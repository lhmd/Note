{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"","title":"\u5173\u4e8e\u6211"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/","text":"\u63a5\u89e6\u8ba1\u7b97\u673a\u89c6\u89c9\u76f8\u5173\u7684\u7b2c\u4e00\u95e8\u8bfe\u7a0b\u3002 Lec 1 Introduction \u00b6 1 CV\u4e3b\u8981\u4efb\u52a1\uff1a \u00b6 \u4e09\u7ef4\u91cd\u5efa \u56fe\u50cf\u7406\u89e3 \u56fe\u50cf\u5408\u6210 2 Review of Linear Algebra \u00b6 \u7701\u7565\u3002\u3002\u3002 Lec 2 Image formation \u00b6 1 Camera and lens \u00b6 Pinhole camera \u00b6 Add a barrier to block off most of the rays, the opening known as the aperture(\u5149\u5708). Lens \u00b6 Focal length: \\[\\frac{1}{i}+\\frac{1}{o}=\\frac{1}{f}\\] Image Magnification: \\[m=\\frac{h_i}{h_o}\\] Field of View (FOV): Longer focal length = Narrower angle of view Shorter focal length = Wider angle of view FOV also depends on sensor size Aperture: control image brightness F-number: represent aperture as a fraction of focal length Depth of Field: range of object distances over which the image is sufficiently well focused 2 Geometric image formation \u00b6 Pinhole camera model: Perspective Projection \u00b6 Homogeneous coordinates \u00b6 Converting from Cartesian to Homogeneous coordinates(add an extra dimension) Converting from Homogeneous to Cartesian(remove the last dimension by dividing a number) Homogeneous coordinates are invariant to scaling. Each point has an infinite set of homogeneous coordinates. The point in the 2D plane is projection of a ray in 3D space: Perspective Projection \u00b6 Orthographic projection \u00b6 3 Photometric image formation \u00b6 Shutter speed \u00b6 Shutter speed controls exposure time. The pixel value is equal to the integral of the light intensity within the exposure time. Rolling shutter effect \u00b6 Exposing the image line by line. Color spaces \u00b6 RGB HSV (Hue / Value / Saturation) Color Sensing: Bayer filter \u00b6 Lec 3 Image processing \u00b6 1 Image processing basics \u00b6 Convolution \u00b6 2D convolution \u00b6 Discrete 2D convolution \u00b6 This can also be the same with the vector/matrix dot product. Padding \u00b6 Adding pixels around the image border. Blur \u00b6 box\u6ee4\u6ce2\uff1a\u5377\u79ef\u6838\u5168\u4e3a1 \u9ad8\u65af\u6ee4\u6ce2\uff1a\u7279\u5b9a\u51fd\u6570 Sharpen \u00b6 Sharpening is adding high frequencies. Let be the original image. High frequencies in image is J-blur(I), blur(I) is the low frequencied in image. Sharpened image is I+(I-blur(I)). Gradient detection filter \u00b6 Bilateral filter \u00b6 2 Image sampling \u00b6 Change image size / resolution. resolution: pixel / inch Reducing image size \u00b6 \u964d\u91c7\u6837\uff0c\u53bb\u6389\u65c1\u8fb9\u7684\u50cf\u7d20\u6216\u8005\u53d6\u5747\u503c Aliasing \u00b6 Aliasing - artifacts due to sampling Signals are changing too fast but sampled too slow. Anti-aliasing \u00b6 How to do anti-aliasing Convolve the image with low-pass filters (e.g. Gaussian). Sample it with a Nyquist rate. Fourier Transform \u00b6 Represent a function as a weighted sum of sines and cosines. 3 Image magnification \u00b6 Interpolation \u00b6 Nearest-neighbor interpolation Linear interpolation Cubic spline interpolation (Polynomial interpolation) Each interval of function has different parameters Bilinear Interpolation (2D) Bilinear Interpolation is good enough. Seam Carving \u00b6 A method to change aspect ratio. Find connected path of pixels from top to bottom of which the edge energy is minimal, removing unnoticeable pixels. Algorithm: DP Lec 4 Model Fitting and Optimization \u00b6 \u672c\u8bb2\u4e0e\u6570\u503c\u5206\u6790\u8bfe\u7a0b\u9ad8\u5ea6\u91cd\u5408 1 Optimization \u00b6 minimize f 0 (x) Model fitting \u00b6 Mean Square Error (MSE) 2 Numerical methods \u00b6 Find a solution path: F (x 0 ) > F (x 1 ) > \u2026 > F (x k ) > \u2026 \u4e0e\u6570\u503c\u5206\u6790\u8bfe\u4e0a\u5185\u5bb9\u7c7b\u4f3c\uff0c\u6cf0\u52d2\u5c55\u5f00\uff0c\u8fdb\u884c\u8fed\u4ee3\uff0c\u505a\u4e00\u9636\u3001\u4e8c\u9636\u8fd1\u4f3c \u68af\u5ea6\u4e0b\u964d\u6cd5\uff1a\u8fed\u4ee3\u6cd5\u7684\u4e00\u79cd \u00b6 Newton method\uff1a\u89c1\u6570\u503c\u5206\u6790\u8bfe\u7a0b \u00b6 \u9ad8\u65af-\u725b\u987f\u8fed\u4ee3 \u00b6 3 Robust estimation \u00b6 Use other loss functions to replace MSE\uff0c\u53bb\u6389\u5f71\u54cd\u5f88\u5927\u7684\u566a\u70b9 Random Sample Concensus (RANSAC) \u00b6 Key ideas The distribution of inliers is similar while outliers differ a lot Use data point pairs to vote 4 Interpolation \u00b6 \u5177\u4f53\u8bf7\u53c2\u8003\u6570\u503c\u5206\u6790 \u7ebf\u6027\u63d2\u503c \u4e09\u6b21\u6837\u6761\u63d2\u503c 5 Graphcut \u00b6 Images as Graphs \u00b6 A vertex for each pixel, an edge between each pair, each edge is weighted by the affinity or similarity between its two vertices. Normalized cut \u00b6 Markov Random Field (MRF) \u00b6 \u9a6c\u5c14\u79d1\u592b\u968f\u673a\u573a\uff0c\u6ca1\u770b\u61c2 Lec 5 Image Matching and Motion Estimation \u00b6 1 Image matching \u00b6 Finding point-to-point correspondences between two images. Steps \u00b6 Detection: Identify the interest points (key points). Description: Extract vector feature descriptor surrounding each interest point. Matching: Determine correspondence between descriptors in two views. detection \u00b6 Principal Component Analysis (PCA) \u89d2\u70b9\u68c0\u6d4b Compute the covariance matrix at each point Compute eigenvalues Classify points using eigenvalues of H: Blob detector \u00b6 Blobs are have large second derivatives in image intensity. Description \u00b6 SIFT descriptor\uff1aScale Invariant Feature Transform descriptor, use histogram of oriented gradients. SIFT Algorithm Run DoG detector to find maximum in location/scale space. Find dominate orientation and normalize the orientation. For each (x, y, scale, orientation), create the only descriptor. Matching \u00b6 Define the difference between two features f1 , f2, distance L2 = ||f1 \u2212 f2 || 2 Motion estimation \u00b6 Problem \u00b6 Both feature matching and motion estimation are called correspondence problems. \u7279\u5f81\u8ffd\u8e2a\uff1a Extract feature (interest) points and \"track\" them over multiple frames. Output: displacement of sparse points \u5149\u6d41\u6cd5\uff1a Recover image motion at each pixel Output: dense displacement field (optical flow filed) Lucas-Kanade Method \u00b6 Key assumptions\uff1a Small motion: points do not move very far Brightness constancy: same point looks the same(in brightness) in every frame Spatial coherence: points move like their neighbors \u672c\u8bb2\u5c0f\u603b\u7ed3\uff1a Lec 6 Image stitching \u00b6 1 Image Warping \u00b6 Change shape of image Linear Transformmation \u00b6 Linear map = Matrices Affine Transformation \u00b6 Affine map = linear map + translation Using homogenous coordinates 6 unknowns in equations 2 equations for each match we need at least 3 matches to solve a affine transformation for n matches, solve with least squares The result of solution must be remembered. the last row with matrix must be [0 0 1] Projective Transformation (Homography) \u00b6 8 unknowns in equations Homography matrix is up to scale (can be multiplied by a scalar), which means the degree of freedom is 8 . 2 equations for each match we need at least 4 matches to solve the homography for n matches, solve with ||h|| = 1 h = eigenvector of A T A with smallest eigenvalue DoF \u00b6 Translation: The degree of freedom is 2 Affine: The degree of freedom is 6 Projective: The degree of freedom is 8 Forward Warping \u00b6 Inverse Warping \u00b6 if pixel lands between pixels, we interpolate color values from neighboring pixels. nearest neighbor bilinear (usually this method is enough) bicubic 2 Image Stitching \u00b6 Algorithm: Input images Feature matching Compute transformation matrix with RANSAC Fix image 1 and warp image 2 Cylindrical projection: Lec 7 Structure from Motion \u00b6 Target: recover camera poses and 3D structure of a scene from its images 1 Camera calibration \u00b6 \u56fe\u50cf\u5904\u7406 \u00b6 \u53c2\u8003\u6587\u732e\uff1a \u56fe\u50cf\u5904\u7406\u2014\u2014\u76f8\u673a\u6807\u5b9a \u4e16\u754c\u5750\u6807\u7cfb\uff08world coordinate\uff09( xw,yw,zw )\uff0c\u4e5f\u79f0\u4e3a\u6d4b\u91cf\u5750\u6807\u7cfb\uff0c\u662f\u4e00\u4e2a\u4e09\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u4ee5\u5176\u4e3a\u57fa\u51c6\u53ef\u4ee5\u63cf\u8ff0\u76f8\u673a\u548c\u5f85\u6d4b\u7269\u4f53\u7684\u7a7a\u95f4\u4f4d\u7f6e\u3002\u4e16\u754c\u5750\u6807\u7cfb\u7684\u4f4d\u7f6e\u53ef\u4ee5\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u81ea\u7531\u786e\u5b9a\u3002\u4e16\u754c\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u76f8\u673a\u5750\u6807\u7cfb\uff08camera coordinate\uff09( xc,yc,zc )\uff0c\u4e5f\u662f\u4e00\u4e2a\u4e09\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u539f\u70b9\u4f4d\u4e8e\u955c\u5934\u5149\u5fc3\u5904\uff0cxc\u3001yc\u8f74\u5206\u522b\u4e0e\u50cf\u9762\u7684\u4e24\u8fb9\u5e73\u884c\uff0czc\u8f74\u4e3a\u955c\u5934\u5149\u8f74\uff0c\u4e0e\u50cf\u5e73\u9762\u5782\u76f4\u3002\u76f8\u673a\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u56fe\u50cf\u5750\u6807\u7cfb\uff08image coordinate\uff09( x , y )\uff0c\u662f\u50cf\u5e73\u9762\u4e0a\u7684\u4e8c\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\u3002\u56fe\u50cf\u5750\u6807\u7cfb\u7684\u539f\u70b9\u4e3a\u955c\u5934\u5149\u8f74\u4e0e\u50cf\u5e73\u9762\u7684\u4ea4\u70b9\uff08\u4e5f\u79f0\u4e3b\u70b9\uff0cprincipal point\uff09\uff0c\u5b83\u7684x\u8f74\u4e0e\u76f8\u673a\u5750\u6807\u7cfb\u7684xc\u8f74\u5e73\u884c\uff0c\u5b83\u7684y\u8f74\u4e0e\u76f8\u673a\u5750\u6807\u7cfb\u7684yc\u8f74\u5e73\u884c\u3002\u56fe\u50cf\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u50cf\u7d20\u5750\u6807\u7cfb\uff08pixel coordinate\uff09(u,v)\uff0c\u662f\u56fe\u50cf\u5904\u7406\u5de5\u4f5c\u4e2d\u5e38\u7528\u7684\u4e8c\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u53cd\u6620\u4e86\u76f8\u673aCCD/CMOS\u82af\u7247\u4e2d\u50cf\u7d20\u7684\u6392\u5217\u60c5\u51b5\u3002\u5b83\u7684\u539f\u70b9\u4f4d\u4e8e\u56fe\u50cf\u5de6\u4e0a\u89d2\uff0c\u6a2a\u5750\u6807u\u8868\u793a\u50cf\u7d20\u6240\u5728\u7684\u5217\uff0c\u7eb5\u5750\u6807v\u8868\u793a\u50cf\u7d20\u6240\u5728\u7684\u884c\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u53ef\u4ee5\u7b80\u5355\u7406\u89e3\u4e3a\u5e73\u79fb\u5173\u7cfb\uff0c\u5b83\u4eec\u540c\u5904\u4e8e\u50cf\u5e73\u9762\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u7684x\u8f74\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u7684u\u8f74\u5e73\u884c\uff0c\u50cf\u7d20\u5750\u6807\u7cfb\u7684y\u8f74\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u7684v\u8f74\u5e73\u884c\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3a\u50cf\u7d20\u3002 \u53d8\u6362\u8fc7\u7a0b\uff1a \u4e16\u754c=\u300b\u76f8\u673a=\u300b\u56fe\u50cf=\u300b\u50cf\u7d20 so, it is similar to lab2. \u4e16\u754c\u76f4\u63a5\u8f6c\u6362\u4e3a\u50cf\u7d20\uff1a \u89e3\u65b9\u7a0b\u65f6\uff1a \u627e\u7279\u5f81\u70b9\uff0c\u5efa\u7acb\u65b9\u7a0b\u6c42\u89e3\u672a\u77e5\u6570 \\(p\\) \u5177\u4f53\u67e5\u770b\u53c2\u8003\u6587\u732e\u548c\u8bfe\u7a0bPPT PnP\u95ee\u9898 \u00b6 \u53c2\u8003\u6587\u732e\uff1a PnP\u95ee\u9898\u5404\u79cd\u7b97\u6cd5\u603b\u7ed3\u5206\u6790 \u95ee\u9898\u63cf\u8ff0\uff1a\u5df2\u77e5n\u4e2a3D\u70b9\u7684\u5750\u6807(\u76f8\u5bf9\u4e16\u754c\u5750\u6807\u7cfb)\u4ee5\u53ca\u8fd9\u4e9b\u70b9\u7684\u50cf\u7d20\u5750\u6807\u65f6\uff0c\u5982\u4f55\u4f30\u8ba1\u76f8\u673a\u7684\u4f4d\u59ff Direct Linear Transform (DLT) \u00b6 \u524d\u9762\u6211\u4eec\u901a\u8fc7\u89e3\u65b9\u7a0b\u7684\u5f62\u5f0f\u89e3\u51fa\u4e86\u8fd9\u4e2a\u65b9\u7a0b\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5c31\u53eb\u505aDLT\u3002 P3P \u00b6 \u81f3\u5c11\u4e09\u4e2a\u5bf9\u5e94\u5173\u7cfb\u53ef\u4ee5\u89e3\u51fa\u76f8\u673a\u5750\u6807\uff0c\u8fd8\u9700\u8981\u4e00\u4e2a\u5bf9\u5e94\u5173\u7cfb\u4f7f\u8fd9\u4e2a\u89e3\u662f\u7279\u89e3\u3002 EPnP \u00b6 Main steps: Represent each point as the linear combination of 4 control points c i . Construct a linear system in the control-point coordinate. Solve the equation. 2 Two-frame structure from motion \u00b6 Assume Camera Matrix \ud835\udc3e is known for each camera Find a few Reliable Corresponding Points Find Relative Camera Position \ud835\udc2d and Orientation \ud835\udc45 Find 3D position of scene points \u8be6\u7ec6\u8bb2\u89e3\uff1a \u5bf9\u6781\u51e0\u4f55--\u77e5\u4e4e \u200b \u5bf9\u6781\u51e0\u4f55--github 3 Multi-frame structure from motion \u00b6 Initialize camera motion and scene structure For each additional view - Determine projection matrix of new camera using all the known 3D points that are visible in its image - Refine and extend structure: compute new 3D points, reoptimize existing points that are also seen by this camera Refine structure and motion: Bundle Adjustment 4 A modern SfM system: COLMAP \u00b6 sfM: Structure-from-Motion MVS: Multi-View Stereo Lec 8 Depth estimation and 3D reconstruction \u00b6 1 Depth estimation \u00b6 1.1 Introduction \u00b6 \u200b \u6df1\u5ea6\u4f20\u611f\u5668\u987e\u540d\u601d\u4e49\u662f\u7528\u6765\u63a2\u6d4b\u73af\u5883\u7269\u4f53\u4e0e\u4f20\u611f\u5668\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u3002\u5b83\u7684\u8f93\u51fa\u4e3b\u8981\u53ef\u4ee5\u8868\u793a\u4e3a\u6df1\u5ea6\u56fe(depth map)\u548c\u70b9\u4e91(point cloud)\u8fd9\u4e24\u79cd\u5f62\u5f0f\u3002 \u200b \u6df1\u5ea6\u56fe\u50cf\uff08depth image)\u4e5f\u88ab\u79f0\u4e3a\u8ddd\u79bb\u5f71\u50cf\uff08range image\uff09\uff0c\u662f\u6307\u5c06\u4ece\u56fe\u50cf\u91c7\u96c6\u5668\u5230\u573a\u666f\u4e2d\u5404\u70b9\u7684\u8ddd\u79bb\uff08\u6df1\u5ea6\uff09\u4f5c\u4e3a\u50cf\u7d20\u503c\u7684\u56fe\u50cf\uff0c\u5b83\u76f4\u63a5\u53cd\u6620\u4e86\u666f\u7269\u53ef\u89c1\u8868\u9762\u7684\u51e0\u4f55\u5f62\u72b6\u3002\u6df1\u5ea6\u56fe\u50cf\u7ecf\u8fc7\u5750\u6807\u8f6c\u6362\u53ef\u4ee5\u8ba1\u7b97\u4e3a\u70b9\u4e91\u6570\u636e\uff0c\u6709\u89c4\u5219\u53ca\u5fc5\u8981\u4fe1\u606f\u7684\u70b9\u4e91\u6570\u636e\u4e5f\u53ef\u4ee5\u53cd\u7b97\u4e3a\u6df1\u5ea6\u56fe\u50cf\u6570\u636e\u3002 \u6df1\u5ea6\u6570\u636e\u6d41\u6240\u63d0\u4f9b\u7684\u56fe\u50cf\u5e27\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u50cf\u7d20\u70b9\u4ee3\u8868\u7684\u662f\u5728\u6df1\u5ea6\u611f\u5e94\u5668\u7684\u89c6\u91ce\u4e2d\uff0c\u8be5\u7279\u5b9a\u7684\uff08x, y\uff09\u5750\u6807\u5904\u7269\u4f53\u5230\u79bb\u6444\u50cf\u5934\u5e73\u9762\u6700\u8fd1\u7684\u7269\u4f53\u5230\u8be5\u5e73\u9762\u7684\u8ddd\u79bb\uff08\u4ee5\u6beb\u7c73\u4e3a\u5355\u4f4d\uff09\u3002 \u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f(Passive depth sensing) \u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f=\u4e24\u4e2a\u76f8\u9694\u4e00\u5b9a\u8ddd\u79bb\u7684\u76f8\u673a\u83b7\u5f97\u4e24\u5e45\u56fe\u50cf+\u7acb\u4f53\u5339\u914d+\u4e09\u89d2\u539f\u7406\u8ba1\u7b97\u89c6\u5dee\uff08disparity\uff09 \u200b \u4e24\u4e2a\u76f8\u9694\u4e00\u5b9a\u8ddd\u79bb\u7684\u6444\u50cf\u673a\u540c\u65f6\u83b7\u53d6\u540c\u4e00\u573a\u666f\u7684\u4e24\u5e45\u56fe\u50cf\uff0c\u901a\u8fc7\u7acb\u4f53\u5339\u914d\u7b97\u6cd5\u627e\u5230\u4e24\u5e45\u56fe\u50cf\u4e2d\u5bf9\u5e94\u7684\u50cf\u7d20\u70b9\uff0c\u968f\u540e\u6839\u636e\u4e09\u89d2\u539f\u7406\u8ba1\u7b97\u51fa\u89c6\u5dee\u4fe1\u606f\uff0c\u800c\u89c6\u5dee\u4fe1\u606f\u901a\u8fc7\u8f6c\u6362\u53ef\u7528\u4e8e\u8868\u5f81\u573a\u666f\u4e2d\u7269\u4f53\u7684\u6df1\u5ea6\u4fe1\u606f\u3002\u57fa\u4e8e\u7acb\u4f53\u5339\u914d\u7b97\u6cd5\uff0c\u8fd8\u53ef\u901a\u8fc7\u62cd\u6444\u540c\u4e00\u573a\u666f\u4e0b\u4e0d\u540c\u89d2\u5ea6\u7684\u4e00\u7ec4\u56fe\u50cf\u6765\u83b7\u5f97\u8be5\u573a\u666f\u7684\u6df1\u5ea6\u56fe\u50cf\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u573a\u666f\u6df1\u5ea6\u4fe1\u606f\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5bf9\u56fe\u50cf\u7684\u5149\u5ea6\u7279\u5f81\u3001\u660e\u6697\u7279\u5f81\u7b49\u7279\u5f81\u8fdb\u884c\u5206\u6790\u95f4\u63a5\u4f30\u7b97\u5f97\u5230\u3002 \u4e3b\u52a8\u6d4b\u8ddd\u4f20\u611f(Active depth sensing) \u200b \u4e3b\u52a8\u6d4b\u8ddd\u4f20\u611f\u76f8\u6bd4\u8f83\u4e8e\u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f\u6700\u660e\u663e\u7684\u7279\u5f81\u662f\uff1a\u8bbe\u5907\u672c\u8eab\u9700\u8981\u53d1\u5c04\u80fd\u91cf\u6765\u5b8c\u6210\u6df1\u5ea6\u4fe1\u606f\u7684\u91c7\u96c6\u3002\u8fd9\u4e5f\u5c31\u4fdd\u8bc1\u4e86\u6df1\u5ea6\u56fe\u50cf\u7684\u83b7\u53d6\u72ec\u7acb\u4e8e\u5f69\u8272\u56fe\u50cf\u7684\u83b7\u53d6\u3002\u8fd1\u5e74\u6765\uff0c\u4e3b\u52a8\u6df1\u5ea6\u4f20\u611f\u5728\u5e02\u9762\u4e0a\u7684\u5e94\u7528\u6108\u52a0\u4e30\u5bcc\u3002\u4e3b\u52a8\u6df1\u5ea6\u4f20\u611f\u7684\u65b9\u6cd5\u4e3b\u8981\u5305\u62ec\u4e86TOF\uff08Time of Flight\uff09\u3001\u7ed3\u6784\u5149\u3001\u6fc0\u5149\u626b\u63cf\u7b49\u3002 1.2 Stereo matching \u00b6 \u53c2\u8003\u8d44\u6599 3D\u89c6\u89c9\u4e4b\u7acb\u4f53\u5339\u914d \u7acb\u4f53\u5339\u914d\u7b97\u6cd5 \u6700\u7b80\u5355\u7684\u7b97\u6cd5\uff1a For each pixel in the first image Find corresponding epipolar line in the right image Search along epipolar line and pick the best match Simplest case: epipolar lines are horizontal scanlines \u8fd9\u6837\u5c31\u627e\u5230\u4e86\u4e24\u4e2a\u76f8\u540c\u7684\u70b9\uff0c\u7136\u540e\u8ba1\u7b97\u6df1\u5ea6\u3002 \u5982\u679c\u89c6\u89d2\u4e0d\u5728\u540c\u4e00\u6c34\u5e73\u7ebf\u4e0a\uff0c\u5c31\u5148\u628a\u4ed6\u4eec\u8f6c\u5230\u540c\u4e00\u6c34\u5e73\u7ebf\u3002 Stereo as energy minimization\uff1a\u8ba9\u5f53\u524d\u50cf\u7d20\u7684\u4ee3\u4ef7\u805a\u5408\u8fc7\u7a0b\u53d7\u591a\u4e2a\u65b9\u5411(\u6216\u8def\u5f84)\u4e0a\u6240\u6709\u50cf\u7d20\u7684\u5f71\u54cd\uff0c\u65b9\u5411\u8d8a\u591a\u53c2\u4e0e\u5f71\u54cd\u5f53\u524d\u50cf\u7d20\u7684\u90bb\u57df\u50cf\u7d20\u5c31\u8d8a\u591a \u52a8\u6001\u89c4\u5212\uff1a Choosing the stereo baseline\uff1a Too small: large depth error Too large: difficult search problem 1.3 Multi-view stereo \u00b6 Plane-Sweep: \u5e73\u9762\u626b\u63cf\u7b97\u6cd5 PatchMatch: PatchMatch Initialize pixels with random patch offsets Check if neighbors have better patch offsets Search in concentric radius around the current offset for better better patch offsets Go to Step 2 until converge. 2 3D reconstruction \u00b6 2.1 3D representations \u00b6 \u70b9\u4e91 mesh \u7528G(E, V)\u8868\u793a voxel SDF(Signed Distance Function) The distance of a point to the shape boundary The distance is defined by a metric, usually the Euclidean distance Truncated Signed Distance Function (TSDF): Truncation SDF\u2019s distance value to [\u22121, 1] 2.2 3D surface reconstruction \u00b6 KinectFusion \u6cca\u677e\u91cd\u5efa Marching Cubes\u7b97\u6cd5 \u89c6\u9891\u4ecb\u7ecdMarching Cubes\u7b97\u6cd5: Marching Squares \u57fa\u672c\u548cMarching cubes \u7c7b\u4f3c\u3002 COLMAP : \u4e00\u79cd\u901a\u7528\u7684\u8fd0\u52a8\u7ed3\u6784 (SfM) \u548c\u591a\u89c6\u56fe\u7acb\u4f53 (MVS) \u7ba1\u9053\u3002 2.3 Texture mapping \u00b6 Surface lives in 3D world space Every 3D surface point also has a place where it goes in the 2D image (texture). \u7eb9\u7406\u6620\u5c04(Texture mapping) Lec 9 Deep Learning \u00b6 1 Machine learning \u00b6 \u4f20\u7edf\u7a0b\u5e8f\u662f\u7ed9\u7535\u8111\u8f93\u5165\u548c\u7a0b\u5e8f\uff0c\u7535\u8111\u7ed9\u51fa\u8f93\u51fa\u3002 \u673a\u5668\u5b66\u4e60\u662f\u7ed9\u7535\u8111\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u7535\u8111\u7ed9\u51fa\u7a0b\u5e8f\u3002 \u6982\u5ff5 \u00b6 Model: \\(x\\) \u548c \\(y\\) \u4e4b\u95f4\u5173\u7cfb\u7684\u6570\u5b66\u8868\u793a Supervised learning(\u76d1\u7763\u5b66\u4e60): \u53ef\u4ee5\u7531\u8bad\u7ec3\u8d44\u6599\u4e2d\u5b66\u5230\u6216\u5efa\u7acb\u4e00\u4e2a\u6a21\u5f0f\uff08\u51fd\u6570/learning model\uff09\uff0c\u5e76\u4e14\u4f9d\u6b21\u6a21\u5f0f\u63a8\u6d4b\u51fa\u65b0\u7684\u5b9e\u4f8b\u3002 labeled data: exisitng (x,y) pairs, called training data. \u673a\u5668\u5b66\u4e60\u7684\u4e24\u4e2a\u9636\u6bb5\uff1a \u8bad\u7ec3(Training) \u6d4b\u8bd5(Testing) 2 Linear classifier \u00b6 CLassification model \u00b6 \u8f93\u5165\u662f\u4e00\u5f20\u56fe\u7247 \u8f93\u51fa\u662f\u6bcf\u4e2a\u5206\u7c7b\u7684\u5bf9\u5e94\u5206\u6570 \u6709\u4e24\u90e8\u5206\u7ec4\u6210\uff1a \u8bc4\u5206\u51fd\u6570 \u635f\u5931\u51fd\u6570 Linear classifier \u00b6 \u5c06\u4e00\u5f20\u7167\u7247\u91cc\u9762\u7684\u6240\u6709\u50cf\u7d20\u53d8\u6210\u4e00\u4e2a\u5411\u91cf\u3002 \\(f(x_i,W,b) = Wx_i + b\\) \u53c2\u6570 W \u88ab\u79f0\u4e3a \u6743\u91cd\uff08weights\uff09 \uff0c b \u88ab\u79f0\u4e3a \u504f\u5dee\u5411\u91cf\uff08bias vector\uff09 \u3002 \u9996\u5148\uff0c\u4e00\u4e2a\u5355\u72ec\u7684\u77e9\u9635\u4e58\u6cd5 \\(Wx_i\\) \u5c31\u9ad8\u6548\u5730\u5e76\u884c\u8bc4\u4f3010\u4e2a\u4e0d\u540c\u7684\u5206\u7c7b\u5668\uff08\u6bcf\u4e2a\u5206\u7c7b\u5668\u9488\u5bf9\u4e00\u4e2a\u5206\u7c7b\uff09\uff0c\u5176\u4e2d\u6bcf\u4e2a\u7c7b\u7684\u5206\u7c7b\u5668\u5c31\u662fW\u7684\u4e00\u4e2a\u884c\u5411\u91cf\u3002 \u8bad\u7ec3\u6570\u636e\u7528\u6765\u5b66\u4e60 \\(W\\) \u548c \\(b\\) \u4e00\u5f20\u56fe\u50cf\u53ef\u770b\u505a\u9ad8\u7ef4\u7a7a\u95f4\u7684\u4e00\u4e2a\u70b9\uff0c\u6bcf\u4e2a\u5206\u7c7b\u5c31\u662f\u628a\u8fd9\u4e9b\u70b9\u5212\u5206\u6210\u82e5\u5e72\u4e2a\u533a\u57df\u3002 Loss function \u00b6 \u5224\u65ad\u4e00\u4e2a\u6743\u91cd\u77e9\u9635\u662f\u5426\u8db3\u591f\u597d \u56de\u5f52\u95ee\u9898\u4f7f\u7528\u5747\u65b9\u8bef\u5dee(MSE) \u5206\u7c7b\u95ee\u9898\u4f7f\u7528\u4ea4\u53c9\u71b5(Cross Entropy Loss) \u53c2\u8003\u8d44\u6599\uff1a \u7b80\u5355\u8c08\u8c08Cross Entropy Loss Softmax: \u628aK\u4e2a\u5b9e\u503c\u8f6c\u6362\u4e3a\u53e6\u5916K\u4e2a\u5b9e\u503c\u5e76\u4f7fK\u4e2a\u5b9e\u503c\u4e4b\u548c\u4e3a1\u7684\u51fd\u6570\u3002 3 Neural networks \u00b6 \u53c2\u8003\u8d44\u6599\uff1a \u6fc0\u6d3b\u51fd\u6570\uff08Activation Function\uff09 \u200b \u6fc0\u6d3b\u51fd\u6570 \uff1a\u4e0d\u4f7f\u7528\u6fc0\u6d3b\u51fd\u6570\u7684\u8bdd\uff0c\u795e\u7ecf\u7f51\u7edc\u7684\u6bcf\u5c42\u90fd\u53ea\u662f\u505a \u7ebf\u6027\u53d8\u6362 \uff0c\u591a\u5c42\u8f93\u5165\u53e0\u52a0\u540e\u4e5f\u8fd8\u662f\u7ebf\u6027\u53d8\u6362\u3002\u56e0\u4e3a\u7ebf\u6027\u6a21\u578b\u7684\u8868\u8fbe\u80fd\u529b\u901a\u5e38\u4e0d\u591f\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5c31\u4f53\u73b0\u4e86\u6fc0\u6d3b\u51fd\u6570\u7684\u4f5c\u7528\u4e86\uff0c\u6fc0\u6d3b\u51fd\u6570\u53ef\u4ee5\u5f15\u5165 \u975e\u7ebf\u6027\u56e0\u7d20 \u3002 \u200b \u5728\u795e\u7ecf\u7f51\u7edc\u6bcf\u4e00\u5c42\u795e\u7ecf\u5143\u505a\u5b8c\u7ebf\u6027\u53d8\u6362\u540e\uff0c\u52a0\u4e0a\u4e00\u4e2a\u975e\u7ebf\u6027\u6fc0\u52b1\u51fd\u6570\u5bf9\u7ebf\u6027\u53d8\u6362\u7684\u7ed3\u679c\u8fdb\u884c\u8f6c\u6362\uff0c\u8f93\u51fa\u5c31\u53ef\u4ee5\u53d8\u6210\u4e00\u4e2a\u975e\u7ebf\u6027\u7684\u51fd\u6570\u3002 \u591a\u5c42\u611f\u77e5\u5668 \u5168\u8fde\u63a5\u795e\u7ecf\u7f51\u7edc 4 Convolutional neural networks--\u5377\u79ef\u795e\u7ecf\u7f51\u7edc \u00b6 \u53c2\u8003\u8d44\u6599\uff1a \u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u8d85\u8be6\u7ec6\u4ecb\u7ecd Convolution = local connectivity + weight sharing \u00b6 \u4e24\u8005\u7684\u5173\u952e\u4f5c\u7528\u5c31\u662f\u51cf\u5c11\u53c2\u6570\u6570\u91cf\uff0c\u4f7f\u8fd0\u7b97\u53d8\u5f97\u7b80\u6d01\u3001\u9ad8\u6548\uff0c\u80fd\u591f\u5728\u8d85\u5927\u89c4\u6a21\u6570\u636e\u96c6\u4e0a\u8fd0\u7b97 local connectivity(\u5c40\u90e8\u8fde\u63a5): \u5bf9\u4e8e\u5c40\u90e8\u8fde\u63a5\u800c\u8a00\uff1a\u5c42\u95f4\u795e\u7ecf\u53ea\u6709\u5c40\u90e8\u8303\u56f4\u5185\u7684\u8fde\u63a5\uff0c\u5728\u8fd9\u4e2a\u8303\u56f4\u5185\u91c7\u7528\u5168\u8fde\u63a5\u7684\u65b9\u5f0f\uff0c\u8d85\u8fc7\u8fd9\u4e2a\u8303\u56f4\u7684\u795e\u7ecf\u5143\u5219\u6ca1\u6709\u8fde\u63a5\uff1b\u8fde\u63a5\u4e0e\u8fde\u63a5\u4e4b\u95f4\u72ec\u7acb\u53c2\u6570\uff0c\u76f8\u6bd4\u4e8e\u53bb\u5168\u8fde\u63a5\u51cf\u5c11\u4e86\u611f\u53d7\u57df\u5916\u7684\u8fde\u63a5\uff0c\u6709\u6548\u51cf\u5c11\u53c2\u6570\u89c4\u6a21\u3002 weight sharing(\u6743\u503c\u5171\u4eab): \u4ece\u56fe\u50cf\u5c40\u90e8\u5b66\u4e60\u5230\u7684\u4fe1\u606f\u5e94\u7528\u5230\u56fe\u50cf\u7684\u5176\u4ed6\u90e8\u4f4d\u53bb\u3002\u6743\u503c\u5171\u4eab\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fc7\u6ee4\u5668\u5728\u904d\u5386\u6574\u4e2a\u56fe\u50cf\u7684\u65f6\u5019\uff0c\u8fc7\u6ee4\u5668\u7684\u53c2\u6570(\u5373\u8fc7\u6ee4\u5668\u7684\u53c2\u6570\u7684\u503c)\u662f\u56fa\u5b9a\u4e0d\u53d8\u7684 \u53c2\u8003\uff1a weight sharing \u611f\u53d7\u91ce(Receptive fields) \u00b6 \u82e5\u76ee\u6807\u76f8\u5bf9\u611f\u53d7\u91ce\u8fc7\u5c0f\uff0c\u90a3\u8bad\u7ec3\u53c2\u6570\u53ea\u6709\u5c11\u90e8\u5206\u662f\u5bf9\u5e94\u4e8e\u8bad\u7ec3\u76ee\u6807\u7684\uff0c\u5219\u5728\u6d4b\u8bd5\u73af\u8282\uff0c\u4e5f\u5f88\u96be\u68c0\u6d4b\u51fa\u7c7b\u4f3c\u7684\u76ee\u6807\uff1b \u82e5\u76ee\u6807\u76f8\u5bf9\u611f\u53d7\u91ce\u8fc7\u5927\uff0c\u90a3\u8bad\u7ec3\u7684\u53c2\u6570\u90fd\u662f\u5bf9\u5e94\u4e8e\u6574\u4e2a\u5bf9\u8c61\u7684\u5c40\u90e8\u4fe1\u606f\uff0c\u662f\u4e0d\u591f\u5229\u4e8e\u68c0\u6d4b\u5c0f\u76ee\u6807\u7684\u3002 \u6c60\u5316\u5c42(Pooling layer) \u00b6 \u603b\u4f53\u6846\u67b6 \u00b6 5 Training neural networks \u00b6 \u68af\u5ea6\u4e0b\u964d\u8bad\u7ec3CNN \u00b6 \u53cd\u5411\u4f20\u64ad \u00b6 \u53c2\u8003\uff1a \u53cd\u5411\u4f20\u64ad-cs231n Forward data through the network, get loss Backprop to calculate the gradients Update the parameters using the gradient Go to step 1 if not converged \u968f\u673a\u68af\u5ea6\u4e0b\u964d\u6cd5(SGD) \u00b6 \u53c2\u8003\uff1a \u968f\u673a\u68af\u5ea6\u4e0b\u964d\u8be6\u89e3 \u4ec5\u8ba1\u7b97\u4e00\u6279\u968f\u673a\u91c7\u6837\u56fe\u50cf\u4e0a\u7684\u635f\u5931\u548c\u68af\u5ea6\u3002 \u8d85\u53c2\u6570(hyper-parameters) \u00b6 \u7b97\u6cd5\u8fd0\u884c\u524d\u9700\u8981\u51b3\u5b9a\u7684\u53c2\u6570\u3002 \u9009\u62e9\u4f9d\u636e\uff1a Train for original model Validate to find hyperparameters Test to understand generalizability \u8fc7\u62df\u5408(overfitting) \u00b6 \u628a\u566a\u97f3\u70b9\u4e5f\u62df\u5408\u4e0a\u4e86\uff0c\u8fc7\u5206\u4f9d\u8d56\u6570\u636e\u96c6\u3002 \u9632\u6b62\uff1a Cross validation(\u9a8c\u8bc1) and early stop Regularization(\u6b63\u5219\u5316) or dropout \u6b63\u5219\u5316 \uff1a\u5728\u635f\u5931\u51fd\u6570\u4e2d\u7ed9\u6bcf\u4e2a\u53c2\u6570 w \u52a0\u4e0a\u6743\u91cd\uff0c\u5f15\u5165\u6a21\u578b\u590d\u6742\u5ea6\u6307\u6807\uff0c\u4ece\u800c\u6291\u5236\u6a21\u578b\u566a\u58f0\uff0c\u51cf\u5c0f\u8fc7\u62df\u5408\u3002 dropout \uff1a\u5728\u524d\u5411\u4f20\u64ad\u7684\u65f6\u5019\uff0c\u8ba9\u67d0\u4e2a\u795e\u7ecf\u5143\u7684\u6fc0\u6d3b\u503c\u4ee5\u4e00\u5b9a\u7684\u6982\u7387p\u505c\u6b62\u5de5\u4f5c\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u6a21\u578b\u6cdb\u5316\u6027\u66f4\u5f3a\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4f1a\u592a\u4f9d\u8d56\u67d0\u4e9b\u5c40\u90e8\u7684\u7279\u5f81 Data augmentation(\u6570\u636e\u589e\u5f3a) \u53c2\u8003\uff1a \u6570\u636e\u589e\u5f3a(Data Augmentation) \u200b \u4e3a\u4e86\u83b7\u5f97\u66f4\u591a\u7684\u6570\u636e\uff0c\u6211\u4eec\u53ea\u8981\u5bf9\u73b0\u6709\u7684\u6570\u636e\u96c6\u8fdb\u884c\u5fae\u5c0f\u7684\u6539\u53d8\u3002\u6bd4\u5982\u65cb\u8f6c\uff08flips\uff09\u3001\u79fb\u4f4d\uff08translations\uff09\u3001\u65cb\u8f6c\uff08rotations\uff09\u7b49\u5fae\u5c0f\u7684\u6539\u53d8\u3002\u6211\u4eec\u7684\u7f51\u7edc\u4f1a\u8ba4\u4e3a\u8fd9\u662f\u4e0d\u540c\u7684\u56fe\u7247\u3002 \u6279\u6807\u51c6\u5316(Batch Normalization) \u00b6 \u53c2\u8003 \u6df1\u5165\u7406\u89e3BN \u200b \u76ee\u7684\uff1aReduce internal covariate shift( \u5185\u90e8\u534f\u53d8\u91cf\u504f\u79fb ) \u200b \u795e\u7ecf\u7f51\u7edc\u7684\u6df1\u5ea6\u589e\u52a0\uff0c\u6bcf\u5c42\u7279\u5f81\u503c\u5206\u5e03\u4f1a\u9010\u6e10\u7684\u5411\u6fc0\u6d3b\u51fd\u6570\u7684\u8f93\u51fa\u533a\u95f4\u7684\u4e0a\u4e0b\u4e24\u7aef\uff08\u6fc0\u6d3b\u51fd\u6570\u9971\u548c\u533a\u95f4\uff09\u9760\u8fd1\uff0c\u8fd9\u6837\u7ee7\u7eed\u4e0b\u53bb\u5c31\u4f1a\u5bfc\u81f4\u68af\u5ea6\u6d88\u5931\u3002BN\u5c31\u662f\u901a\u8fc7\u65b9\u6cd5\u5c06 \u8be5\u5c42\u7279\u5f81\u503c\u5206\u5e03\u91cd\u65b0\u62c9\u56de\u6807\u51c6\u6b63\u6001\u5206\u5e03 \uff0c\u7279\u5f81\u503c\u5c06\u843d\u5728\u6fc0\u6d3b\u51fd\u6570\u5bf9\u4e8e\u8f93\u5165\u8f83\u4e3a\u654f\u611f\u7684\u533a\u95f4\uff0c\u8f93\u5165\u7684\u5c0f\u53d8\u5316\u53ef\u5bfc\u81f4\u635f\u5931\u51fd\u6570\u8f83\u5927\u7684\u53d8\u5316\uff0c\u4f7f\u5f97\u68af\u5ea6\u53d8\u5927\uff0c\u907f\u514d\u68af\u5ea6\u6d88\u5931\uff0c\u540c\u65f6\u4e5f\u53ef\u52a0\u5feb\u6536\u655b\u3002 \u200b \u8bad\u7ec3\u65f6\u7684\u4f7f\u7528\u65b9\u6cd5\uff1a\u5bf9\u6bcf\u4e2a\u9690\u5c42\u52a0\u4e0a\u4e00\u5c42BN\u3002 6 Network architectures \u00b6 \u4ee5\u524d\u53d1\u5c55\u4e0d\u597d\uff1a \u6570\u636e\u96c6\u8fc7\u5c0f\u5bfc\u81f4\u8fc7\u62df\u5408 \u8ba1\u7b97\u80fd\u529b\u4e0d\u591f AlexNet ResNet DenseNet \uff1a\u4e92\u76f8\u8fde\u63a5\u6240\u6709\u7684\u5c42 MobileNets Neural Architecture Search (\u795e\u7ecf\u67b6\u6784\u641c\u7d22) Lec 10 Recognition \u00b6 1 Semantic segmentation(\u8bed\u4e49\u5206\u5272) \u00b6 \u5728\u56fe\u50cf\u9886\u57df\uff0c\u8bed\u4e49\u6307\u7684\u662f\u56fe\u50cf\u7684\u5185\u5bb9\uff0c\u5bf9\u56fe\u7247\u610f\u601d\u7684\u7406\u89e3\uff0c\u6bd4\u5982\u5de6\u56fe\u7684\u8bed\u4e49\u5c31\u662f\u4e09\u4e2a\u4eba\u9a91\u7740\u4e09\u8f86\u81ea\u884c\u8f66\uff1b\u5206\u5272\u7684\u610f\u601d\u662f\u4ece\u50cf\u7d20\u7684\u89d2\u5ea6\u5206\u5272\u51fa\u56fe\u7247\u4e2d\u7684\u4e0d\u540c\u5bf9\u8c61\uff0c\u5bf9\u539f\u56fe\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u90fd\u8fdb\u884c\u6807\u6ce8\u3002 \u540d\u8bcd\u89e3\u91ca \u00b6 \u6ed1\u52a8\u7a97\u53e3\uff1a\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\uff0c\u6709\u9650\u7684\u611f\u53d7\u91ce\u3002 \u5168\u8fde\u63a5\u5377\u79ef\u7f51\u7edc\uff1a\u4e00\u6b21\u505a\u51fa\u9884\u6d4b\uff0c\u635f\u5931\u51fd\u6570\u662f\u6bcf\u4e2a\u50cf\u7d20\u7684\u4ea4\u53c9\u71b5\u3002 Unpolling\uff1a\u4e00\u79cd\u4e0a\u91c7\u6837\u65b9\u6cd5\uff0c\u6709\u5f88\u591a\u79cd\u5177\u4f53\u6848\u4f8b\u3002 U-Net \u00b6 Skip Connection: \u8df3\u8fc7\u4e2d\u95f4\u8fde\u63a5\uff0c\u4f7f\u6df1\u5c42\u548c\u6d45\u5c42\u8fde\u63a5\u8d77\u6765\u3002 DeepLab \u00b6 \u53c2\u8003: \u56fe\u50cf\u8bed\u4e49\u5206\u5272\u4e4bFCN\u548cCRF \u56fe\u50cf\u8bed\u4e49\u5206\u5272\u6b65\u9aa4\uff1a FCN - \u5168\u5377\u79ef\u7f51\u7edc CRF - \u6761\u4ef6\u968f\u673a\u573a(Conditional random field) MRF - \u9a6c\u5c14\u79d1\u592b\u968f\u673a\u573a \u8bc4\u4f30\u6307\u6807 \u00b6 Per-pixel Intersection-over-union 2 Object detection(\u76ee\u6807\u68c0\u6d4b) \u00b6 \u8f93\u5165\uff1a\u4e00\u5f20RGB\u56fe\u7247 \u8f93\u51fa\uff1a\u8868\u793a\u5bf9\u8c61\u7684\u4e00\u7ec4\u8fb9\u754c\u6846(\u7c7b\u522b\u6807\u7b7e\u3001\u6846\u7684\u4f4d\u7f6e\uff0c\u6846\u7684\u5927\u5c0f) \u5355\u4e2a\u7269\u4f53\u68c0\u6d4b \u00b6 \u591a\u4e2a\u7269\u4f53\u68c0\u6d4b \u00b6 \u4e00\u5f20\u7167\u7247\u7ecf\u8fc7\u5404\u79cd\u4e0d\u540c\u7684\u795e\u7ecf\u7f51\u7edc\uff0c\u5f97\u51fa\u7ed3\u679c\u3002 \u6ed1\u52a8\u7a97\u53e3 \u00b6 Apply a CNN to many different crops of the image, CNN classifies each crop as object or background. \u4e00\u5f20\u56fe\u7247\u53ef\u4ee5\u88ab\u62c6\u5206\u6210\u5f88\u591aboxes\uff0c\u6211\u4eec\u4e0d\u80fd\u68c0\u6d4b\u6240\u6709\u8fd9\u4e9b\u56fe\u7247\u3002 Region proposals(\u5019\u9009\u533a\u57df) \u00b6 \u7528\u56fe\u50cf\u5206\u5272\u7b97\u6cd5\u5148\u5206\u5272\u56fe\u50cf\uff0c\u7136\u540e\u518d\u8fdb\u884c\u76ee\u6807\u68c0\u6d4b\u3002 R-CNN \u00b6 \u9009\u5efa\u8bae\u6846\u5e76\u8c03\u6574\u5c3a\u5bf8 \u5bf9\u6bcf\u4e2a\u7c7b\u522b\u4f7f\u7528SVM\u5206\u7c7b\u5668\u8fdb\u884c\u6253\u5206 \u8fdb\u884c\u7b5b\u9009 \u635f\u5931\u51fd\u6570\uff1a \\(loU=\\frac {Area Of Overlap}{Area Of Union}\\) Mean Average Precision (mAP)\uff1a Run object detector on all test images For each category, compute Average Precision (AP) = area under Precision vs Recall Curve For each detection (highest score to lowest score) If it matches some GT box with IoU > 0.5, mark it as positive and eliminate the GT Otherwise mark it as negative Plot a point on PR Curve Average Precision (AP) = area under PR curve Mean Average Precision (mAP) = average of AP for each category For \u201cCOCO mAP\u201d: Compute mAP@thresh for each IoU threshold (0.5, 0.55, 0.6, \u2026, 0.95) and take average \u975e\u6700\u5927\u6291\u5236(Non-Max Suppression): Select the highest-scoring box Eliminate lower-scoring boxes with IoU > threshold If any boxes remain, goto 1 Fast R-CNN: \u00b6 A two-stage object detector First stage: run once per image Backbone network RPN Second stage: run once per region Crop features: RoI pool / align Predict object class Predict bbox offset Rol Pool \u00b6 R-CNN\u4e2d\u7684ROIPool\u3001ROIAlign RPN \u00b6 \u53c2\u8003\uff1a \u8be6\u89e3RPN\u7f51\u7edc RPN\uff08Region Proposal Network\uff09\u662fFaster-RCNN\u7f51\u7edc\u7528\u4e8e\u63d0\u53d6\u9884\u9009\u6846\uff08\u4e5f\u5c31\u662fRCNN\u4e2d\u4f7f\u7528selective search\u7b97\u6cd5\u8fdb\u884cRegion Proposal\u7684\u90e8\u5206\uff09\uff0cR-CNN\u53caFast-RCNN\u4e2d\u4e00\u4e2a\u6027\u80fd\u74f6\u9888\u5c31\u662f\u63d0\u53d6\u9884\u9009\u6846\u7684\u90e8\u5206\uff0c\u800cRPN\u5f88\u597d\u5730\u5bf9\u8fd9\u4e2a\u90e8\u5206\u8fdb\u884c\u4e86\u4f18\u5316\uff0c\u539f\u56e0\u5728\u4e8e\u5b83\u5c06\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u5f15\u5165\u4e86\u8fdb\u6765\uff0c\u4f7f\u7528\u7279\u5f81\u63d0\u53d6\u7684\u5f62\u5f0f\u751f\u6210\u51fa\u9884\u9009\u6846\u7684\u4f4d\u7f6e\u4ece\u800c\u964d\u4f4e\u4e86selective search\u7b97\u6cd5\u5e26\u6765\u7684\u8ba1\u7b97\u65f6\u95f4\u4e0a\u7684\u5f00\u9500\u3002 \u200b \u5047\u8bbe\u6211\u4eec\u6709\u4e00\u5f20\u5927\u5c0f\u4e3a600\u00d7800\u7684\u56fe\u50cf\uff0c\u5728\u901a\u8fc7\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\uff08CNN\uff09\u5757\u540e\uff0c\u8fd9\u5e45\u8f93\u5165\u56fe\u50cf\u7f29\u5c0f\u4e3a38\u00d756\u7684\u7279\u5f81\u56fe\uff0c\u7279\u5f81\u56fe\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u67099\u4e2a\u951a\u70b9\u76d2\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u670938 * 56 * 9=1192\u4e2a\u5efa\u8bae\u6216\u951a\u7bb1\u9700\u8981\u8003\u8651\u3002\u800c\u6bcf\u4e2a\u951a\u7bb1\u90fd\u6709\u4e24\u4e2a\u53ef\u80fd\u7684\u6807\u7b7e\uff08\u524d\u666f\u6216\u80cc\u666f\uff09\u3002\u5982\u679c\u6211\u4eec\u628a\u7279\u5f81\u56fe\u7684\u6df1\u5ea6\u5b9a\u4e3a18\uff089\u4e2a\u951a\u70b9x 2\u4e2a\u6807\u7b7e\uff09\uff0c\u6211\u4eec\u5c06\u4f7f\u6bcf\u4e2a\u951a\u70b9\u90fd\u6709\u4e00\u4e2a\u6709\u4e24\u4e2a\u503c\u7684\u5411\u91cf\uff08\u901a\u5e38\u79f0\u4e3a\u9884\u6d4b\u503c\uff09\uff0c\u4ee3\u8868\u524d\u666f\u548c\u80cc\u666f\u3002\u5982\u679c\u6211\u4eec\u5c06\u9884\u6d4b\u503c\u9001\u5165softmax/logistic\u56de\u5f52\u6fc0\u6d3b\u51fd\u6570\uff0c\u5b83\u5c06\u9884\u6d4b\u6807\u7b7e\u3002 3 Instance segmentation(\u5b9e\u4f8b\u5206\u5272) \u00b6 \u8bed\u4e49\u5206\u5272\u7684\u8bdd\u53ea\u9700\u8981\u5206\u51fa\u4e0d\u540c\u7c7b\u5c31\u884c\uff0c\u540c\u7c7b\u7684\u4e0d\u540c\u4e2a\u4f53\u4e0d\u9700\u8981\u5206\uff0c\u4f46\u662fInstance Segmentation\u8fd9\u91cc\u5728\u8bed\u4e49\u5206\u5272\u7684\u57fa\u7840\u4e0a\u53c8\u628a\u4e0d\u540c\u7684\u7c7b\u8fdb\u884c\u4e86\u5206\u5272 \u76ee\u6807\u68c0\u6d4b\u540e\uff0c\u9700\u8981\u5bf9\u68c0\u6d4b\u7684\u90e8\u5206\u505a\u8fdb\u4e00\u6b65\u7684\u8bed\u4e49\u5206\u5272 Mask R-CNN : \u5728Faster R-CNN\u7684\u57fa\u7840\u4e0a\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9884\u6d4b\u5206\u5272mask\u7684\u5206\u652f\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\u5176\u4e2d\u9ed1\u8272\u90e8\u5206\u4e3a\u539f\u6765\u7684Faster-RCNN\uff0c\u7ea2\u8272\u90e8\u5206\u4e3a\u5728Faster-RCNN\u7f51\u7edc\u4e0a\u7684\u4fee\u6539\u3002\u5c06RoI Pooling \u5c42\u66ff\u6362\u6210\u4e86RoIAlign\u5c42\uff1b\u6dfb\u52a0\u4e86\u5e76\u5217\u7684FCN\u5c42\uff08mask\u5c42\uff09\u3002 DeepSnake: \u901a\u8fc7\u6df1\u5ea6\u5b66\u4e60\u7ed9\u51fa\u8f93\u5165\u521d\u59cb\u8f6e\u5ed3\u9876\u70b9\u9700\u8981\u8c03\u6574\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5f97\u5230\u66f4\u4e3a\u51c6\u786e\u7684\u5b9e\u4f8b\u5206\u5272\u7ed3\u679c\u3002 Panoptic segmentation: \u5bf9\u6bcf\u4e00\u4e2a\u50cf\u7d20\u90fd\u5206\u51fa\u7c7b\u522b 4 Human pose estimation(\u4eba\u4f53\u59ff\u6001\u4f30\u8ba1) \u00b6 \u901a\u8fc7\u5b9a\u4f4d\u4e00\u7ec4\u5173\u952e\u70b9\u6765\u8868\u793a\u4eba\u7684\u59ff\u52bf \u5355\u4eba\uff1aRepresent joint location as the heatmap(\u73b0\u5728\u628a\u5173\u952e\u70b9\u7528\u70ed\u529b\u56fe(heat map)\u8868\u793a\uff0c\u4e0d\u9700\u8981\u5168\u8fde\u63a5\u5c42\uff0c\u52a0\u901f\u7b97\u6cd5\u51cf\u5c11\u53c2\u6570\u91cf\u3002\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5173\u952e\u70b9\u8f93\u51fa\u4e00\u5f20heat map) \u591a\u4eba\uff1a Top-down(\u51c6\u786e)\uff1a\u628a\u591a\u4eba\u8f6c\u6210\u5355\u4eba\uff0c\u56fe\u50cf\u5206\u5272 Bottom-up(\u5feb)\uff1a\u5148\u68c0\u6d4b\u51fa\u56fe\u4e2d\u6240\u6709\u4eba\u7684\u6240\u6709\u5173\u952e\u70b9\uff0c\u518d\u5bf9\u5173\u952e\u70b9\u8fdb\u884c\u5206\u7ec4\uff0c\u8fdb\u800c\u7ec4\u88c5\u6210\u591a\u4e2a\u4eba \u4eba\u4f53\u59ff\u6001\u4f30\u8ba1(Human Pose Estimation)\u7ecf\u5178\u65b9\u6cd5\u6574\u7406 5 Optical flow(\u5149\u6d41) \u00b6 \u53c2\u8003\uff1a \u8ba1\u7b97\u673a\u89c6\u89c9--\u5149\u6d41\u6cd5(optical flow)\u7b80\u4ecb \u5149\u6d41(optical flow)\u662f\u7a7a\u95f4\u8fd0\u52a8\u7269\u4f53\u5728\u89c2\u5bdf\u6210\u50cf\u5e73\u9762\u4e0a\u7684\u50cf\u7d20\u8fd0\u52a8\u7684\u77ac\u65f6\u901f\u5ea6\u3002\u5728\u65f6\u95f4\u95f4\u9694\u5f88\u5c0f\uff08\u6bd4\u5982\u89c6\u9891\u7684\u8fde\u7eed\u524d\u540e\u4e24\u5e27\u4e4b\u95f4\uff09\u65f6\uff0c\u4e5f\u7b49\u540c\u4e8e\u76ee\u6807\u70b9\u7684\u4f4d\u79fb\u3002 \u5149\u6d41\u573a\uff1a \u00b6 \u200b \u5149\u6d41\u573a\u662f\u4e00\u4e2a\u4e8c\u7ef4\u77e2\u91cf\u573a\uff0c\u5b83\u53cd\u6620\u4e86\u56fe\u50cf\u4e0a\u6bcf\u4e00\u70b9\u7070\u5ea6\u7684\u53d8\u5316\u8d8b\u52bf\uff0c\u53ef\u770b\u6210\u662f\u5e26\u6709\u7070\u5ea6\u7684\u50cf\u7d20\u70b9\u5728\u56fe\u50cf\u5e73\u9762\u4e0a\u8fd0\u52a8\u800c\u4ea7\u751f\u7684\u77ac\u65f6\u901f\u5ea6\u573a\u3002\u5b83\u5305\u542b\u7684\u4fe1\u606f\u5373\u662f\u5404\u50cf\u70b9\u7684\u77ac\u65f6\u8fd0\u52a8\u901f\u5ea6\u77e2\u91cf\u4fe1\u606f\u3002 \u200b \u7814\u7a76\u5149\u6d41\u573a\u7684\u76ee\u7684\u5c31\u662f\u4e3a\u4e86\u4ece\u5e8f\u5217\u56fe\u50cf\u4e2d\u8fd1\u4f3c\u8ba1\u7b97\u4e0d\u80fd\u76f4\u63a5\u5f97\u5230\u7684\u8fd0\u52a8\u573a\u3002\u5149\u6d41\u573a\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5149\u6d41\u573a\u5bf9\u5e94\u4e8e\u8fd0\u52a8\u573a\u3002 FlowNet \u00b6 \u4e24\u90e8\u5206\uff1a\u7f29\u5c0f\u548c\u653e\u5927 \u7f29\u5c0f(\u5377\u79ef)\u90e8\u5206 \u7b2c\u4e00\u79cd\u7f29\u5c0f(\u5377\u79ef)\u65b9\u6848\u662f\u6700\u6734\u7d20\u7684\u65b9\u6cd5\u7684\uff0c\u5c31\u662f\u5c06\u8fd9\u4e00\u5bf9\u56fe\u7247\u7684\u901a\u9053concat\u8d77\u6765 \u7b2c\u4e8c\u4e2d\u65b9\u6848\u662f\u8fd9\u4e00\u5bf9\u56fe\u7247\u5206\u5f00\u5904\u7406\uff0c\u5206\u522b\u8fdb\u5165\u5377\u79ef\u7f51\u8def\uff0c\u5f97\u5230\u5404\u81ea\u7684\u7279\u5f81\u56fe\uff0c\u7136\u540e\u518d\u627e\u5230\u5b83\u4eec\u7279\u5f81\u56fe\u4e4b\u95f4\u7684\u8054\u7cfb\u3002 \u653e\u5927\u90e8\u5206 \u4e00\u8fb9\u5411\u540eunconv\uff0c\u4e00\u8fb9\u76f4\u63a5\u5728\u5c0f\u7684\u7279\u5f81\u56fe\u4e0a\u9884\u6d4b\uff0c\u7136\u540e\u628a\u7ed3\u679c\u53cc\u7ebf\u6027\u63d2\u503c\u7136\u540econcat\u5728unconv\u540e\u7684\u7279\u5f81\u56fe\u4e0a\uff0c\u7136\u540e\u63a5\u7740\u5f80\u540e\u4f20\uff0c\u91cd\u590d\u56db\u6b21\u540e\uff0c\u5f97\u5230\u7684\u9884\u6d4b\u5149\u6d41\u5206\u8fa8\u7387\u4f9d\u7136\u662f\u8f93\u5165\u7684\u00bc\uff0c\u518d\u91cd\u590d\u4e4b\u524d\u7684\u64cd\u4f5c\u5df2\u6ca1\u6709\u592a\u591a\u63d0\u5347\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u53cc\u7ebf\u6027\u63d2\u503c\u5f97\u5230\u548c\u8f93\u5165\u76f8\u540c\u5206\u8fa8\u7387\u7684\u5149\u6d41\u9884\u6d4b\u56fe\u3002 6 Other tasks \u00b6 Video classification: Use 3D CNN Temporal action localization: Generate proposals then classify Multi-object tracking Lec 11 3D Deep Learning \u00b6 1 Feature matching \u00b6 Super Polint: \u7528\u4e8e\u63d0\u53d6\u7279\u5f81\u70b9 \u00b6 CNN-based detectors: Representing feature point locations by heatmaps CNN-based descriptors: Extract descriptors from CNN feature maps(\u6bcf\u4e00\u5f20\u56fe\u90fd\u662f\u4e00\u5c42\u795e\u7ecf\u7f51\u7edc\u4e0b\u7684\u7279\u5f81\u56fe\uff0c\u53d6\u6240\u6709\u56fe\u4e2d\u5bf9\u5e94\u7684\u70b9\u505a\u4e00\u4e2a\u5411\u91cf) SuperGlue: \u73b0\u5728\u6700\u597d\u7684\u68c0\u6d4b\u65b9\u6cd5 \u00b6 2 Object Pose Estimation \u00b6 Estimate the 3D location and orientation (\u4f4d\u7f6e\u548c\u65b9\u5411) of an object realtive to the camera frame. Before that, we need to define the geometry center of the object. Find 3D-2D correspondences Solve R and t by perspective-n-point (PnP) algorithm Find 2D-3D correspondences: detecting keyponts using CNNs 3 Human Pose Estimation \u00b6 Markerless MoCap: \u76f8\u673a\u7167\u5c04\u5173\u952e\u70b9\uff0c\u6807\u8bb0\u7269\u5728\u4eba\u8eab\u4f53\u4e0a\uff0cMarkless\u5c31\u662f\u4e0d\u7528\u8d34\u6807\u8bb0\u7269 \u00b6 Monocular 3D Human Pose Estimation: \u53c2\u6570\u5316\u4eba\u4f53\u6a21\u578b \u00b6 Estimating 3D human pose using a single camera Using networks to regress joint locations 4 Depth Estimation \u00b6 Multiview Depth Estimation: Reconstruct the dense 3D shape from a set of images and camera parameters Learned multi-view stereo Cost volume is a 3D array that stores the errors of all pixels at all depths 5 Single Image to 3D \u00b6 \u2022 Depth \u2022 Point Cloud \u2022 Mesh \u2022 Volume Monoculer depth estimation \u00b6 Learning to guess depth from large-scale training data Single-view shape estimation \u00b6 \u9664\u4e86\u70b9\u4e91\uff0cmesh\u7b49\u65b9\u6cd5\u4e5f\u53ef\u5e94\u7528\u3002 6 PointNet \u00b6 \u628a\u70b9\u4e91\u653e\u8fdb\u795e\u7ecf\u7f51\u7edc\uff0c\u4ee5\u524d\u7684\u795e\u7ecf\u7f51\u7edc\u90fd\u662f\u5149\u6805\u5316\u7684 \u6311\u62181\uff1a\u70b9\u987a\u5e8f\u4e0d\u786e\u5b9a\u2014\u2014\u6700\u540e\u518d\u505apooling \u6311\u62182\uff1a\u4f4d\u7f6e\u53d8\u5316\u4e0d\u786e\u5b9a\u2014\u2014\u4f30\u8ba1\u59ff\u6001 Lec 12 Computational Photography I \u00b6 1 High Dynamic Range Imaging (HDR) \u00b6 Exposure:\u66dd\u5149 \u00b6 Exposure = Gain(\u589e\u76ca) x Irradiance(\u5149\u7ebf) x Time(\u65f6\u95f4) Gain is controlled by the ISO Irradiance is controlled by the aperture Time is controlled by the shutter speed Dynamic Range \u00b6 The ratio between the largest and smallest values of a certain quantity. HDR \u00b6 \u4eae\u7684\u5730\u65b9\u548c\u6697\u7684\u5730\u65b9\u80fd\u540c\u65f6\u62cd\u6e05\u695a \u5b9e\u73b0\u65b9\u6cd5\uff1a Exposure bracketing: Capture multiple LDR images at different exposures(\u4e00\u6b21\u62cd\u5f88\u591a\u5f20) Merging: Combine them into a single HDR image(\u7136\u540e\u5408\u5728\u4e00\u8d77) Merge \u00b6 Tone mapping \u00b6 Display the HDR image (12-bit) on a SDR (standard dynamic range, 8-bit) device. Gamma compression X \u2192 aX \u03b3 , applied independently on R, G, B intend to keep more details on each parts. \u03b3 < 1: keep more datails on dart parts \u03b3 > 1: keep more datails on light parts 2 Deblurring \u00b6 Reason \u00b6 Defocus: the subject is not in the depth of view Motion blur: moving subjects or unstable camera \u2026\u2026 Modeling Image Blur \u00b6 The blurring process can be described by convolution. H is called blur kernel. Deblurring = Deconvolution NBID: Non-blind image deconvolution, the blur kernel is known. BID: Blind image deconvolution, the blur kernel is also unknown. NBID \u00b6 G: The captured image (known) F: Image to be solved (unknown) H: Blur kernel (known) Inverse Filter: will also amplify noise Wiener Filter: Suppress high frequency when reverse filtering Deconvolution by optimization Deconvolution is ill-posed, these are several sets of solutions have the same MSE. Objective function = likelihood function + regular term BID \u00b6 Blur kernel is non-negative and sparse. Optimized objective function: 3 Colorization(\u9ed1\u767d\u53d8\u5f69\u8272) \u00b6 Sample-based colorization \u00b6 \u628a\u4e00\u5f20\u7167\u7247\u4e0a\u7684\u989c\u8272\u8fc1\u79fb\u5230\u53e6\u4e00\u5f20\u7167\u7247\uff0c\u4e3b\u8981\u4efb\u52a1\u662f\u50cf\u7d20\u5339\u914d Interactive colorization \u00b6 \u7ed9\u51fa\u7ebf\u6761\u5927\u81f4\u7684\u989c\u8272(user-guided) Constraint: User-specified colors of brushed pixels keep unchanged Generative Adversarial Network (GAN) \u00b6 D can be viewed as a loss function to train G\uff1a Called adversarial loss Learned instead of being hand-designed Can be applied to any image synthesis tasks 4 Super Resolution \u00b6 Super Resolution using GAN Lec 13 Computational Photography II \u00b6 1 Image-based Rendering \u00b6 Rendering: from 3D models to images Image-based: \u57fa\u4e8e\u7167\u7247\u8fdb\u884c\u6e32\u67d3 Light Fields \u00b6 The plenoptic function (7D) depicts light rays passing through. Multi-Plane Image (MPI) \u00b6 A set of front-parallel planes at a fixed range of depths. Each plane encodes an RGB color image and an alpha/transparency map \u03b1 d . NeRF \u00b6 2 Neural Rendering \u00b6 Pose Transfer & Garment Transfer \u00b6 Input: Image(s) of a person Output: Synthesised images of the persion in different poses (Pose Transfer), or with different clothing (Garment Transfer). Method: Use parametric mesh (SMPL) to represent body pose and shape Use high-dimensional UV texture map to encode appearance Transfer the pose and appearance","title":"\u8ba1\u7b97\u673a\u89c6\u89c9\u5bfc\u8bba"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-1-introduction","text":"","title":"Lec 1 Introduction"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-cv\u4e3b\u8981\u4efb\u52a1","text":"\u4e09\u7ef4\u91cd\u5efa \u56fe\u50cf\u7406\u89e3 \u56fe\u50cf\u5408\u6210","title":"1 CV\u4e3b\u8981\u4efb\u52a1\uff1a"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-review-of-linear-algebra","text":"\u7701\u7565\u3002\u3002\u3002","title":"2 Review of Linear Algebra"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-2-image-formation","text":"","title":"Lec 2 Image formation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-camera-and-lens","text":"","title":"1 Camera and lens"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#pinhole-camera","text":"Add a barrier to block off most of the rays, the opening known as the aperture(\u5149\u5708).","title":"Pinhole camera"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lens","text":"Focal length: \\[\\frac{1}{i}+\\frac{1}{o}=\\frac{1}{f}\\] Image Magnification: \\[m=\\frac{h_i}{h_o}\\] Field of View (FOV): Longer focal length = Narrower angle of view Shorter focal length = Wider angle of view FOV also depends on sensor size Aperture: control image brightness F-number: represent aperture as a fraction of focal length Depth of Field: range of object distances over which the image is sufficiently well focused","title":"Lens"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-geometric-image-formation","text":"","title":"2 Geometric image formation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#pinhole-camera-model-perspective-projection","text":"","title":"Pinhole camera model: Perspective Projection"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#homogeneous-coordinates","text":"Converting from Cartesian to Homogeneous coordinates(add an extra dimension) Converting from Homogeneous to Cartesian(remove the last dimension by dividing a number) Homogeneous coordinates are invariant to scaling. Each point has an infinite set of homogeneous coordinates. The point in the 2D plane is projection of a ray in 3D space:","title":"Homogeneous coordinates"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#perspective-projection","text":"","title":"Perspective Projection"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#orthographic-projection","text":"","title":"Orthographic projection"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-photometric-image-formation","text":"","title":"3 Photometric image formation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#shutter-speed","text":"Shutter speed controls exposure time. The pixel value is equal to the integral of the light intensity within the exposure time.","title":"Shutter speed"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#rolling-shutter-effect","text":"Exposing the image line by line.","title":"Rolling shutter effect"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#color-spaces","text":"RGB HSV (Hue / Value / Saturation)","title":"Color spaces"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#color-sensing-bayer-filter","text":"","title":"Color Sensing: Bayer filter"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-3-image-processing","text":"","title":"Lec 3 Image processing"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-image-processing-basics","text":"","title":"1 Image processing basics"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#convolution","text":"","title":"Convolution"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2d-convolution","text":"","title":"2D convolution"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#discrete-2d-convolution","text":"This can also be the same with the vector/matrix dot product.","title":"Discrete 2D convolution"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#padding","text":"Adding pixels around the image border.","title":"Padding"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#blur","text":"box\u6ee4\u6ce2\uff1a\u5377\u79ef\u6838\u5168\u4e3a1 \u9ad8\u65af\u6ee4\u6ce2\uff1a\u7279\u5b9a\u51fd\u6570","title":"Blur"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#sharpen","text":"Sharpening is adding high frequencies. Let be the original image. High frequencies in image is J-blur(I), blur(I) is the low frequencied in image. Sharpened image is I+(I-blur(I)).","title":"Sharpen"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#gradient-detection-filter","text":"","title":"Gradient detection filter"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#bilateral-filter","text":"","title":"Bilateral filter"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-image-sampling","text":"Change image size / resolution. resolution: pixel / inch","title":"2 Image sampling"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#reducing-image-size","text":"\u964d\u91c7\u6837\uff0c\u53bb\u6389\u65c1\u8fb9\u7684\u50cf\u7d20\u6216\u8005\u53d6\u5747\u503c","title":"Reducing image size"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#aliasing","text":"Aliasing - artifacts due to sampling Signals are changing too fast but sampled too slow.","title":"Aliasing"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#anti-aliasing","text":"How to do anti-aliasing Convolve the image with low-pass filters (e.g. Gaussian). Sample it with a Nyquist rate.","title":"Anti-aliasing"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#fourier-transform","text":"Represent a function as a weighted sum of sines and cosines.","title":"Fourier Transform"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-image-magnification","text":"","title":"3 Image magnification"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#interpolation","text":"Nearest-neighbor interpolation Linear interpolation Cubic spline interpolation (Polynomial interpolation) Each interval of function has different parameters Bilinear Interpolation (2D) Bilinear Interpolation is good enough.","title":"Interpolation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#seam-carving","text":"A method to change aspect ratio. Find connected path of pixels from top to bottom of which the edge energy is minimal, removing unnoticeable pixels. Algorithm: DP","title":"Seam Carving"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-4-model-fitting-and-optimization","text":"\u672c\u8bb2\u4e0e\u6570\u503c\u5206\u6790\u8bfe\u7a0b\u9ad8\u5ea6\u91cd\u5408","title":"Lec 4 Model Fitting and Optimization"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-optimization","text":"minimize f 0 (x)","title":"1 Optimization"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#model-fitting","text":"Mean Square Error (MSE)","title":"Model fitting"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-numerical-methods","text":"Find a solution path: F (x 0 ) > F (x 1 ) > \u2026 > F (x k ) > \u2026 \u4e0e\u6570\u503c\u5206\u6790\u8bfe\u4e0a\u5185\u5bb9\u7c7b\u4f3c\uff0c\u6cf0\u52d2\u5c55\u5f00\uff0c\u8fdb\u884c\u8fed\u4ee3\uff0c\u505a\u4e00\u9636\u3001\u4e8c\u9636\u8fd1\u4f3c","title":"2 Numerical methods"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u68af\u5ea6\u4e0b\u964d\u6cd5\u8fed\u4ee3\u6cd5\u7684\u4e00\u79cd","text":"","title":"\u68af\u5ea6\u4e0b\u964d\u6cd5\uff1a\u8fed\u4ee3\u6cd5\u7684\u4e00\u79cd"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#newton-method\u89c1\u6570\u503c\u5206\u6790\u8bfe\u7a0b","text":"","title":"Newton method\uff1a\u89c1\u6570\u503c\u5206\u6790\u8bfe\u7a0b"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u9ad8\u65af-\u725b\u987f\u8fed\u4ee3","text":"","title":"\u9ad8\u65af-\u725b\u987f\u8fed\u4ee3"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-robust-estimation","text":"Use other loss functions to replace MSE\uff0c\u53bb\u6389\u5f71\u54cd\u5f88\u5927\u7684\u566a\u70b9","title":"3 Robust estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#random-sample-concensus-ransac","text":"Key ideas The distribution of inliers is similar while outliers differ a lot Use data point pairs to vote","title":"Random Sample Concensus (RANSAC)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-interpolation","text":"\u5177\u4f53\u8bf7\u53c2\u8003\u6570\u503c\u5206\u6790 \u7ebf\u6027\u63d2\u503c \u4e09\u6b21\u6837\u6761\u63d2\u503c","title":"4 Interpolation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#5-graphcut","text":"","title":"5 Graphcut"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#images-as-graphs","text":"A vertex for each pixel, an edge between each pair, each edge is weighted by the affinity or similarity between its two vertices.","title":"Images as Graphs"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#normalized-cut","text":"","title":"Normalized cut"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#markov-random-field-mrf","text":"\u9a6c\u5c14\u79d1\u592b\u968f\u673a\u573a\uff0c\u6ca1\u770b\u61c2","title":"Markov Random Field (MRF)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-5-image-matching-and-motion-estimation","text":"","title":"Lec 5 Image Matching and Motion Estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-image-matching","text":"Finding point-to-point correspondences between two images.","title":"1 Image matching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#steps","text":"Detection: Identify the interest points (key points). Description: Extract vector feature descriptor surrounding each interest point. Matching: Determine correspondence between descriptors in two views.","title":"Steps"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#detection","text":"Principal Component Analysis (PCA) \u89d2\u70b9\u68c0\u6d4b Compute the covariance matrix at each point Compute eigenvalues Classify points using eigenvalues of H:","title":"detection"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#blob-detector","text":"Blobs are have large second derivatives in image intensity.","title":"Blob detector"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#description","text":"SIFT descriptor\uff1aScale Invariant Feature Transform descriptor, use histogram of oriented gradients. SIFT Algorithm Run DoG detector to find maximum in location/scale space. Find dominate orientation and normalize the orientation. For each (x, y, scale, orientation), create the only descriptor.","title":"Description"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#matching","text":"Define the difference between two features f1 , f2, distance L2 = ||f1 \u2212 f2 ||","title":"Matching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-motion-estimation","text":"","title":"2 Motion estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#problem","text":"Both feature matching and motion estimation are called correspondence problems. \u7279\u5f81\u8ffd\u8e2a\uff1a Extract feature (interest) points and \"track\" them over multiple frames. Output: displacement of sparse points \u5149\u6d41\u6cd5\uff1a Recover image motion at each pixel Output: dense displacement field (optical flow filed)","title":"Problem"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lucas-kanade-method","text":"Key assumptions\uff1a Small motion: points do not move very far Brightness constancy: same point looks the same(in brightness) in every frame Spatial coherence: points move like their neighbors \u672c\u8bb2\u5c0f\u603b\u7ed3\uff1a","title":"Lucas-Kanade Method"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-6-image-stitching","text":"","title":"Lec 6 Image stitching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-image-warping","text":"Change shape of image","title":"1 Image Warping"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#linear-transformmation","text":"Linear map = Matrices","title":"Linear Transformmation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#affine-transformation","text":"Affine map = linear map + translation Using homogenous coordinates 6 unknowns in equations 2 equations for each match we need at least 3 matches to solve a affine transformation for n matches, solve with least squares The result of solution must be remembered. the last row with matrix must be [0 0 1]","title":"Affine Transformation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#projective-transformation-homography","text":"8 unknowns in equations Homography matrix is up to scale (can be multiplied by a scalar), which means the degree of freedom is 8 . 2 equations for each match we need at least 4 matches to solve the homography for n matches, solve with ||h|| = 1 h = eigenvector of A T A with smallest eigenvalue","title":"Projective Transformation (Homography)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#dof","text":"Translation: The degree of freedom is 2 Affine: The degree of freedom is 6 Projective: The degree of freedom is 8","title":"DoF"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#forward-warping","text":"","title":"Forward Warping"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#inverse-warping","text":"if pixel lands between pixels, we interpolate color values from neighboring pixels. nearest neighbor bilinear (usually this method is enough) bicubic","title":"Inverse Warping"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-image-stitching","text":"Algorithm: Input images Feature matching Compute transformation matrix with RANSAC Fix image 1 and warp image 2 Cylindrical projection:","title":"2 Image Stitching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-7-structure-from-motion","text":"Target: recover camera poses and 3D structure of a scene from its images","title":"Lec 7 Structure from Motion"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-camera-calibration","text":"","title":"1 Camera calibration"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u56fe\u50cf\u5904\u7406","text":"\u53c2\u8003\u6587\u732e\uff1a \u56fe\u50cf\u5904\u7406\u2014\u2014\u76f8\u673a\u6807\u5b9a \u4e16\u754c\u5750\u6807\u7cfb\uff08world coordinate\uff09( xw,yw,zw )\uff0c\u4e5f\u79f0\u4e3a\u6d4b\u91cf\u5750\u6807\u7cfb\uff0c\u662f\u4e00\u4e2a\u4e09\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u4ee5\u5176\u4e3a\u57fa\u51c6\u53ef\u4ee5\u63cf\u8ff0\u76f8\u673a\u548c\u5f85\u6d4b\u7269\u4f53\u7684\u7a7a\u95f4\u4f4d\u7f6e\u3002\u4e16\u754c\u5750\u6807\u7cfb\u7684\u4f4d\u7f6e\u53ef\u4ee5\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u81ea\u7531\u786e\u5b9a\u3002\u4e16\u754c\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u76f8\u673a\u5750\u6807\u7cfb\uff08camera coordinate\uff09( xc,yc,zc )\uff0c\u4e5f\u662f\u4e00\u4e2a\u4e09\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u539f\u70b9\u4f4d\u4e8e\u955c\u5934\u5149\u5fc3\u5904\uff0cxc\u3001yc\u8f74\u5206\u522b\u4e0e\u50cf\u9762\u7684\u4e24\u8fb9\u5e73\u884c\uff0czc\u8f74\u4e3a\u955c\u5934\u5149\u8f74\uff0c\u4e0e\u50cf\u5e73\u9762\u5782\u76f4\u3002\u76f8\u673a\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u56fe\u50cf\u5750\u6807\u7cfb\uff08image coordinate\uff09( x , y )\uff0c\u662f\u50cf\u5e73\u9762\u4e0a\u7684\u4e8c\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\u3002\u56fe\u50cf\u5750\u6807\u7cfb\u7684\u539f\u70b9\u4e3a\u955c\u5934\u5149\u8f74\u4e0e\u50cf\u5e73\u9762\u7684\u4ea4\u70b9\uff08\u4e5f\u79f0\u4e3b\u70b9\uff0cprincipal point\uff09\uff0c\u5b83\u7684x\u8f74\u4e0e\u76f8\u673a\u5750\u6807\u7cfb\u7684xc\u8f74\u5e73\u884c\uff0c\u5b83\u7684y\u8f74\u4e0e\u76f8\u673a\u5750\u6807\u7cfb\u7684yc\u8f74\u5e73\u884c\u3002\u56fe\u50cf\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3amm\u3002 \u50cf\u7d20\u5750\u6807\u7cfb\uff08pixel coordinate\uff09(u,v)\uff0c\u662f\u56fe\u50cf\u5904\u7406\u5de5\u4f5c\u4e2d\u5e38\u7528\u7684\u4e8c\u7ef4\u76f4\u89d2\u5750\u6807\u7cfb\uff0c\u53cd\u6620\u4e86\u76f8\u673aCCD/CMOS\u82af\u7247\u4e2d\u50cf\u7d20\u7684\u6392\u5217\u60c5\u51b5\u3002\u5b83\u7684\u539f\u70b9\u4f4d\u4e8e\u56fe\u50cf\u5de6\u4e0a\u89d2\uff0c\u6a2a\u5750\u6807u\u8868\u793a\u50cf\u7d20\u6240\u5728\u7684\u5217\uff0c\u7eb5\u5750\u6807v\u8868\u793a\u50cf\u7d20\u6240\u5728\u7684\u884c\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u53ef\u4ee5\u7b80\u5355\u7406\u89e3\u4e3a\u5e73\u79fb\u5173\u7cfb\uff0c\u5b83\u4eec\u540c\u5904\u4e8e\u50cf\u5e73\u9762\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u7684x\u8f74\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u7684u\u8f74\u5e73\u884c\uff0c\u50cf\u7d20\u5750\u6807\u7cfb\u7684y\u8f74\u4e0e\u56fe\u50cf\u5750\u6807\u7cfb\u7684v\u8f74\u5e73\u884c\u3002\u50cf\u7d20\u5750\u6807\u7cfb\u7684\u6700\u5c0f\u5355\u4f4d\u4e3a\u50cf\u7d20\u3002 \u53d8\u6362\u8fc7\u7a0b\uff1a \u4e16\u754c=\u300b\u76f8\u673a=\u300b\u56fe\u50cf=\u300b\u50cf\u7d20 so, it is similar to lab2. \u4e16\u754c\u76f4\u63a5\u8f6c\u6362\u4e3a\u50cf\u7d20\uff1a \u89e3\u65b9\u7a0b\u65f6\uff1a \u627e\u7279\u5f81\u70b9\uff0c\u5efa\u7acb\u65b9\u7a0b\u6c42\u89e3\u672a\u77e5\u6570 \\(p\\) \u5177\u4f53\u67e5\u770b\u53c2\u8003\u6587\u732e\u548c\u8bfe\u7a0bPPT","title":"\u56fe\u50cf\u5904\u7406"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#pnp\u95ee\u9898","text":"\u53c2\u8003\u6587\u732e\uff1a PnP\u95ee\u9898\u5404\u79cd\u7b97\u6cd5\u603b\u7ed3\u5206\u6790 \u95ee\u9898\u63cf\u8ff0\uff1a\u5df2\u77e5n\u4e2a3D\u70b9\u7684\u5750\u6807(\u76f8\u5bf9\u4e16\u754c\u5750\u6807\u7cfb)\u4ee5\u53ca\u8fd9\u4e9b\u70b9\u7684\u50cf\u7d20\u5750\u6807\u65f6\uff0c\u5982\u4f55\u4f30\u8ba1\u76f8\u673a\u7684\u4f4d\u59ff","title":"PnP\u95ee\u9898"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#direct-linear-transform-dlt","text":"\u524d\u9762\u6211\u4eec\u901a\u8fc7\u89e3\u65b9\u7a0b\u7684\u5f62\u5f0f\u89e3\u51fa\u4e86\u8fd9\u4e2a\u65b9\u7a0b\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5c31\u53eb\u505aDLT\u3002","title":"Direct Linear Transform (DLT)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#p3p","text":"\u81f3\u5c11\u4e09\u4e2a\u5bf9\u5e94\u5173\u7cfb\u53ef\u4ee5\u89e3\u51fa\u76f8\u673a\u5750\u6807\uff0c\u8fd8\u9700\u8981\u4e00\u4e2a\u5bf9\u5e94\u5173\u7cfb\u4f7f\u8fd9\u4e2a\u89e3\u662f\u7279\u89e3\u3002","title":"P3P"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#epnp","text":"Main steps: Represent each point as the linear combination of 4 control points c i . Construct a linear system in the control-point coordinate. Solve the equation.","title":"EPnP"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-two-frame-structure-from-motion","text":"Assume Camera Matrix \ud835\udc3e is known for each camera Find a few Reliable Corresponding Points Find Relative Camera Position \ud835\udc2d and Orientation \ud835\udc45 Find 3D position of scene points \u8be6\u7ec6\u8bb2\u89e3\uff1a \u5bf9\u6781\u51e0\u4f55--\u77e5\u4e4e \u200b \u5bf9\u6781\u51e0\u4f55--github","title":"2 Two-frame structure from motion"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-multi-frame-structure-from-motion","text":"Initialize camera motion and scene structure For each additional view - Determine projection matrix of new camera using all the known 3D points that are visible in its image - Refine and extend structure: compute new 3D points, reoptimize existing points that are also seen by this camera Refine structure and motion: Bundle Adjustment","title":"3 Multi-frame structure from motion"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-a-modern-sfm-system-colmap","text":"sfM: Structure-from-Motion MVS: Multi-View Stereo","title":"4 A modern SfM system: COLMAP"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-8-depth-estimation-and-3d-reconstruction","text":"","title":"Lec 8 Depth estimation and 3D reconstruction"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-depth-estimation","text":"","title":"1 Depth estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#11-introduction","text":"\u200b \u6df1\u5ea6\u4f20\u611f\u5668\u987e\u540d\u601d\u4e49\u662f\u7528\u6765\u63a2\u6d4b\u73af\u5883\u7269\u4f53\u4e0e\u4f20\u611f\u5668\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u3002\u5b83\u7684\u8f93\u51fa\u4e3b\u8981\u53ef\u4ee5\u8868\u793a\u4e3a\u6df1\u5ea6\u56fe(depth map)\u548c\u70b9\u4e91(point cloud)\u8fd9\u4e24\u79cd\u5f62\u5f0f\u3002 \u200b \u6df1\u5ea6\u56fe\u50cf\uff08depth image)\u4e5f\u88ab\u79f0\u4e3a\u8ddd\u79bb\u5f71\u50cf\uff08range image\uff09\uff0c\u662f\u6307\u5c06\u4ece\u56fe\u50cf\u91c7\u96c6\u5668\u5230\u573a\u666f\u4e2d\u5404\u70b9\u7684\u8ddd\u79bb\uff08\u6df1\u5ea6\uff09\u4f5c\u4e3a\u50cf\u7d20\u503c\u7684\u56fe\u50cf\uff0c\u5b83\u76f4\u63a5\u53cd\u6620\u4e86\u666f\u7269\u53ef\u89c1\u8868\u9762\u7684\u51e0\u4f55\u5f62\u72b6\u3002\u6df1\u5ea6\u56fe\u50cf\u7ecf\u8fc7\u5750\u6807\u8f6c\u6362\u53ef\u4ee5\u8ba1\u7b97\u4e3a\u70b9\u4e91\u6570\u636e\uff0c\u6709\u89c4\u5219\u53ca\u5fc5\u8981\u4fe1\u606f\u7684\u70b9\u4e91\u6570\u636e\u4e5f\u53ef\u4ee5\u53cd\u7b97\u4e3a\u6df1\u5ea6\u56fe\u50cf\u6570\u636e\u3002 \u6df1\u5ea6\u6570\u636e\u6d41\u6240\u63d0\u4f9b\u7684\u56fe\u50cf\u5e27\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u50cf\u7d20\u70b9\u4ee3\u8868\u7684\u662f\u5728\u6df1\u5ea6\u611f\u5e94\u5668\u7684\u89c6\u91ce\u4e2d\uff0c\u8be5\u7279\u5b9a\u7684\uff08x, y\uff09\u5750\u6807\u5904\u7269\u4f53\u5230\u79bb\u6444\u50cf\u5934\u5e73\u9762\u6700\u8fd1\u7684\u7269\u4f53\u5230\u8be5\u5e73\u9762\u7684\u8ddd\u79bb\uff08\u4ee5\u6beb\u7c73\u4e3a\u5355\u4f4d\uff09\u3002 \u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f(Passive depth sensing) \u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f=\u4e24\u4e2a\u76f8\u9694\u4e00\u5b9a\u8ddd\u79bb\u7684\u76f8\u673a\u83b7\u5f97\u4e24\u5e45\u56fe\u50cf+\u7acb\u4f53\u5339\u914d+\u4e09\u89d2\u539f\u7406\u8ba1\u7b97\u89c6\u5dee\uff08disparity\uff09 \u200b \u4e24\u4e2a\u76f8\u9694\u4e00\u5b9a\u8ddd\u79bb\u7684\u6444\u50cf\u673a\u540c\u65f6\u83b7\u53d6\u540c\u4e00\u573a\u666f\u7684\u4e24\u5e45\u56fe\u50cf\uff0c\u901a\u8fc7\u7acb\u4f53\u5339\u914d\u7b97\u6cd5\u627e\u5230\u4e24\u5e45\u56fe\u50cf\u4e2d\u5bf9\u5e94\u7684\u50cf\u7d20\u70b9\uff0c\u968f\u540e\u6839\u636e\u4e09\u89d2\u539f\u7406\u8ba1\u7b97\u51fa\u89c6\u5dee\u4fe1\u606f\uff0c\u800c\u89c6\u5dee\u4fe1\u606f\u901a\u8fc7\u8f6c\u6362\u53ef\u7528\u4e8e\u8868\u5f81\u573a\u666f\u4e2d\u7269\u4f53\u7684\u6df1\u5ea6\u4fe1\u606f\u3002\u57fa\u4e8e\u7acb\u4f53\u5339\u914d\u7b97\u6cd5\uff0c\u8fd8\u53ef\u901a\u8fc7\u62cd\u6444\u540c\u4e00\u573a\u666f\u4e0b\u4e0d\u540c\u89d2\u5ea6\u7684\u4e00\u7ec4\u56fe\u50cf\u6765\u83b7\u5f97\u8be5\u573a\u666f\u7684\u6df1\u5ea6\u56fe\u50cf\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u573a\u666f\u6df1\u5ea6\u4fe1\u606f\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5bf9\u56fe\u50cf\u7684\u5149\u5ea6\u7279\u5f81\u3001\u660e\u6697\u7279\u5f81\u7b49\u7279\u5f81\u8fdb\u884c\u5206\u6790\u95f4\u63a5\u4f30\u7b97\u5f97\u5230\u3002 \u4e3b\u52a8\u6d4b\u8ddd\u4f20\u611f(Active depth sensing) \u200b \u4e3b\u52a8\u6d4b\u8ddd\u4f20\u611f\u76f8\u6bd4\u8f83\u4e8e\u88ab\u52a8\u6d4b\u8ddd\u4f20\u611f\u6700\u660e\u663e\u7684\u7279\u5f81\u662f\uff1a\u8bbe\u5907\u672c\u8eab\u9700\u8981\u53d1\u5c04\u80fd\u91cf\u6765\u5b8c\u6210\u6df1\u5ea6\u4fe1\u606f\u7684\u91c7\u96c6\u3002\u8fd9\u4e5f\u5c31\u4fdd\u8bc1\u4e86\u6df1\u5ea6\u56fe\u50cf\u7684\u83b7\u53d6\u72ec\u7acb\u4e8e\u5f69\u8272\u56fe\u50cf\u7684\u83b7\u53d6\u3002\u8fd1\u5e74\u6765\uff0c\u4e3b\u52a8\u6df1\u5ea6\u4f20\u611f\u5728\u5e02\u9762\u4e0a\u7684\u5e94\u7528\u6108\u52a0\u4e30\u5bcc\u3002\u4e3b\u52a8\u6df1\u5ea6\u4f20\u611f\u7684\u65b9\u6cd5\u4e3b\u8981\u5305\u62ec\u4e86TOF\uff08Time of Flight\uff09\u3001\u7ed3\u6784\u5149\u3001\u6fc0\u5149\u626b\u63cf\u7b49\u3002","title":"1.1 Introduction"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#12-stereo-matching","text":"\u53c2\u8003\u8d44\u6599 3D\u89c6\u89c9\u4e4b\u7acb\u4f53\u5339\u914d \u7acb\u4f53\u5339\u914d\u7b97\u6cd5 \u6700\u7b80\u5355\u7684\u7b97\u6cd5\uff1a For each pixel in the first image Find corresponding epipolar line in the right image Search along epipolar line and pick the best match Simplest case: epipolar lines are horizontal scanlines \u8fd9\u6837\u5c31\u627e\u5230\u4e86\u4e24\u4e2a\u76f8\u540c\u7684\u70b9\uff0c\u7136\u540e\u8ba1\u7b97\u6df1\u5ea6\u3002 \u5982\u679c\u89c6\u89d2\u4e0d\u5728\u540c\u4e00\u6c34\u5e73\u7ebf\u4e0a\uff0c\u5c31\u5148\u628a\u4ed6\u4eec\u8f6c\u5230\u540c\u4e00\u6c34\u5e73\u7ebf\u3002 Stereo as energy minimization\uff1a\u8ba9\u5f53\u524d\u50cf\u7d20\u7684\u4ee3\u4ef7\u805a\u5408\u8fc7\u7a0b\u53d7\u591a\u4e2a\u65b9\u5411(\u6216\u8def\u5f84)\u4e0a\u6240\u6709\u50cf\u7d20\u7684\u5f71\u54cd\uff0c\u65b9\u5411\u8d8a\u591a\u53c2\u4e0e\u5f71\u54cd\u5f53\u524d\u50cf\u7d20\u7684\u90bb\u57df\u50cf\u7d20\u5c31\u8d8a\u591a \u52a8\u6001\u89c4\u5212\uff1a Choosing the stereo baseline\uff1a Too small: large depth error Too large: difficult search problem","title":"1.2 Stereo matching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#13-multi-view-stereo","text":"Plane-Sweep: \u5e73\u9762\u626b\u63cf\u7b97\u6cd5 PatchMatch: PatchMatch Initialize pixels with random patch offsets Check if neighbors have better patch offsets Search in concentric radius around the current offset for better better patch offsets Go to Step 2 until converge.","title":"1.3 Multi-view stereo"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-3d-reconstruction","text":"","title":"2 3D reconstruction"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#21-3d-representations","text":"\u70b9\u4e91 mesh \u7528G(E, V)\u8868\u793a voxel SDF(Signed Distance Function) The distance of a point to the shape boundary The distance is defined by a metric, usually the Euclidean distance Truncated Signed Distance Function (TSDF): Truncation SDF\u2019s distance value to [\u22121, 1]","title":"2.1 3D representations"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#22-3d-surface-reconstruction","text":"KinectFusion \u6cca\u677e\u91cd\u5efa Marching Cubes\u7b97\u6cd5 \u89c6\u9891\u4ecb\u7ecdMarching Cubes\u7b97\u6cd5: Marching Squares \u57fa\u672c\u548cMarching cubes \u7c7b\u4f3c\u3002 COLMAP : \u4e00\u79cd\u901a\u7528\u7684\u8fd0\u52a8\u7ed3\u6784 (SfM) \u548c\u591a\u89c6\u56fe\u7acb\u4f53 (MVS) \u7ba1\u9053\u3002","title":"2.2 3D surface reconstruction"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#23-texture-mapping","text":"Surface lives in 3D world space Every 3D surface point also has a place where it goes in the 2D image (texture). \u7eb9\u7406\u6620\u5c04(Texture mapping)","title":"2.3 Texture mapping"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-9-deep-learning","text":"","title":"Lec 9 Deep Learning"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-machine-learning","text":"\u4f20\u7edf\u7a0b\u5e8f\u662f\u7ed9\u7535\u8111\u8f93\u5165\u548c\u7a0b\u5e8f\uff0c\u7535\u8111\u7ed9\u51fa\u8f93\u51fa\u3002 \u673a\u5668\u5b66\u4e60\u662f\u7ed9\u7535\u8111\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u7535\u8111\u7ed9\u51fa\u7a0b\u5e8f\u3002","title":"1 Machine learning"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u6982\u5ff5","text":"Model: \\(x\\) \u548c \\(y\\) \u4e4b\u95f4\u5173\u7cfb\u7684\u6570\u5b66\u8868\u793a Supervised learning(\u76d1\u7763\u5b66\u4e60): \u53ef\u4ee5\u7531\u8bad\u7ec3\u8d44\u6599\u4e2d\u5b66\u5230\u6216\u5efa\u7acb\u4e00\u4e2a\u6a21\u5f0f\uff08\u51fd\u6570/learning model\uff09\uff0c\u5e76\u4e14\u4f9d\u6b21\u6a21\u5f0f\u63a8\u6d4b\u51fa\u65b0\u7684\u5b9e\u4f8b\u3002 labeled data: exisitng (x,y) pairs, called training data. \u673a\u5668\u5b66\u4e60\u7684\u4e24\u4e2a\u9636\u6bb5\uff1a \u8bad\u7ec3(Training) \u6d4b\u8bd5(Testing)","title":"\u6982\u5ff5"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-linear-classifier","text":"","title":"2 Linear classifier"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#classification-model","text":"\u8f93\u5165\u662f\u4e00\u5f20\u56fe\u7247 \u8f93\u51fa\u662f\u6bcf\u4e2a\u5206\u7c7b\u7684\u5bf9\u5e94\u5206\u6570 \u6709\u4e24\u90e8\u5206\u7ec4\u6210\uff1a \u8bc4\u5206\u51fd\u6570 \u635f\u5931\u51fd\u6570","title":"CLassification model"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#linear-classifier","text":"\u5c06\u4e00\u5f20\u7167\u7247\u91cc\u9762\u7684\u6240\u6709\u50cf\u7d20\u53d8\u6210\u4e00\u4e2a\u5411\u91cf\u3002 \\(f(x_i,W,b) = Wx_i + b\\) \u53c2\u6570 W \u88ab\u79f0\u4e3a \u6743\u91cd\uff08weights\uff09 \uff0c b \u88ab\u79f0\u4e3a \u504f\u5dee\u5411\u91cf\uff08bias vector\uff09 \u3002 \u9996\u5148\uff0c\u4e00\u4e2a\u5355\u72ec\u7684\u77e9\u9635\u4e58\u6cd5 \\(Wx_i\\) \u5c31\u9ad8\u6548\u5730\u5e76\u884c\u8bc4\u4f3010\u4e2a\u4e0d\u540c\u7684\u5206\u7c7b\u5668\uff08\u6bcf\u4e2a\u5206\u7c7b\u5668\u9488\u5bf9\u4e00\u4e2a\u5206\u7c7b\uff09\uff0c\u5176\u4e2d\u6bcf\u4e2a\u7c7b\u7684\u5206\u7c7b\u5668\u5c31\u662fW\u7684\u4e00\u4e2a\u884c\u5411\u91cf\u3002 \u8bad\u7ec3\u6570\u636e\u7528\u6765\u5b66\u4e60 \\(W\\) \u548c \\(b\\) \u4e00\u5f20\u56fe\u50cf\u53ef\u770b\u505a\u9ad8\u7ef4\u7a7a\u95f4\u7684\u4e00\u4e2a\u70b9\uff0c\u6bcf\u4e2a\u5206\u7c7b\u5c31\u662f\u628a\u8fd9\u4e9b\u70b9\u5212\u5206\u6210\u82e5\u5e72\u4e2a\u533a\u57df\u3002","title":"Linear classifier"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#loss-function","text":"\u5224\u65ad\u4e00\u4e2a\u6743\u91cd\u77e9\u9635\u662f\u5426\u8db3\u591f\u597d \u56de\u5f52\u95ee\u9898\u4f7f\u7528\u5747\u65b9\u8bef\u5dee(MSE) \u5206\u7c7b\u95ee\u9898\u4f7f\u7528\u4ea4\u53c9\u71b5(Cross Entropy Loss) \u53c2\u8003\u8d44\u6599\uff1a \u7b80\u5355\u8c08\u8c08Cross Entropy Loss Softmax: \u628aK\u4e2a\u5b9e\u503c\u8f6c\u6362\u4e3a\u53e6\u5916K\u4e2a\u5b9e\u503c\u5e76\u4f7fK\u4e2a\u5b9e\u503c\u4e4b\u548c\u4e3a1\u7684\u51fd\u6570\u3002","title":"Loss function"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-neural-networks","text":"\u53c2\u8003\u8d44\u6599\uff1a \u6fc0\u6d3b\u51fd\u6570\uff08Activation Function\uff09 \u200b \u6fc0\u6d3b\u51fd\u6570 \uff1a\u4e0d\u4f7f\u7528\u6fc0\u6d3b\u51fd\u6570\u7684\u8bdd\uff0c\u795e\u7ecf\u7f51\u7edc\u7684\u6bcf\u5c42\u90fd\u53ea\u662f\u505a \u7ebf\u6027\u53d8\u6362 \uff0c\u591a\u5c42\u8f93\u5165\u53e0\u52a0\u540e\u4e5f\u8fd8\u662f\u7ebf\u6027\u53d8\u6362\u3002\u56e0\u4e3a\u7ebf\u6027\u6a21\u578b\u7684\u8868\u8fbe\u80fd\u529b\u901a\u5e38\u4e0d\u591f\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5c31\u4f53\u73b0\u4e86\u6fc0\u6d3b\u51fd\u6570\u7684\u4f5c\u7528\u4e86\uff0c\u6fc0\u6d3b\u51fd\u6570\u53ef\u4ee5\u5f15\u5165 \u975e\u7ebf\u6027\u56e0\u7d20 \u3002 \u200b \u5728\u795e\u7ecf\u7f51\u7edc\u6bcf\u4e00\u5c42\u795e\u7ecf\u5143\u505a\u5b8c\u7ebf\u6027\u53d8\u6362\u540e\uff0c\u52a0\u4e0a\u4e00\u4e2a\u975e\u7ebf\u6027\u6fc0\u52b1\u51fd\u6570\u5bf9\u7ebf\u6027\u53d8\u6362\u7684\u7ed3\u679c\u8fdb\u884c\u8f6c\u6362\uff0c\u8f93\u51fa\u5c31\u53ef\u4ee5\u53d8\u6210\u4e00\u4e2a\u975e\u7ebf\u6027\u7684\u51fd\u6570\u3002 \u591a\u5c42\u611f\u77e5\u5668 \u5168\u8fde\u63a5\u795e\u7ecf\u7f51\u7edc","title":"3 Neural networks"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-convolutional-neural-networks--\u5377\u79ef\u795e\u7ecf\u7f51\u7edc","text":"\u53c2\u8003\u8d44\u6599\uff1a \u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u8d85\u8be6\u7ec6\u4ecb\u7ecd","title":"4 Convolutional neural networks--\u5377\u79ef\u795e\u7ecf\u7f51\u7edc"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#convolution--local-connectivity--weight-sharing","text":"\u4e24\u8005\u7684\u5173\u952e\u4f5c\u7528\u5c31\u662f\u51cf\u5c11\u53c2\u6570\u6570\u91cf\uff0c\u4f7f\u8fd0\u7b97\u53d8\u5f97\u7b80\u6d01\u3001\u9ad8\u6548\uff0c\u80fd\u591f\u5728\u8d85\u5927\u89c4\u6a21\u6570\u636e\u96c6\u4e0a\u8fd0\u7b97 local connectivity(\u5c40\u90e8\u8fde\u63a5): \u5bf9\u4e8e\u5c40\u90e8\u8fde\u63a5\u800c\u8a00\uff1a\u5c42\u95f4\u795e\u7ecf\u53ea\u6709\u5c40\u90e8\u8303\u56f4\u5185\u7684\u8fde\u63a5\uff0c\u5728\u8fd9\u4e2a\u8303\u56f4\u5185\u91c7\u7528\u5168\u8fde\u63a5\u7684\u65b9\u5f0f\uff0c\u8d85\u8fc7\u8fd9\u4e2a\u8303\u56f4\u7684\u795e\u7ecf\u5143\u5219\u6ca1\u6709\u8fde\u63a5\uff1b\u8fde\u63a5\u4e0e\u8fde\u63a5\u4e4b\u95f4\u72ec\u7acb\u53c2\u6570\uff0c\u76f8\u6bd4\u4e8e\u53bb\u5168\u8fde\u63a5\u51cf\u5c11\u4e86\u611f\u53d7\u57df\u5916\u7684\u8fde\u63a5\uff0c\u6709\u6548\u51cf\u5c11\u53c2\u6570\u89c4\u6a21\u3002 weight sharing(\u6743\u503c\u5171\u4eab): \u4ece\u56fe\u50cf\u5c40\u90e8\u5b66\u4e60\u5230\u7684\u4fe1\u606f\u5e94\u7528\u5230\u56fe\u50cf\u7684\u5176\u4ed6\u90e8\u4f4d\u53bb\u3002\u6743\u503c\u5171\u4eab\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fc7\u6ee4\u5668\u5728\u904d\u5386\u6574\u4e2a\u56fe\u50cf\u7684\u65f6\u5019\uff0c\u8fc7\u6ee4\u5668\u7684\u53c2\u6570(\u5373\u8fc7\u6ee4\u5668\u7684\u53c2\u6570\u7684\u503c)\u662f\u56fa\u5b9a\u4e0d\u53d8\u7684 \u53c2\u8003\uff1a weight sharing","title":"Convolution = local connectivity + weight sharing"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u611f\u53d7\u91cereceptive-fields","text":"\u82e5\u76ee\u6807\u76f8\u5bf9\u611f\u53d7\u91ce\u8fc7\u5c0f\uff0c\u90a3\u8bad\u7ec3\u53c2\u6570\u53ea\u6709\u5c11\u90e8\u5206\u662f\u5bf9\u5e94\u4e8e\u8bad\u7ec3\u76ee\u6807\u7684\uff0c\u5219\u5728\u6d4b\u8bd5\u73af\u8282\uff0c\u4e5f\u5f88\u96be\u68c0\u6d4b\u51fa\u7c7b\u4f3c\u7684\u76ee\u6807\uff1b \u82e5\u76ee\u6807\u76f8\u5bf9\u611f\u53d7\u91ce\u8fc7\u5927\uff0c\u90a3\u8bad\u7ec3\u7684\u53c2\u6570\u90fd\u662f\u5bf9\u5e94\u4e8e\u6574\u4e2a\u5bf9\u8c61\u7684\u5c40\u90e8\u4fe1\u606f\uff0c\u662f\u4e0d\u591f\u5229\u4e8e\u68c0\u6d4b\u5c0f\u76ee\u6807\u7684\u3002","title":"\u611f\u53d7\u91ce(Receptive fields)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u6c60\u5316\u5c42pooling-layer","text":"","title":"\u6c60\u5316\u5c42(Pooling layer)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u603b\u4f53\u6846\u67b6","text":"","title":"\u603b\u4f53\u6846\u67b6"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#5-training-neural-networks","text":"","title":"5 Training neural networks"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u68af\u5ea6\u4e0b\u964d\u8bad\u7ec3cnn","text":"","title":"\u68af\u5ea6\u4e0b\u964d\u8bad\u7ec3CNN"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u53cd\u5411\u4f20\u64ad","text":"\u53c2\u8003\uff1a \u53cd\u5411\u4f20\u64ad-cs231n Forward data through the network, get loss Backprop to calculate the gradients Update the parameters using the gradient Go to step 1 if not converged","title":"\u53cd\u5411\u4f20\u64ad"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u968f\u673a\u68af\u5ea6\u4e0b\u964d\u6cd5sgd","text":"\u53c2\u8003\uff1a \u968f\u673a\u68af\u5ea6\u4e0b\u964d\u8be6\u89e3 \u4ec5\u8ba1\u7b97\u4e00\u6279\u968f\u673a\u91c7\u6837\u56fe\u50cf\u4e0a\u7684\u635f\u5931\u548c\u68af\u5ea6\u3002","title":"\u968f\u673a\u68af\u5ea6\u4e0b\u964d\u6cd5(SGD)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u8d85\u53c2\u6570hyper-parameters","text":"\u7b97\u6cd5\u8fd0\u884c\u524d\u9700\u8981\u51b3\u5b9a\u7684\u53c2\u6570\u3002 \u9009\u62e9\u4f9d\u636e\uff1a Train for original model Validate to find hyperparameters Test to understand generalizability","title":"\u8d85\u53c2\u6570(hyper-parameters)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u8fc7\u62df\u5408overfitting","text":"\u628a\u566a\u97f3\u70b9\u4e5f\u62df\u5408\u4e0a\u4e86\uff0c\u8fc7\u5206\u4f9d\u8d56\u6570\u636e\u96c6\u3002 \u9632\u6b62\uff1a Cross validation(\u9a8c\u8bc1) and early stop Regularization(\u6b63\u5219\u5316) or dropout \u6b63\u5219\u5316 \uff1a\u5728\u635f\u5931\u51fd\u6570\u4e2d\u7ed9\u6bcf\u4e2a\u53c2\u6570 w \u52a0\u4e0a\u6743\u91cd\uff0c\u5f15\u5165\u6a21\u578b\u590d\u6742\u5ea6\u6307\u6807\uff0c\u4ece\u800c\u6291\u5236\u6a21\u578b\u566a\u58f0\uff0c\u51cf\u5c0f\u8fc7\u62df\u5408\u3002 dropout \uff1a\u5728\u524d\u5411\u4f20\u64ad\u7684\u65f6\u5019\uff0c\u8ba9\u67d0\u4e2a\u795e\u7ecf\u5143\u7684\u6fc0\u6d3b\u503c\u4ee5\u4e00\u5b9a\u7684\u6982\u7387p\u505c\u6b62\u5de5\u4f5c\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u6a21\u578b\u6cdb\u5316\u6027\u66f4\u5f3a\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4f1a\u592a\u4f9d\u8d56\u67d0\u4e9b\u5c40\u90e8\u7684\u7279\u5f81 Data augmentation(\u6570\u636e\u589e\u5f3a) \u53c2\u8003\uff1a \u6570\u636e\u589e\u5f3a(Data Augmentation) \u200b \u4e3a\u4e86\u83b7\u5f97\u66f4\u591a\u7684\u6570\u636e\uff0c\u6211\u4eec\u53ea\u8981\u5bf9\u73b0\u6709\u7684\u6570\u636e\u96c6\u8fdb\u884c\u5fae\u5c0f\u7684\u6539\u53d8\u3002\u6bd4\u5982\u65cb\u8f6c\uff08flips\uff09\u3001\u79fb\u4f4d\uff08translations\uff09\u3001\u65cb\u8f6c\uff08rotations\uff09\u7b49\u5fae\u5c0f\u7684\u6539\u53d8\u3002\u6211\u4eec\u7684\u7f51\u7edc\u4f1a\u8ba4\u4e3a\u8fd9\u662f\u4e0d\u540c\u7684\u56fe\u7247\u3002","title":"\u8fc7\u62df\u5408(overfitting)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u6279\u6807\u51c6\u5316batch-normalization","text":"\u53c2\u8003 \u6df1\u5165\u7406\u89e3BN \u200b \u76ee\u7684\uff1aReduce internal covariate shift( \u5185\u90e8\u534f\u53d8\u91cf\u504f\u79fb ) \u200b \u795e\u7ecf\u7f51\u7edc\u7684\u6df1\u5ea6\u589e\u52a0\uff0c\u6bcf\u5c42\u7279\u5f81\u503c\u5206\u5e03\u4f1a\u9010\u6e10\u7684\u5411\u6fc0\u6d3b\u51fd\u6570\u7684\u8f93\u51fa\u533a\u95f4\u7684\u4e0a\u4e0b\u4e24\u7aef\uff08\u6fc0\u6d3b\u51fd\u6570\u9971\u548c\u533a\u95f4\uff09\u9760\u8fd1\uff0c\u8fd9\u6837\u7ee7\u7eed\u4e0b\u53bb\u5c31\u4f1a\u5bfc\u81f4\u68af\u5ea6\u6d88\u5931\u3002BN\u5c31\u662f\u901a\u8fc7\u65b9\u6cd5\u5c06 \u8be5\u5c42\u7279\u5f81\u503c\u5206\u5e03\u91cd\u65b0\u62c9\u56de\u6807\u51c6\u6b63\u6001\u5206\u5e03 \uff0c\u7279\u5f81\u503c\u5c06\u843d\u5728\u6fc0\u6d3b\u51fd\u6570\u5bf9\u4e8e\u8f93\u5165\u8f83\u4e3a\u654f\u611f\u7684\u533a\u95f4\uff0c\u8f93\u5165\u7684\u5c0f\u53d8\u5316\u53ef\u5bfc\u81f4\u635f\u5931\u51fd\u6570\u8f83\u5927\u7684\u53d8\u5316\uff0c\u4f7f\u5f97\u68af\u5ea6\u53d8\u5927\uff0c\u907f\u514d\u68af\u5ea6\u6d88\u5931\uff0c\u540c\u65f6\u4e5f\u53ef\u52a0\u5feb\u6536\u655b\u3002 \u200b \u8bad\u7ec3\u65f6\u7684\u4f7f\u7528\u65b9\u6cd5\uff1a\u5bf9\u6bcf\u4e2a\u9690\u5c42\u52a0\u4e0a\u4e00\u5c42BN\u3002","title":"\u6279\u6807\u51c6\u5316(Batch Normalization)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#6-network-architectures","text":"\u4ee5\u524d\u53d1\u5c55\u4e0d\u597d\uff1a \u6570\u636e\u96c6\u8fc7\u5c0f\u5bfc\u81f4\u8fc7\u62df\u5408 \u8ba1\u7b97\u80fd\u529b\u4e0d\u591f AlexNet ResNet DenseNet \uff1a\u4e92\u76f8\u8fde\u63a5\u6240\u6709\u7684\u5c42 MobileNets Neural Architecture Search (\u795e\u7ecf\u67b6\u6784\u641c\u7d22)","title":"6 Network architectures"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-10-recognition","text":"","title":"Lec 10 Recognition"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-semantic-segmentation\u8bed\u4e49\u5206\u5272","text":"\u5728\u56fe\u50cf\u9886\u57df\uff0c\u8bed\u4e49\u6307\u7684\u662f\u56fe\u50cf\u7684\u5185\u5bb9\uff0c\u5bf9\u56fe\u7247\u610f\u601d\u7684\u7406\u89e3\uff0c\u6bd4\u5982\u5de6\u56fe\u7684\u8bed\u4e49\u5c31\u662f\u4e09\u4e2a\u4eba\u9a91\u7740\u4e09\u8f86\u81ea\u884c\u8f66\uff1b\u5206\u5272\u7684\u610f\u601d\u662f\u4ece\u50cf\u7d20\u7684\u89d2\u5ea6\u5206\u5272\u51fa\u56fe\u7247\u4e2d\u7684\u4e0d\u540c\u5bf9\u8c61\uff0c\u5bf9\u539f\u56fe\u4e2d\u7684\u6bcf\u4e2a\u50cf\u7d20\u90fd\u8fdb\u884c\u6807\u6ce8\u3002","title":"1 Semantic segmentation(\u8bed\u4e49\u5206\u5272)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u540d\u8bcd\u89e3\u91ca","text":"\u6ed1\u52a8\u7a97\u53e3\uff1a\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\uff0c\u6709\u9650\u7684\u611f\u53d7\u91ce\u3002 \u5168\u8fde\u63a5\u5377\u79ef\u7f51\u7edc\uff1a\u4e00\u6b21\u505a\u51fa\u9884\u6d4b\uff0c\u635f\u5931\u51fd\u6570\u662f\u6bcf\u4e2a\u50cf\u7d20\u7684\u4ea4\u53c9\u71b5\u3002 Unpolling\uff1a\u4e00\u79cd\u4e0a\u91c7\u6837\u65b9\u6cd5\uff0c\u6709\u5f88\u591a\u79cd\u5177\u4f53\u6848\u4f8b\u3002","title":"\u540d\u8bcd\u89e3\u91ca"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#u-net","text":"Skip Connection: \u8df3\u8fc7\u4e2d\u95f4\u8fde\u63a5\uff0c\u4f7f\u6df1\u5c42\u548c\u6d45\u5c42\u8fde\u63a5\u8d77\u6765\u3002","title":"U-Net"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#deeplab","text":"\u53c2\u8003: \u56fe\u50cf\u8bed\u4e49\u5206\u5272\u4e4bFCN\u548cCRF \u56fe\u50cf\u8bed\u4e49\u5206\u5272\u6b65\u9aa4\uff1a FCN - \u5168\u5377\u79ef\u7f51\u7edc CRF - \u6761\u4ef6\u968f\u673a\u573a(Conditional random field) MRF - \u9a6c\u5c14\u79d1\u592b\u968f\u673a\u573a","title":"DeepLab"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u8bc4\u4f30\u6307\u6807","text":"Per-pixel Intersection-over-union","title":"\u8bc4\u4f30\u6307\u6807"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-object-detection\u76ee\u6807\u68c0\u6d4b","text":"\u8f93\u5165\uff1a\u4e00\u5f20RGB\u56fe\u7247 \u8f93\u51fa\uff1a\u8868\u793a\u5bf9\u8c61\u7684\u4e00\u7ec4\u8fb9\u754c\u6846(\u7c7b\u522b\u6807\u7b7e\u3001\u6846\u7684\u4f4d\u7f6e\uff0c\u6846\u7684\u5927\u5c0f)","title":"2 Object detection(\u76ee\u6807\u68c0\u6d4b)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u5355\u4e2a\u7269\u4f53\u68c0\u6d4b","text":"","title":"\u5355\u4e2a\u7269\u4f53\u68c0\u6d4b"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u591a\u4e2a\u7269\u4f53\u68c0\u6d4b","text":"\u4e00\u5f20\u7167\u7247\u7ecf\u8fc7\u5404\u79cd\u4e0d\u540c\u7684\u795e\u7ecf\u7f51\u7edc\uff0c\u5f97\u51fa\u7ed3\u679c\u3002","title":"\u591a\u4e2a\u7269\u4f53\u68c0\u6d4b"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u6ed1\u52a8\u7a97\u53e3","text":"Apply a CNN to many different crops of the image, CNN classifies each crop as object or background. \u4e00\u5f20\u56fe\u7247\u53ef\u4ee5\u88ab\u62c6\u5206\u6210\u5f88\u591aboxes\uff0c\u6211\u4eec\u4e0d\u80fd\u68c0\u6d4b\u6240\u6709\u8fd9\u4e9b\u56fe\u7247\u3002","title":"\u6ed1\u52a8\u7a97\u53e3"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#region-proposals\u5019\u9009\u533a\u57df","text":"\u7528\u56fe\u50cf\u5206\u5272\u7b97\u6cd5\u5148\u5206\u5272\u56fe\u50cf\uff0c\u7136\u540e\u518d\u8fdb\u884c\u76ee\u6807\u68c0\u6d4b\u3002","title":"Region proposals(\u5019\u9009\u533a\u57df)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#r-cnn","text":"\u9009\u5efa\u8bae\u6846\u5e76\u8c03\u6574\u5c3a\u5bf8 \u5bf9\u6bcf\u4e2a\u7c7b\u522b\u4f7f\u7528SVM\u5206\u7c7b\u5668\u8fdb\u884c\u6253\u5206 \u8fdb\u884c\u7b5b\u9009 \u635f\u5931\u51fd\u6570\uff1a \\(loU=\\frac {Area Of Overlap}{Area Of Union}\\) Mean Average Precision (mAP)\uff1a Run object detector on all test images For each category, compute Average Precision (AP) = area under Precision vs Recall Curve For each detection (highest score to lowest score) If it matches some GT box with IoU > 0.5, mark it as positive and eliminate the GT Otherwise mark it as negative Plot a point on PR Curve Average Precision (AP) = area under PR curve Mean Average Precision (mAP) = average of AP for each category For \u201cCOCO mAP\u201d: Compute mAP@thresh for each IoU threshold (0.5, 0.55, 0.6, \u2026, 0.95) and take average \u975e\u6700\u5927\u6291\u5236(Non-Max Suppression): Select the highest-scoring box Eliminate lower-scoring boxes with IoU > threshold If any boxes remain, goto 1","title":"R-CNN"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#fast-r-cnn","text":"A two-stage object detector First stage: run once per image Backbone network RPN Second stage: run once per region Crop features: RoI pool / align Predict object class Predict bbox offset","title":"Fast R-CNN:"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#rol-pool","text":"R-CNN\u4e2d\u7684ROIPool\u3001ROIAlign","title":"Rol Pool"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#rpn","text":"\u53c2\u8003\uff1a \u8be6\u89e3RPN\u7f51\u7edc RPN\uff08Region Proposal Network\uff09\u662fFaster-RCNN\u7f51\u7edc\u7528\u4e8e\u63d0\u53d6\u9884\u9009\u6846\uff08\u4e5f\u5c31\u662fRCNN\u4e2d\u4f7f\u7528selective search\u7b97\u6cd5\u8fdb\u884cRegion Proposal\u7684\u90e8\u5206\uff09\uff0cR-CNN\u53caFast-RCNN\u4e2d\u4e00\u4e2a\u6027\u80fd\u74f6\u9888\u5c31\u662f\u63d0\u53d6\u9884\u9009\u6846\u7684\u90e8\u5206\uff0c\u800cRPN\u5f88\u597d\u5730\u5bf9\u8fd9\u4e2a\u90e8\u5206\u8fdb\u884c\u4e86\u4f18\u5316\uff0c\u539f\u56e0\u5728\u4e8e\u5b83\u5c06\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u5f15\u5165\u4e86\u8fdb\u6765\uff0c\u4f7f\u7528\u7279\u5f81\u63d0\u53d6\u7684\u5f62\u5f0f\u751f\u6210\u51fa\u9884\u9009\u6846\u7684\u4f4d\u7f6e\u4ece\u800c\u964d\u4f4e\u4e86selective search\u7b97\u6cd5\u5e26\u6765\u7684\u8ba1\u7b97\u65f6\u95f4\u4e0a\u7684\u5f00\u9500\u3002 \u200b \u5047\u8bbe\u6211\u4eec\u6709\u4e00\u5f20\u5927\u5c0f\u4e3a600\u00d7800\u7684\u56fe\u50cf\uff0c\u5728\u901a\u8fc7\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\uff08CNN\uff09\u5757\u540e\uff0c\u8fd9\u5e45\u8f93\u5165\u56fe\u50cf\u7f29\u5c0f\u4e3a38\u00d756\u7684\u7279\u5f81\u56fe\uff0c\u7279\u5f81\u56fe\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u67099\u4e2a\u951a\u70b9\u76d2\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u670938 * 56 * 9=1192\u4e2a\u5efa\u8bae\u6216\u951a\u7bb1\u9700\u8981\u8003\u8651\u3002\u800c\u6bcf\u4e2a\u951a\u7bb1\u90fd\u6709\u4e24\u4e2a\u53ef\u80fd\u7684\u6807\u7b7e\uff08\u524d\u666f\u6216\u80cc\u666f\uff09\u3002\u5982\u679c\u6211\u4eec\u628a\u7279\u5f81\u56fe\u7684\u6df1\u5ea6\u5b9a\u4e3a18\uff089\u4e2a\u951a\u70b9x 2\u4e2a\u6807\u7b7e\uff09\uff0c\u6211\u4eec\u5c06\u4f7f\u6bcf\u4e2a\u951a\u70b9\u90fd\u6709\u4e00\u4e2a\u6709\u4e24\u4e2a\u503c\u7684\u5411\u91cf\uff08\u901a\u5e38\u79f0\u4e3a\u9884\u6d4b\u503c\uff09\uff0c\u4ee3\u8868\u524d\u666f\u548c\u80cc\u666f\u3002\u5982\u679c\u6211\u4eec\u5c06\u9884\u6d4b\u503c\u9001\u5165softmax/logistic\u56de\u5f52\u6fc0\u6d3b\u51fd\u6570\uff0c\u5b83\u5c06\u9884\u6d4b\u6807\u7b7e\u3002","title":"RPN"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-instance-segmentation\u5b9e\u4f8b\u5206\u5272","text":"\u8bed\u4e49\u5206\u5272\u7684\u8bdd\u53ea\u9700\u8981\u5206\u51fa\u4e0d\u540c\u7c7b\u5c31\u884c\uff0c\u540c\u7c7b\u7684\u4e0d\u540c\u4e2a\u4f53\u4e0d\u9700\u8981\u5206\uff0c\u4f46\u662fInstance Segmentation\u8fd9\u91cc\u5728\u8bed\u4e49\u5206\u5272\u7684\u57fa\u7840\u4e0a\u53c8\u628a\u4e0d\u540c\u7684\u7c7b\u8fdb\u884c\u4e86\u5206\u5272 \u76ee\u6807\u68c0\u6d4b\u540e\uff0c\u9700\u8981\u5bf9\u68c0\u6d4b\u7684\u90e8\u5206\u505a\u8fdb\u4e00\u6b65\u7684\u8bed\u4e49\u5206\u5272 Mask R-CNN : \u5728Faster R-CNN\u7684\u57fa\u7840\u4e0a\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9884\u6d4b\u5206\u5272mask\u7684\u5206\u652f\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\u5176\u4e2d\u9ed1\u8272\u90e8\u5206\u4e3a\u539f\u6765\u7684Faster-RCNN\uff0c\u7ea2\u8272\u90e8\u5206\u4e3a\u5728Faster-RCNN\u7f51\u7edc\u4e0a\u7684\u4fee\u6539\u3002\u5c06RoI Pooling \u5c42\u66ff\u6362\u6210\u4e86RoIAlign\u5c42\uff1b\u6dfb\u52a0\u4e86\u5e76\u5217\u7684FCN\u5c42\uff08mask\u5c42\uff09\u3002 DeepSnake: \u901a\u8fc7\u6df1\u5ea6\u5b66\u4e60\u7ed9\u51fa\u8f93\u5165\u521d\u59cb\u8f6e\u5ed3\u9876\u70b9\u9700\u8981\u8c03\u6574\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u5f97\u5230\u66f4\u4e3a\u51c6\u786e\u7684\u5b9e\u4f8b\u5206\u5272\u7ed3\u679c\u3002 Panoptic segmentation: \u5bf9\u6bcf\u4e00\u4e2a\u50cf\u7d20\u90fd\u5206\u51fa\u7c7b\u522b","title":"3 Instance segmentation(\u5b9e\u4f8b\u5206\u5272)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-human-pose-estimation\u4eba\u4f53\u59ff\u6001\u4f30\u8ba1","text":"\u901a\u8fc7\u5b9a\u4f4d\u4e00\u7ec4\u5173\u952e\u70b9\u6765\u8868\u793a\u4eba\u7684\u59ff\u52bf \u5355\u4eba\uff1aRepresent joint location as the heatmap(\u73b0\u5728\u628a\u5173\u952e\u70b9\u7528\u70ed\u529b\u56fe(heat map)\u8868\u793a\uff0c\u4e0d\u9700\u8981\u5168\u8fde\u63a5\u5c42\uff0c\u52a0\u901f\u7b97\u6cd5\u51cf\u5c11\u53c2\u6570\u91cf\u3002\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5173\u952e\u70b9\u8f93\u51fa\u4e00\u5f20heat map) \u591a\u4eba\uff1a Top-down(\u51c6\u786e)\uff1a\u628a\u591a\u4eba\u8f6c\u6210\u5355\u4eba\uff0c\u56fe\u50cf\u5206\u5272 Bottom-up(\u5feb)\uff1a\u5148\u68c0\u6d4b\u51fa\u56fe\u4e2d\u6240\u6709\u4eba\u7684\u6240\u6709\u5173\u952e\u70b9\uff0c\u518d\u5bf9\u5173\u952e\u70b9\u8fdb\u884c\u5206\u7ec4\uff0c\u8fdb\u800c\u7ec4\u88c5\u6210\u591a\u4e2a\u4eba \u4eba\u4f53\u59ff\u6001\u4f30\u8ba1(Human Pose Estimation)\u7ecf\u5178\u65b9\u6cd5\u6574\u7406","title":"4 Human pose estimation(\u4eba\u4f53\u59ff\u6001\u4f30\u8ba1)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#5-optical-flow\u5149\u6d41","text":"\u53c2\u8003\uff1a \u8ba1\u7b97\u673a\u89c6\u89c9--\u5149\u6d41\u6cd5(optical flow)\u7b80\u4ecb \u5149\u6d41(optical flow)\u662f\u7a7a\u95f4\u8fd0\u52a8\u7269\u4f53\u5728\u89c2\u5bdf\u6210\u50cf\u5e73\u9762\u4e0a\u7684\u50cf\u7d20\u8fd0\u52a8\u7684\u77ac\u65f6\u901f\u5ea6\u3002\u5728\u65f6\u95f4\u95f4\u9694\u5f88\u5c0f\uff08\u6bd4\u5982\u89c6\u9891\u7684\u8fde\u7eed\u524d\u540e\u4e24\u5e27\u4e4b\u95f4\uff09\u65f6\uff0c\u4e5f\u7b49\u540c\u4e8e\u76ee\u6807\u70b9\u7684\u4f4d\u79fb\u3002","title":"5 Optical flow(\u5149\u6d41)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#\u5149\u6d41\u573a","text":"\u200b \u5149\u6d41\u573a\u662f\u4e00\u4e2a\u4e8c\u7ef4\u77e2\u91cf\u573a\uff0c\u5b83\u53cd\u6620\u4e86\u56fe\u50cf\u4e0a\u6bcf\u4e00\u70b9\u7070\u5ea6\u7684\u53d8\u5316\u8d8b\u52bf\uff0c\u53ef\u770b\u6210\u662f\u5e26\u6709\u7070\u5ea6\u7684\u50cf\u7d20\u70b9\u5728\u56fe\u50cf\u5e73\u9762\u4e0a\u8fd0\u52a8\u800c\u4ea7\u751f\u7684\u77ac\u65f6\u901f\u5ea6\u573a\u3002\u5b83\u5305\u542b\u7684\u4fe1\u606f\u5373\u662f\u5404\u50cf\u70b9\u7684\u77ac\u65f6\u8fd0\u52a8\u901f\u5ea6\u77e2\u91cf\u4fe1\u606f\u3002 \u200b \u7814\u7a76\u5149\u6d41\u573a\u7684\u76ee\u7684\u5c31\u662f\u4e3a\u4e86\u4ece\u5e8f\u5217\u56fe\u50cf\u4e2d\u8fd1\u4f3c\u8ba1\u7b97\u4e0d\u80fd\u76f4\u63a5\u5f97\u5230\u7684\u8fd0\u52a8\u573a\u3002\u5149\u6d41\u573a\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5149\u6d41\u573a\u5bf9\u5e94\u4e8e\u8fd0\u52a8\u573a\u3002","title":"\u5149\u6d41\u573a\uff1a"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#flownet","text":"\u4e24\u90e8\u5206\uff1a\u7f29\u5c0f\u548c\u653e\u5927 \u7f29\u5c0f(\u5377\u79ef)\u90e8\u5206 \u7b2c\u4e00\u79cd\u7f29\u5c0f(\u5377\u79ef)\u65b9\u6848\u662f\u6700\u6734\u7d20\u7684\u65b9\u6cd5\u7684\uff0c\u5c31\u662f\u5c06\u8fd9\u4e00\u5bf9\u56fe\u7247\u7684\u901a\u9053concat\u8d77\u6765 \u7b2c\u4e8c\u4e2d\u65b9\u6848\u662f\u8fd9\u4e00\u5bf9\u56fe\u7247\u5206\u5f00\u5904\u7406\uff0c\u5206\u522b\u8fdb\u5165\u5377\u79ef\u7f51\u8def\uff0c\u5f97\u5230\u5404\u81ea\u7684\u7279\u5f81\u56fe\uff0c\u7136\u540e\u518d\u627e\u5230\u5b83\u4eec\u7279\u5f81\u56fe\u4e4b\u95f4\u7684\u8054\u7cfb\u3002 \u653e\u5927\u90e8\u5206 \u4e00\u8fb9\u5411\u540eunconv\uff0c\u4e00\u8fb9\u76f4\u63a5\u5728\u5c0f\u7684\u7279\u5f81\u56fe\u4e0a\u9884\u6d4b\uff0c\u7136\u540e\u628a\u7ed3\u679c\u53cc\u7ebf\u6027\u63d2\u503c\u7136\u540econcat\u5728unconv\u540e\u7684\u7279\u5f81\u56fe\u4e0a\uff0c\u7136\u540e\u63a5\u7740\u5f80\u540e\u4f20\uff0c\u91cd\u590d\u56db\u6b21\u540e\uff0c\u5f97\u5230\u7684\u9884\u6d4b\u5149\u6d41\u5206\u8fa8\u7387\u4f9d\u7136\u662f\u8f93\u5165\u7684\u00bc\uff0c\u518d\u91cd\u590d\u4e4b\u524d\u7684\u64cd\u4f5c\u5df2\u6ca1\u6709\u592a\u591a\u63d0\u5347\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u53cc\u7ebf\u6027\u63d2\u503c\u5f97\u5230\u548c\u8f93\u5165\u76f8\u540c\u5206\u8fa8\u7387\u7684\u5149\u6d41\u9884\u6d4b\u56fe\u3002","title":"FlowNet"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#6-other-tasks","text":"Video classification: Use 3D CNN Temporal action localization: Generate proposals then classify Multi-object tracking","title":"6 Other tasks"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-11--3d-deep-learning","text":"","title":"Lec 11  3D Deep Learning"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-feature-matching","text":"","title":"1 Feature matching"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#super-polint-\u7528\u4e8e\u63d0\u53d6\u7279\u5f81\u70b9","text":"CNN-based detectors: Representing feature point locations by heatmaps CNN-based descriptors: Extract descriptors from CNN feature maps(\u6bcf\u4e00\u5f20\u56fe\u90fd\u662f\u4e00\u5c42\u795e\u7ecf\u7f51\u7edc\u4e0b\u7684\u7279\u5f81\u56fe\uff0c\u53d6\u6240\u6709\u56fe\u4e2d\u5bf9\u5e94\u7684\u70b9\u505a\u4e00\u4e2a\u5411\u91cf)","title":"Super Polint: \u7528\u4e8e\u63d0\u53d6\u7279\u5f81\u70b9"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#superglue-\u73b0\u5728\u6700\u597d\u7684\u68c0\u6d4b\u65b9\u6cd5","text":"","title":"SuperGlue: \u73b0\u5728\u6700\u597d\u7684\u68c0\u6d4b\u65b9\u6cd5"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-object-pose-estimation","text":"Estimate the 3D location and orientation (\u4f4d\u7f6e\u548c\u65b9\u5411) of an object realtive to the camera frame. Before that, we need to define the geometry center of the object. Find 3D-2D correspondences Solve R and t by perspective-n-point (PnP) algorithm Find 2D-3D correspondences: detecting keyponts using CNNs","title":"2 Object Pose Estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-human-pose-estimation","text":"","title":"3 Human Pose Estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#markerless-mocap-\u76f8\u673a\u7167\u5c04\u5173\u952e\u70b9\u6807\u8bb0\u7269\u5728\u4eba\u8eab\u4f53\u4e0amarkless\u5c31\u662f\u4e0d\u7528\u8d34\u6807\u8bb0\u7269","text":"","title":"Markerless MoCap: \u76f8\u673a\u7167\u5c04\u5173\u952e\u70b9\uff0c\u6807\u8bb0\u7269\u5728\u4eba\u8eab\u4f53\u4e0a\uff0cMarkless\u5c31\u662f\u4e0d\u7528\u8d34\u6807\u8bb0\u7269"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#monocular-3d-human-pose-estimation-\u53c2\u6570\u5316\u4eba\u4f53\u6a21\u578b","text":"Estimating 3D human pose using a single camera Using networks to regress joint locations","title":"Monocular 3D Human Pose Estimation: \u53c2\u6570\u5316\u4eba\u4f53\u6a21\u578b"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-depth-estimation","text":"Multiview Depth Estimation: Reconstruct the dense 3D shape from a set of images and camera parameters Learned multi-view stereo Cost volume is a 3D array that stores the errors of all pixels at all depths","title":"4 Depth Estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#5-single-image-to-3d","text":"\u2022 Depth \u2022 Point Cloud \u2022 Mesh \u2022 Volume","title":"5 Single Image to 3D"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#monoculer-depth-estimation","text":"Learning to guess depth from large-scale training data","title":"Monoculer depth estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#single-view-shape-estimation","text":"\u9664\u4e86\u70b9\u4e91\uff0cmesh\u7b49\u65b9\u6cd5\u4e5f\u53ef\u5e94\u7528\u3002","title":"Single-view shape estimation"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#6-pointnet","text":"\u628a\u70b9\u4e91\u653e\u8fdb\u795e\u7ecf\u7f51\u7edc\uff0c\u4ee5\u524d\u7684\u795e\u7ecf\u7f51\u7edc\u90fd\u662f\u5149\u6805\u5316\u7684 \u6311\u62181\uff1a\u70b9\u987a\u5e8f\u4e0d\u786e\u5b9a\u2014\u2014\u6700\u540e\u518d\u505apooling \u6311\u62182\uff1a\u4f4d\u7f6e\u53d8\u5316\u4e0d\u786e\u5b9a\u2014\u2014\u4f30\u8ba1\u59ff\u6001","title":"6 PointNet"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-12-computational-photography-i","text":"","title":"Lec 12 Computational Photography I"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-high-dynamic-range-imaging-hdr","text":"","title":"1 High Dynamic Range Imaging (HDR)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#exposure\u66dd\u5149","text":"Exposure = Gain(\u589e\u76ca) x Irradiance(\u5149\u7ebf) x Time(\u65f6\u95f4) Gain is controlled by the ISO Irradiance is controlled by the aperture Time is controlled by the shutter speed","title":"Exposure:\u66dd\u5149"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#dynamic-range","text":"The ratio between the largest and smallest values of a certain quantity.","title":"Dynamic Range"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#hdr","text":"\u4eae\u7684\u5730\u65b9\u548c\u6697\u7684\u5730\u65b9\u80fd\u540c\u65f6\u62cd\u6e05\u695a \u5b9e\u73b0\u65b9\u6cd5\uff1a Exposure bracketing: Capture multiple LDR images at different exposures(\u4e00\u6b21\u62cd\u5f88\u591a\u5f20) Merging: Combine them into a single HDR image(\u7136\u540e\u5408\u5728\u4e00\u8d77)","title":"HDR"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#merge","text":"","title":"Merge"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#tone-mapping","text":"Display the HDR image (12-bit) on a SDR (standard dynamic range, 8-bit) device. Gamma compression X \u2192 aX \u03b3 , applied independently on R, G, B intend to keep more details on each parts. \u03b3 < 1: keep more datails on dart parts \u03b3 > 1: keep more datails on light parts","title":"Tone mapping"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-deblurring","text":"","title":"2 Deblurring"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#reason","text":"Defocus: the subject is not in the depth of view Motion blur: moving subjects or unstable camera \u2026\u2026","title":"Reason"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#modeling-image-blur","text":"The blurring process can be described by convolution. H is called blur kernel. Deblurring = Deconvolution NBID: Non-blind image deconvolution, the blur kernel is known. BID: Blind image deconvolution, the blur kernel is also unknown.","title":"Modeling Image Blur"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#nbid","text":"G: The captured image (known) F: Image to be solved (unknown) H: Blur kernel (known) Inverse Filter: will also amplify noise Wiener Filter: Suppress high frequency when reverse filtering Deconvolution by optimization Deconvolution is ill-posed, these are several sets of solutions have the same MSE. Objective function = likelihood function + regular term","title":"NBID"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#bid","text":"Blur kernel is non-negative and sparse. Optimized objective function:","title":"BID"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#3-colorization\u9ed1\u767d\u53d8\u5f69\u8272","text":"","title":"3 Colorization(\u9ed1\u767d\u53d8\u5f69\u8272)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#sample-based-colorization","text":"\u628a\u4e00\u5f20\u7167\u7247\u4e0a\u7684\u989c\u8272\u8fc1\u79fb\u5230\u53e6\u4e00\u5f20\u7167\u7247\uff0c\u4e3b\u8981\u4efb\u52a1\u662f\u50cf\u7d20\u5339\u914d","title":"Sample-based colorization"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#interactive-colorization","text":"\u7ed9\u51fa\u7ebf\u6761\u5927\u81f4\u7684\u989c\u8272(user-guided) Constraint: User-specified colors of brushed pixels keep unchanged","title":"Interactive colorization"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#generative-adversarial-network-gan","text":"D can be viewed as a loss function to train G\uff1a Called adversarial loss Learned instead of being hand-designed Can be applied to any image synthesis tasks","title":"Generative Adversarial Network (GAN)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#4-super-resolution","text":"Super Resolution using GAN","title":"4 Super Resolution"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#lec-13-computational-photography-ii","text":"","title":"Lec 13 Computational Photography II"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#1-image-based-rendering","text":"Rendering: from 3D models to images Image-based: \u57fa\u4e8e\u7167\u7247\u8fdb\u884c\u6e32\u67d3","title":"1 Image-based Rendering"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#light-fields","text":"The plenoptic function (7D) depicts light rays passing through.","title":"Light Fields"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#multi-plane-image-mpi","text":"A set of front-parallel planes at a fixed range of depths. Each plane encodes an RGB color image and an alpha/transparency map \u03b1 d .","title":"Multi-Plane Image (MPI)"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#nerf","text":"","title":"NeRF"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#2-neural-rendering","text":"","title":"2 Neural Rendering"},{"location":"CS%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/#pose-transfer--garment-transfer","text":"Input: Image(s) of a person Output: Synthesised images of the persion in different poses (Pose Transfer), or with different clothing (Garment Transfer). Method: Use parametric mesh (SMPL) to represent body pose and shape Use high-dimensional UV texture map to encode appearance Transfer the pose and appearance","title":"Pose Transfer &amp; Garment Transfer"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/","text":"Midquarter review of Stanford CS106L. stream \u00b6 stream: an abstraction for input/output. Streams convert between data and the string representation of data. Output Streams \u00b6 Have type std::ostream Can only send data using the << operator Converts any type into string and sends it to the stream std::cout is the output stream that goes to the console std :: cout << 5 << std :: endl ; // converts int value 5 to string \u201c5\u201d // sends \u201c5\u201d to the console output stream Output File Streams \u00b6 Have type std::ofstream Only receive data using the << operator Converts data of any type into a string and sends it to the file stream Must initialize your own ofstream object linked to your file std :: ofstream out ( \u201c out . txt \u201d , std :: ofstream :: out ); // out is now an ofstream that outputs to out.txt out << 5 << std :: endl ; // out.txt contains 5 Input Streams \u00b6 Have type std::istream Can only receive data using the >> operator Receives a string from the stream and converts it to data std::cin is the output stream that gets input from the console int x ; string str ; std :: cin >> x >> str ; //reads exactly one int then 1 string from console Nitty Gritty Details: std::cin \u00b6 First call to std::cin >> creates a command line prompt that allows the user to type until they hit enter Each >> ONLY reads until the next whitespace Whitespace = tab, space, newline Everything after the first whitespace gets saved and used the next time std::cin >> is called The place its saved is called a buffer! If there is nothing waiting in the buffer, std::cin >> creates a new command line prompt Whitespace is eaten: it won\u2019t show up in output Stringstreams \u00b6 Input stream: std::istringstream Give any data type to the istringstream, it\u2019ll store it as a string! Output stream: std::ostringstream Make an ostringstream out of a string, read from it word/type by word/type! The same as the other i/ostreams you\u2019ve seen //ostringstreams string judgementCall ( int age , string name , bool lovesCpp ) { std :: ostringstream formatter ; formatter << name << \", age \" << age ; if ( lovesCpp ) formatter << \", rocks.\" ; else formatter << \" could be better\" ; return formatter . str (); } //istringstreams Student reverseJudgementCall ( string judgement ) { std :: istringstream converter ; string fluff ; int age ; bool lovesCpp ; string name ; converter >> name ; converter >> fluff ; converter >> age ; converter >> fluff ; string cool ; converter >> cool ; if ( fluff == \"rocks\" ) return Student { name , age , \"bliss\" }; else return Student { name , age , \"misery\" }; } References \u00b6 References to variables \u00b6 vector < int > original { 1 , 2 }; vector < int > copy = original ; vector < int >& ref = original ; original . push_back ( 3 ); copy . push_back ( 4 ); ref . push_back ( 5 ); cout << original << endl ; // {1, 2, 3, 5} cout << copy << endl ; // {1, 2, 4} cout << ref << endl ; // {1, 2, 3, 5} The classic reference-copy bug: \u00b6 void shift ( vector < std :: pair < int , int >>& nums ) { for ( size_t i = 0 ; i < nums . size (); ++ i ) { auto [ num1 , num2 ] = nums [ i ]; //This creates a copy of the course num1 ++ ; num2 ++ ; //This is updating that same copy! } } //The classic reference-copy bug, fixed: void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } The classic reference-rvalue error \u00b6 void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } shift ({{ 1 , 1 }}); // {{1, 1}} is an rvalue, it can\u2019t be referenced l-values l-values can appear on the left or right of an = x is an l-value l-values have names l-values are not temporary r-values r-values can ONLY appear on the right of an = 3 is an r-value r-values don\u2019t have names r-values are temporary //The classic reference-rvalue error, fixed void shift ( vector < pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } auto my_nums = {{ 1 , 1 }}; shift ( my_nums ); const indicates a variable can\u2019t be modified \u00b6 std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference vec . push_back ( 3 ); // OKAY c_vec . push_back ( 3 ); // BAD - const ref . push_back ( 3 ); // OKAY c_ref . push_back ( 3 ); // BAD - const const & subtleties \u00b6 std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference Containers and Iterators \u00b6 Simple Sequence Containers \u00b6 graph TB A[Sequence Containers]-->B[Simple] A-->C[Adaptors] B-->d[vector] B-->e[deque] B-->f[list] B-->q[tuple] C-->p[stack] C-->o[queue] C-->m[priority_queue] graph TB A[Associative Containers]-->B[Ordered] A-->C[Unordered] B-->set B-->map C-->unordered_set C-->unordered_map What you want to do std::vector std::deque std::list Insert/remove in the front Slow Fast Fast Insert/remove in the back Super Fast Very Fast Fast Indexed Access Super Fast Fast Impossible Insert/remove in the middle Slow Fast Very Fast Memory usage Low High High Combining (splicing/joining) Slow Very Slow Fast Stability (iterators/concurrency) Bad Very Bad Good Container Adaptors \u00b6 What is a container adaptor? std::stack and std::queue Container adaptors are wrappers in C++ Container adaptors provide a different interface for sequence containers. You can choose what the underlying container is For instance, let\u2019s choose a deque as our underlying container, and let\u2019s implement a queue std :: queue < int > stack_deque ; // Container = std::deque std :: queue < int , std :: list < int >> stack_list ; // Container = std::list Associative Containers \u00b6 //set std :: set < int > s ; //Create an empty set s . insert ( k ); //Add a value k to the set s . erase ( k ); //Remove value k from the set if ( s . count ( k ))... //Check if a value k is in the set if ( vec . empty ())... //Check if vector is empty //map std :: map < int , char > m ; //Create an empty map m . insert ({ k , v }); m [ k ] = v ; //Add key k with value v into the map m . erase ( k ); //Remove key k from the map if ( m . count ( k )) ... //Check if key k is in the map if ( m . empty ()) ... //Check if the map is empty //Retrieve or overwrite value associated with key k (error if key isn\u2019t in map) char c = m . at ( k ); m . at ( k ) = v ; //Retrieve or overwrite value associated with key k (auto-insert if key isn\u2019t in map) char c = m [ k ]; m [ k ] = v ; STL Iterators \u00b6 Iterators are objects that point to elements inside containers. Each STL container has its own iterator, but all of these iterators exhibit a similar behavior! Generally, STL iterators support the following operations: std :: set < type > s = { 0 , 1 , 2 , 3 , 4 }; std :: set :: iterator iter = s . begin (); // at 0 ++ iter ; // at 1 * iter ; // 1 ( iter != s . end ()); // can compare iterator equality auto second_iter = iter ; // \"copy construction\" Why ++iter and not iter++? Answer : ++iter returns the value after being incremented! iter++ returns the previous value and then increments it. (wastes just a bit of time) Looping over collections \u00b6 //\u521d\u59cb std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( auto iter = set . begin (); iter != set . end (); ++ iter ) { const auto & elem = * iter ; cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( auto iter = map . begin (); iter != map . end (); ++ iter ) { const auto & [ key , value ] = * iter ; // structured binding! cout << key << \":\" << value << \", \" << endl ; } //\u6539\u8fdb std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( const auto & elem : set ) { cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( const auto & [ key , value ] : map ) { cout << key << \":\" << value << \", \" << endl ; } Pointers \u00b6 When variables are created, they're given an address in memory. Pointers are objects that store an address and type of a variable. classes \u00b6 A programmerdefined custom type. An abstraction of an object or data type. Sections \u00b6 Public section: Users of the Student object can directly access anything here! Defines interface for interacting with the private member variables Private section: Usually contains all member variables Users can\u2019t access or modify anything in the private section Constructors \u00b6 Define how the member variables of an object is initialized What gets called when you first create a Student object Overloadable Destructors \u00b6 Arrays are memory WE allocate, so we need to give instructions for when to deallocate that memory! When we are done using our array, we need to delete [] it! Template classes \u00b6 //mypair.cpp #include \u201cmypair.h\u201d template < class First , typename Second > First MyPair < First , Second >:: getFirst (){ return first ; } template < class Second , typename First > Second MyPair < First , Second >:: getSecond (){ return second ; } Member Types \u00b6 Sometimes, we need a name for a type that is dependent on our template types iterator is a member type of vector //vector.h template < typename T > class vector { using iterator = \u2026 // something internal private : iterator front ; } //vector.cpp template < typename T > typename vector < T >:: iterator vector < T >:: insert ( iterator pos , intvalue ) {...} //iterator is a nested type in namespace vector<T>:: Aside: Type Aliases You can use using type_name = type in application code as well! When using it in a class interface, it defines a nested type, like vector::iterator When using it in application code, like main.cpp, it just creates another name for type within that scope (until the next unmatched }) Summary Used to make sure your clients have a standardized way to access important types Lives in your namespace: vector<T>::iterator After class specifier, you can use the alias directly (e.g. inside function arguments, inside function body) Before class specifier, use typename. Recap \u00b6 Template classes Add template<typename T1, typename T2 ...> before class definition in .h Add template<typename T1, typename T2 ...> before all function signature in .cpp When returning nested types (like iterator types), put template<typename T1, typename T2 ...>::member_type as return type, not just member_type Templates don\u2019t emit code until instantiated, so #include the .cpp file in the .h file, not the other way around Const and Const-correctness Use const parameters and variables wherever you can in application code Every member function of a class that doesn\u2019t change its member variables should be marked const auto will drop all const and &, so be sure to specify Make iterators and const_iterators for all your classes! const iterator = cannot increment the iterator, can dereference and change underlying value const_iterator = can increment the iterator, cannot dereference and change underlying value const const_iterator = cannot increment iterator, cannot dereference and change underlying value","title":"\u671f\u4e2d\u590d\u4e60"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#stream","text":"stream: an abstraction for input/output. Streams convert between data and the string representation of data.","title":"stream"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#output-streams","text":"Have type std::ostream Can only send data using the << operator Converts any type into string and sends it to the stream std::cout is the output stream that goes to the console std :: cout << 5 << std :: endl ; // converts int value 5 to string \u201c5\u201d // sends \u201c5\u201d to the console output stream","title":"Output Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#output-file-streams","text":"Have type std::ofstream Only receive data using the << operator Converts data of any type into a string and sends it to the file stream Must initialize your own ofstream object linked to your file std :: ofstream out ( \u201c out . txt \u201d , std :: ofstream :: out ); // out is now an ofstream that outputs to out.txt out << 5 << std :: endl ; // out.txt contains 5","title":"Output File Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#input-streams","text":"Have type std::istream Can only receive data using the >> operator Receives a string from the stream and converts it to data std::cin is the output stream that gets input from the console int x ; string str ; std :: cin >> x >> str ; //reads exactly one int then 1 string from console","title":"Input Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#nitty-gritty-details-stdcin","text":"First call to std::cin >> creates a command line prompt that allows the user to type until they hit enter Each >> ONLY reads until the next whitespace Whitespace = tab, space, newline Everything after the first whitespace gets saved and used the next time std::cin >> is called The place its saved is called a buffer! If there is nothing waiting in the buffer, std::cin >> creates a new command line prompt Whitespace is eaten: it won\u2019t show up in output","title":"Nitty Gritty Details: std::cin"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#stringstreams","text":"Input stream: std::istringstream Give any data type to the istringstream, it\u2019ll store it as a string! Output stream: std::ostringstream Make an ostringstream out of a string, read from it word/type by word/type! The same as the other i/ostreams you\u2019ve seen //ostringstreams string judgementCall ( int age , string name , bool lovesCpp ) { std :: ostringstream formatter ; formatter << name << \", age \" << age ; if ( lovesCpp ) formatter << \", rocks.\" ; else formatter << \" could be better\" ; return formatter . str (); } //istringstreams Student reverseJudgementCall ( string judgement ) { std :: istringstream converter ; string fluff ; int age ; bool lovesCpp ; string name ; converter >> name ; converter >> fluff ; converter >> age ; converter >> fluff ; string cool ; converter >> cool ; if ( fluff == \"rocks\" ) return Student { name , age , \"bliss\" }; else return Student { name , age , \"misery\" }; }","title":"Stringstreams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#references","text":"","title":"References"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#references-to-variables","text":"vector < int > original { 1 , 2 }; vector < int > copy = original ; vector < int >& ref = original ; original . push_back ( 3 ); copy . push_back ( 4 ); ref . push_back ( 5 ); cout << original << endl ; // {1, 2, 3, 5} cout << copy << endl ; // {1, 2, 4} cout << ref << endl ; // {1, 2, 3, 5}","title":"References to variables"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#the-classic-reference-copy-bug","text":"void shift ( vector < std :: pair < int , int >>& nums ) { for ( size_t i = 0 ; i < nums . size (); ++ i ) { auto [ num1 , num2 ] = nums [ i ]; //This creates a copy of the course num1 ++ ; num2 ++ ; //This is updating that same copy! } } //The classic reference-copy bug, fixed: void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } }","title":"The classic reference-copy bug:"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#the-classic-reference-rvalue-error","text":"void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } shift ({{ 1 , 1 }}); // {{1, 1}} is an rvalue, it can\u2019t be referenced l-values l-values can appear on the left or right of an = x is an l-value l-values have names l-values are not temporary r-values r-values can ONLY appear on the right of an = 3 is an r-value r-values don\u2019t have names r-values are temporary //The classic reference-rvalue error, fixed void shift ( vector < pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } auto my_nums = {{ 1 , 1 }}; shift ( my_nums );","title":"The classic reference-rvalue error"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#const-indicates-a-variable-cant-be-modified","text":"std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference vec . push_back ( 3 ); // OKAY c_vec . push_back ( 3 ); // BAD - const ref . push_back ( 3 ); // OKAY c_ref . push_back ( 3 ); // BAD - const","title":"const indicates a variable can\u2019t be modified"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#const--subtleties","text":"std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference","title":"const &amp; subtleties"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#containers-and-iterators","text":"","title":"Containers and Iterators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#simple--sequence-containers","text":"graph TB A[Sequence Containers]-->B[Simple] A-->C[Adaptors] B-->d[vector] B-->e[deque] B-->f[list] B-->q[tuple] C-->p[stack] C-->o[queue] C-->m[priority_queue] graph TB A[Associative Containers]-->B[Ordered] A-->C[Unordered] B-->set B-->map C-->unordered_set C-->unordered_map What you want to do std::vector std::deque std::list Insert/remove in the front Slow Fast Fast Insert/remove in the back Super Fast Very Fast Fast Indexed Access Super Fast Fast Impossible Insert/remove in the middle Slow Fast Very Fast Memory usage Low High High Combining (splicing/joining) Slow Very Slow Fast Stability (iterators/concurrency) Bad Very Bad Good","title":"Simple  Sequence Containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#container-adaptors","text":"What is a container adaptor? std::stack and std::queue Container adaptors are wrappers in C++ Container adaptors provide a different interface for sequence containers. You can choose what the underlying container is For instance, let\u2019s choose a deque as our underlying container, and let\u2019s implement a queue std :: queue < int > stack_deque ; // Container = std::deque std :: queue < int , std :: list < int >> stack_list ; // Container = std::list","title":"Container Adaptors"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#associative-containers","text":"//set std :: set < int > s ; //Create an empty set s . insert ( k ); //Add a value k to the set s . erase ( k ); //Remove value k from the set if ( s . count ( k ))... //Check if a value k is in the set if ( vec . empty ())... //Check if vector is empty //map std :: map < int , char > m ; //Create an empty map m . insert ({ k , v }); m [ k ] = v ; //Add key k with value v into the map m . erase ( k ); //Remove key k from the map if ( m . count ( k )) ... //Check if key k is in the map if ( m . empty ()) ... //Check if the map is empty //Retrieve or overwrite value associated with key k (error if key isn\u2019t in map) char c = m . at ( k ); m . at ( k ) = v ; //Retrieve or overwrite value associated with key k (auto-insert if key isn\u2019t in map) char c = m [ k ]; m [ k ] = v ;","title":"Associative Containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#stl-iterators","text":"Iterators are objects that point to elements inside containers. Each STL container has its own iterator, but all of these iterators exhibit a similar behavior! Generally, STL iterators support the following operations: std :: set < type > s = { 0 , 1 , 2 , 3 , 4 }; std :: set :: iterator iter = s . begin (); // at 0 ++ iter ; // at 1 * iter ; // 1 ( iter != s . end ()); // can compare iterator equality auto second_iter = iter ; // \"copy construction\" Why ++iter and not iter++? Answer : ++iter returns the value after being incremented! iter++ returns the previous value and then increments it. (wastes just a bit of time)","title":"STL Iterators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#looping-over-collections","text":"//\u521d\u59cb std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( auto iter = set . begin (); iter != set . end (); ++ iter ) { const auto & elem = * iter ; cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( auto iter = map . begin (); iter != map . end (); ++ iter ) { const auto & [ key , value ] = * iter ; // structured binding! cout << key << \":\" << value << \", \" << endl ; } //\u6539\u8fdb std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( const auto & elem : set ) { cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( const auto & [ key , value ] : map ) { cout << key << \":\" << value << \", \" << endl ; }","title":"Looping over collections"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#pointers","text":"When variables are created, they're given an address in memory. Pointers are objects that store an address and type of a variable.","title":"Pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#classes","text":"A programmerdefined custom type. An abstraction of an object or data type.","title":"classes"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#sections","text":"Public section: Users of the Student object can directly access anything here! Defines interface for interacting with the private member variables Private section: Usually contains all member variables Users can\u2019t access or modify anything in the private section","title":"Sections"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#constructors","text":"Define how the member variables of an object is initialized What gets called when you first create a Student object Overloadable","title":"Constructors"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#destructors","text":"Arrays are memory WE allocate, so we need to give instructions for when to deallocate that memory! When we are done using our array, we need to delete [] it!","title":"Destructors"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#template-classes","text":"//mypair.cpp #include \u201cmypair.h\u201d template < class First , typename Second > First MyPair < First , Second >:: getFirst (){ return first ; } template < class Second , typename First > Second MyPair < First , Second >:: getSecond (){ return second ; }","title":"Template classes"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#member-types","text":"Sometimes, we need a name for a type that is dependent on our template types iterator is a member type of vector //vector.h template < typename T > class vector { using iterator = \u2026 // something internal private : iterator front ; } //vector.cpp template < typename T > typename vector < T >:: iterator vector < T >:: insert ( iterator pos , intvalue ) {...} //iterator is a nested type in namespace vector<T>:: Aside: Type Aliases You can use using type_name = type in application code as well! When using it in a class interface, it defines a nested type, like vector::iterator When using it in application code, like main.cpp, it just creates another name for type within that scope (until the next unmatched }) Summary Used to make sure your clients have a standardized way to access important types Lives in your namespace: vector<T>::iterator After class specifier, you can use the alias directly (e.g. inside function arguments, inside function body) Before class specifier, use typename.","title":"Member Types"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L-Midquarter-Review/#recap","text":"Template classes Add template<typename T1, typename T2 ...> before class definition in .h Add template<typename T1, typename T2 ...> before all function signature in .cpp When returning nested types (like iterator types), put template<typename T1, typename T2 ...>::member_type as return type, not just member_type Templates don\u2019t emit code until instantiated, so #include the .cpp file in the .h file, not the other way around Const and Const-correctness Use const parameters and variables wherever you can in application code Every member function of a class that doesn\u2019t change its member variables should be marked const auto will drop all const and &, so be sure to specify Make iterators and const_iterators for all your classes! const iterator = cannot increment the iterator, can dereference and change underlying value const_iterator = can increment the iterator, cannot dereference and change underlying value const const_iterator = cannot increment iterator, cannot dereference and change underlying value","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","text":"Stanford CS106L: Standard C++ Programming\u8bfe\u7a0b\u7b14\u8bb0\u3002 \u5f15\u8a00\uff1a CS106B/X \u548c CS106L \u662f\u914d\u5957\u8bfe\u7a0b\uff0c\u5b66\u4e60\u5b8c\u524d\u4e00\u4e2a\u518d\u5b66\u4e60 CS106L \u624d\u662f\u6b63\u786e\u7684\u8def\u5f84\u3002\u4f46\u662f\u6d59\u6c5f\u5927\u5b66\u7684\u300a\u6570\u636e\u7ed3\u6784\u57fa\u7840\u300b\u8bfe\u7a0b\u5df2\u7ecf\u5305\u62ec\u4e86 CS106B \u4e2d\u9664 C++ Class \u548c Huffman Coding \u4e4b\u5916\u7684\u5176\u4ed6\u5185\u5bb9\uff0c\u6240\u4ee5\u5bf9\u4e8e CS106B \u7684\u5185\u5bb9\u4ec5\u505a\u7b80\u5355\u8865\u5145\u3002 \u6b64\u7b14\u8bb0\u57fa\u4e8e CS 106L, Fall '21 Lec1 Welcome to CS 106L! \u00b6 Why C++ is important \u00b6 What is C++ \u00b6 #include <iostream> int main () { std :: cout << \"Hello World!\" << std :: endl ; return 0 ; } #include \"stdio.h\" #include \"stdlib.h\" int main ( int argc , char * argv ) { asm ( \"sub $0x20,%rsp \\n\\t \" // assembly code! \"movabs $0x77202c6f6c6c6548,%rax \\n\\t \" \"mov %rax,(%rsp) \\n\\t \" \"movl $0x646c726f, 0x8(%rsp) \\n\\t \" \"movw $0x21, 0xc(%rsp) \\n\\t \" \"movb $0x0,0xd(%rsp) \\n\\t \" \"leaq (%rsp),%rax \\n\\t \" \"mov %rax,%rdi \\n\\t \" \"call __Z6myputsPc \\n\\t \" \"add $0x20, %rsp \\n\\t \" ); return EXIT_SUCCESS ; } Lec2 Types and Structs \u00b6 Types make things better...and sometimes harder...but still better Types \u00b6 Fundamental Types \u00b6 int val = 5 ; //32 bits char ch = 'F' ; //8 bits (usually) float decimalVal1 = 5.0 ; //32 bits (usually) double decimalVal2 = 5.0 ; //64 bits (usually) bool bVal = true ; //1 bit #include <string> std :: string str = \"Frankie\" ; \u200b C++ is a statically typed language: everything with a name (variables, functions, etc) is given a type before runtime \u200b static typing helps us to prevent errors before our code runs Static Types + Function \u00b6 int add ( int a , int b ); int , int -> int string echo ( string phrase ); string -> string string helloworld (); void -> string double divide ( int a , int b ); int , int -> double Overloading \u00b6 int half ( int x , int divisor = 2 ) { // (1) return x / divisor ; } double half ( double x ) { // (2) return x / 2 ; } half ( 3 ) // uses version (1), returns 1 half ( 3 , 3 ) // uses version (1), returns 1 half ( 3.0 ) // uses version (2), returns 1.5 Intro to structs \u00b6 struct: a group of named variables each with their own type. A way to bundle different types together struct Student { string name ; // these are called fields string state ; // separate these by semicolons int age ; }; Student s ; s . name = \"Frankie\" ; s . state = \"MN\" ; s . age = 21 ; // use . to access fields void printStudentInfo ( Student student ) { cout << s . name << \" from \" << s . state ; cout << \" (\" << s . age \")\" << endl ; } Student randomStudentFrom ( std :: string state ) { Student s ; s . name = \"Frankie\" ; //random = always Frankie s . state = state ; s . age = std :: randint ( 0 , 100 ); return s ; } Student foundStudent = randomStudentFrom ( \"MN\" ); cout << foundStudent . name << endl ; // Frankie std::pair: An STL built-in struct with two fields of any type std :: pair < int , string > numSuffix = { 1 , \"st\" }; cout << numSuffix . first << numSuffix . second ; //prints 1st struct Pair { fill_in_type first ; fill_in_type second ; }; //pair in functions std :: pair < bool , Student > lookupStudent ( string name ) { Student blank ; if ( found ( name )) return std :: make_pair ( false , blank ); Student result = getStudentWithName ( name ); return std :: make_pair ( true , result ); } std :: pair < bool , Student > output = lookupStudent ( \u201c Keith \u201d ); auto: Keyword used in lieu of type when declaring a variable, tells the compiler to deduce the type. //It means that the type is deduced by the compiler. auto a = 3 ; auto b = 4.3 ; auto c = \u2018 X \u2019 ; auto d = \u201c Hello \u201d ; auto e = std :: make_pair ( 3 , \u201c Hello \u201d ); Sneak peek at streams \u00b6 stream: an abstraction for input/output. Streams convert between data and the string representation of data. std :: cout << 5 << std :: endl ; // prints 5 // use a stream to print any primitive type! std :: cout << \"Frankie\" << std :: endl ; // Mix types! std :: cout << \"Frankie is \" << 21 << std :: endl ; // structs? Student s = { \"Frankie\" , \"MN\" , 21 }; std :: cout << s . name << s . age << std :: endl ; Recap \u00b6 Everything with a name in your program has a type Strong type systems prevent errors before your code runs! Structs are a way to bundle a bunch of variables of many types std::pair is a type of struct that had been defined for you and is in the STL So you access it through the std:: namespace (std::pair) auto is a keyword that tells the compiler to deduce the type of a variable, it should be used when the type is obvious or very cumbersome to write out Lec3 Initialization & References \u00b6 Initialization \u00b6 Initialization: How we provide initial values to variables // Recall: Two ways to initialize a struct Student s ; s . name = \"Frankie\" ; s . state = \"MN\" ; s . age = 21 ; //is the same as ... Student s = { \"Frankie\" , \"MN\" , 21 }; //Multiple ways to initialize a pair std :: pair < int , string > numSuffix1 = { 1 , \"st\" }; std :: pair < int , string > numSuffix2 ; numSuffix2 . first = 2 ; numSuffix2 . second = \"nd\" ; std :: pair < int , string > numSuffix2 = std :: make_pair ( 3 , \"rd\" ); //Initialization of vectors std :: vector < int > vec1 ( 3 , 5 ); // makes {5, 5, 5}, not {3, 5}! std :: vector < int > vec2 ; vec2 = { 3 , 5 }; // initialize vec2 to {3, 5} after its declared Uniform initialization: curly bracket initialization. Available for all types, immediate initialization on declaration(\u7edf\u4e00\u521d\u59cb\u5316\uff1a\u58f0\u660e\u65f6\u7528\u82b1\u62ec\u53f7\u5b9a\u4e49) std :: vector < int > vec { 1 , 3 , 5 }; std :: pair < int , string > numSuffix1 { 1 , \"st\" }; Student s { \"Frankie\" , \"MN\" , 21 }; // less common/nice for primitive types, but possible! int x { 5 }; string f { \"Frankie\" }; //Careful with Vector initialization! std :: vector < int > vec1 ( 3 , 5 ); // makes {5, 5, 5}, not {3, 5}! //uses a std::initializer_list (more later) std :: vector < int > vec2 { 3 , 5 }; // makes {3, 5} //TLDR: use uniform initialization to initialize every field of your non-primitive typed variables - but be careful not to use vec(n, k)! auto: use it to reduce long type names std :: pair < bool , std :: pair < double , double >> result = quadratic ( a , b , c ); //It can be write as below auto result = quadratic ( a , b , c ); Don\u2019t overuse auto! //A better way to use quadratic int main () { auto a , b , c ; std :: cin >> a >> b >> c ; auto [ found , solutions ] = quadratic ( a , b , c ); if ( found ) { auto [ x1 , x2 ] = solutions ; std :: cout << x1 << \u201c \u201d << x2 << endl ; } else { std :: cout << \u201c No solutions found ! \u201d << endl ; } } //This is better is because it\u2019s semantically clearer: variables have clear names References \u00b6 Reference: An alias (another name) for a named variable References in 106B void changeX ( int & x ){ //changes to x will persist x = 0 ; } void keepX ( int x ){ x = 0 ; } int a = 100 ; int b = 100 ; changeX ( a ); //a becomes a reference to x keepX ( b ); //b becomes a copy of x cout << a << endl ; //0 cout << b << endl ; //100 References in 106L: References to variables vector < int > original { 1 , 2 }; vector < int > copy = original ; vector < int >& ref = original ; original . push_back ( 3 ); copy . push_back ( 4 ); ref . push_back ( 5 ); cout << original << endl ; // {1, 2, 3, 5} cout << copy << endl ; // {1, 2, 4} cout << ref << endl ; // {1, 2, 3, 5} //\u201c=\u201d automatically makes a copy! Must use & to avoid this. Reference-copy bug //bug void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } //fixed void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } l-values l-values can appear on the left or right of an = x is an l-value l-values have names l-values are not temporary r-values r-values can ONLY appear on the right of an = 3 is an r-value r-values don\u2019t have names r-values are temporary The classic reference-rvalue error //\u53ef\u4ee5\u53d6\u5730\u5740\u7684\uff0c\u6709\u540d\u5b57\u7684\uff0c\u975e\u4e34\u65f6\u7684\u5c31\u662f\u5de6\u503c\uff1b\u4e0d\u80fd\u53d6\u5730\u5740\u7684\uff0c\u6ca1\u6709\u540d\u5b57\u7684\uff0c\u4e34\u65f6\u7684\u5c31\u662f\u53f3\u503c\uff1b void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } shift ({{ 1 , 1 }}); // {{1, 1}} is an rvalue, it can\u2019t be referenced //fixed void shift ( vector < pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } auto my_nums = {{ 1 , 1 }}; shift ( my_nums ); BONUS: Const and Const References \u00b6 const indicates a variable can\u2019t be modified! std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference, \u6ce8\u610f\u524d\u9762\u4e5f\u8981\u52a0\u4e0a const vec . push_back ( 3 ); // OKAY c_vec . push_back ( 3 ); // BAD - const ref . push_back ( 3 ); // OKAY c_ref . push_back ( 3 ); // BAD - const const std :: vector < int > c_vec { 7 , 8 }; // a const variable // BAD - can't declare non-const ref to const vector std :: vector < int >& bad_ref = c_vec ; // fixed const std :: vector < int >& bad_ref = c_vec ; // BAD - Can't declare a non-const reference as equal to a const reference! std :: vector < int >& ref = c_ref ; const & subtleties std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference \u200b Remember: C++, by default, makes copies when we do variable assignment! We need to use & if we need references instead. Recap \u00b6 Use input streams to get information Use structs to bundle information Use uniform initialization wherever possible Use references to have multiple aliases to the same thing Use const references to avoid making copies whenever possible Lec4 Streams \u00b6 stream: an abstraction for input/output. Streams convert between data and the string representation of data. Input streams \u00b6 std::cin is an input stream. It has type std::istream Have type std::istream Can only receive strings using the >> operator Receives a string from the stream and converts it to data std::cin is the input stream that gets input from the console int x ; string str ; std :: cin >> x >> str ; //reads exactly one int then 1 string from console First call to std::cin >> creates a command line prompt that allows the user to type until they hit enter Each >> ONLY reads until the next whitespace Whitespace = tab, space, newline Everything after the first whitespace gets saved and used the next time std::cin >> is called If there is nothing waiting in the buffer, std::cin >> creates a new command line prompt Whitespace is eaten: it won\u2019t show up in output string str ; int x ; std :: cin >> str >> x ; //what happens if input is \"blah blah\"? std :: cout << str << x ; //once an error is detected, the input stream\u2019s //fail bit is set, and it will no longer accept //input To read a whole line, use std::getline(istream& stream, string& line); std :: string line ; std :: getline ( cin , line ); //now line has changed! //say the user entered \u201cHello World 42!\u201d std :: cout << line << std :: endl ; //should print out\u201cHello World 42!\u201d >> reads up to the next whitespace character and does not go past that whitespace character. getline reads up to the next delimiter (by default, \u2018\\n\u2019), and does go past that delimiter. Output streams \u00b6 std::cout is an output stream. It has type std::ostream Can only send data using the << operator Converts any type into string and sends it to the stream std::cout is the output stream that goes to the console File streams \u00b6 Input File Streams \u00b6 Have type std::ifstream Only send data using the >> operator Receives strings from a file and converts it to data of any type Must initialize your own ifstream object linked to your file std :: ifstream in ( \u201c out . txt \u201d ); // in is now an ifstream that reads from out.txt string str ; in >> str ; // first word in out.txt goes into str Output File Streams \u00b6 Have type std::ofstream Only send data using the << operator Converts data of any type into a string and sends it to the file stream Must initialize your own ofstream object linked to your file std :: ofstream out ( \u201c out . txt \u201d ); // out is now an ofstream that outputs to out.txt out << 5 << std :: endl ; // out.txt contains 5 string streams \u00b6 Input stream: std::istringstream Give any data type to the istringstream, it\u2019ll store it as a string! Output stream: std::ostringstream Make an ostringstream out of a string, read from it word/type by word/type The same as the other i/ostreams you\u2019ve seen! ostringstreams \u00b6 string judgementCall ( int age , string name , bool lovesCpp ) { std :: ostringstream formatter ; formatter << name << \", age \" << age ; if ( lovesCpp ) formatter << \", rocks.\" ; else formatter << \" could be better\" ; return formatter . str (); } istringstreams \u00b6 Student reverseJudgementCall ( string judgement ){ //input: \u201cFrankie age 22, rocks\u201d std :: istringstream converter ; string fluff ; int age ; bool lovesCpp ; string name ; converter >> name ; converter >> fluff ; converter >> age ; converter >> fluff ; string cool ; converter >> cool ; if ( cool == \"rocks\" ) return Student { name , age , \"bliss\" }; else return Student { name , age , \"misery\" }; } // returns: {\u201cFrankie\u201d, 22, \u201cbliss\u201d} Recap \u00b6 Streams convert between data of any type and the string representation of that data. Streams have an endpoint: console for cin/cout, files for i/o fstreams, string variables for i/o streams where they read in a string from or output a string to. To send data (in string form) to a stream, use stream_name << data. To extract data from a stream, use stream_name >> data, and the stream will try to convert a string to whatever type data is. Lec5 Containers \u00b6 What's in the STL: Containers Iterators Functions Algorithms Types of containers \u00b6 All containers can hold almost all elements graph TB A[Sequence Containers]-->B[Simple] A-->C[Adaptors] B-->d[vector] B-->e[deque] B-->f[list] B-->q[tuple] C-->p[stack] C-->o[queue] C-->m[priority_queue] graph TB A[Associative Containers]-->B[Ordered] A-->C[Unordered] B-->set B-->map C-->unordered_set C-->unordered_map Sequence Containers \u00b6 vector \u00b6 #include <vector> //construct std :: vector < int > intArr ; //Create a new, empty vector std :: vector < int > vec ( n ); //Create a vector with n copies of 0 std :: vector < int > vec ( n , k ); //Create a vector with n copies of a value k std :: vector < string > strArr ; std :: vector < myStruct > structArr ; std :: vector < std :: vector < string >> vecArr ; //\u4e8c\u7ef4\u6570\u7ec4 //use int k = vec [ i ]; //Get the element at index i (does not bounds check) vec . push_back ( k ); //Add a value k to the end of a vector for ( std :: size_t i = 0 ; i < vec . size (); ++ i ) //Loop through vector by index i vec [ i ] = k ; //Replace the element at index i(does not bounds check) vec . clear (); //Remove all elements of a vector vec . size (); //Check size of vector vec . pop_back (); //\u5220\u9664\u672b\u5c3e vec . capacity (); //\u7ed9vector\u5206\u914d\u7684\u7a7a\u95f4\u5927\u5c0f vec . empty (); //\u5224\u65ad\u662f\u5426\u4e3a\u7a7a vec . at ( 2 ); //\u4f4d\u7f6e\u4e3a2\u5904\u5143\u7d20\u5f15\u7528 vec . begin (); //\u5934\u6307\u9488 vec . end (); //\u5c3e\u6307\u9488 \u83dc\u9e1f\u6559\u7a0b array \u00b6 #include <array> //construct std :: array < int , 3 > arr = { 1 , 2 , 3 }; std :: array < std :: array < string , 3 > , 4 > ; //4*3\u7684string\u6570\u7ec4 //\u8bbf\u95ee arr . at ( 2 ). at ( 1 ); //\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u8bbf\u95ee deque \u00b6 \u200b deque \u652f\u6301 vector \u7684\u6240\u6709\u64cd\u4f5c\uff0c\u5e76\u4e14\u652f\u6301\u5feb\u901f push_front() \uff0c\u4f46\u662f\u5b9e\u8df5\u4e2d\u4e00\u822c\u4f7f\u7528 vector \uff0c\u56e0\u4e3a\u5176\u4ed6\u64cd\u4f5c\u66f4\u5feb\u3002 list \u00b6 \u200b A list provides fast insertion anywhere, but no random (indexed) access. What you want to do std::vector std::deque std::list Insert/remove in the front Slow Fast Fast Insert/remove in the back Super Fast Very Fast Fast Indexed Access Super Fast Fast Impossible Insert/remove in the middle Slow Fast Very Fast Memory usage Low High High Combining (splicing/joining) Slow Very Slow Fast Stability (iterators/concurrency) Bad Very Bad Good wrapper: A wrapper on an object changes how external users can interact with that object. Container adaptors are wrappers in C++! queue \u00b6 queue . push_back (); queue . pop_front (); stack \u00b6 stack . push_back (); stack . pop_back (); priority_queue \u00b6 \u200b Adding elements with a priority, always removing the highest priority-element. Associative Containers \u00b6 set \u00b6 set \u5c31\u662f\u96c6\u5408\uff0c\u6bcf\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u6309\u952e\u503c\u5347\u5e8f\u6392\u5217\u3002\u8bbf\u95ee\u5143\u7d20\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(logn). std :: set < int > s ; //Create an empty set s . insert ( k ); //Add a value k to the set s . erase ( k ); //Remove value k from the set if ( s . count ( k ))... //Check if a value k is in the set if ( vec . empty ())... //Check if vector is empty map \u00b6 map \u662fc++\u6807\u51c6\u5e93\u4e2d\u5b9a\u4e49\u7684\u5173\u8054\u5bb9\u5668\uff0c\u662f\u952e\uff08key\uff09\u503c\uff08value\uff09\u5bf9\u7684\u7ed3\u5408\u4f53\u3002 std :: map < int , char > m ; //Create an empty map m . insert ({ k , v }); m [ k ] = v ; //Add key k with value v into the map m . erase ( k ); //Remove key k from the map if ( m . count ( k )) ... //Check if key k is in the map if ( m . empty ()) ... //Check if the map is empty //Retrieve or overwrite value associated with key k (error if key isn\u2019t in map) char c = m . at ( k ); m . at ( k ) = v ; //Retrieve or overwrite value associated with key k (auto-insert if key isn\u2019t in map) char c = m [ k ]; m [ k ] = v ; Every std::map<k, v> is actually backed by: std::pair<const k, v> //Iterating through maps and sets std :: set < ... > s ; std :: map < ..., ... > m ; for ( const auto & element : s ) { // do stuff with element } for ( const auto & [ key , value ] : m ) { // do stuff with key and value } unordered_map and unordered_set \u00b6 Each STL set/map comes with an unordered sibling. They\u2019re almost the same, except: Instead of a comparison operator, the set/map type must have a hash function defined for it. Simple types, like int, char, bool, double, and even std::string are already supported! Any containers/collections need you to provide a hash function to use them. unordered_map/unordered_set are generally faster than map/set. Recap \u00b6 Sequence Containers std::vector - use for almost everything std::deque - use when you need fast insertion to front AND back Container Adaptors sta::stack and std::queue Associative Containers std::map and std::set if using simple data types/you\u2019re familiar with hash functions, use std::unordered_map and std::unordered_set Lec6 Iterators and Pointers \u00b6 Iterators \u00b6 A way to access all containers programmatically! Iterators are objects that point to elements inside containers. Each STL container has its own iterator, but all of these iterators exhibit a similar behavior! Generally, STL iterators support the following operations: std :: set < type > s = { 0 , 1 , 2 , 3 , 4 }; std :: set :: iterator iter = s . begin (); // at 0 ++ iter ; // at 1 * iter ; // 1 ( iter != s . end ()); // can compare iterator equality auto second_iter = iter ; // \"copy construction\" Types: Input Iterator\uff1a\u53ea\u80fd\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\uff0c\u4e0d\u5141\u8bb8\u4fee\u6539\u7531\u8be5\u7c7b\u8fed\u4ee3\u5668\u5f15\u7528\u7684\u5143\u7d20\u3002 Output Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u548cInput Iterator\u6781\u5176\u76f8\u4f3c\uff0c\u4e5f\u53ea\u80fd\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\uff0c\u4e0d\u540c\u7684\u662f\u8be5\u7c7b\u8fed\u4ee3\u5668\u5bf9\u5143\u7d20\u53ea\u6709\u5199\u7684\u6743\u529b\u3002 Forward Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u53ef\u4ee5\u5728\u4e00\u4e2a\u6b63\u786e\u7684\u533a\u95f4\u4e2d\u8fdb\u884c\u8bfb\u5199\u64cd\u4f5c\uff0c\u5b83\u62e5\u6709Input Iterator\u7684\u6240\u6709\u7279\u6027\uff0c\u548cOutput Iterator\u7684\u90e8\u5206\u7279\u6027\uff0c\u4ee5\u53ca\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\u7684\u80fd\u529b\u3002 Bidirectional Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u662f\u5728Forward Iterator\u7684\u57fa\u7840\u4e0a\u63d0\u4f9b\u4e86\u5355\u6b65\u5411\u540e\u8fed\u4ee3\u5143\u7d20\u7684\u80fd\u529b\u3002 Random Access Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u80fd\u5b8c\u6210\u4e0a\u9762\u6240\u6709\u8fed\u4ee3\u5668\u7684\u5de5\u4f5c\uff0c\u5b83\u81ea\u5df1\u72ec\u6709\u7684\u7279\u6027\u5c31\u662f\u53ef\u4ee5\u50cf\u6307\u9488\u90a3\u6837\u8fdb\u884c\u7b97\u672f\u8ba1\u7b97\uff0c\u800c\u4e0d\u662f\u4ec5\u4ec5\u53ea\u6709\u5355\u6b65\u5411\u524d\u6216\u5411\u540e\u8fed\u4ee3\u3002 Explain: There are a few different types of iterators, since containers are different! All iterators can be incremented (++) Input iterators can be on the RHS (right hand side) of an = sign: auto elem = *it; Output iterators can be on the LHS of = : *elem = value; Random access iterators support indexing by integers! it += 3 ; // move forward by 3 it -= 70 ; // move backwards by 70 auto elem = it [ 5 ]; // offset by 5 Why ++iter and not iter++? \u200b Answer : ++iter returns the value after being incremented! iter++ returns the previous value and then increments it. (wastes just a bit of time) std :: map < int , int > map {{ 1 , 2 }, { 3 , 4 }}; auto iter = map . begin (); // what is *iter? ++ iter ; auto iter2 = iter ; // what is (*iter2).second? ++ iter2 ; // now what is (*iter).first? // ++iter: go to the next element // *iter: retrieve what's at iter's position // copy constructor: create another iterator pointing to the same thing std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( auto iter = set . begin (); iter != set . end (); ++ iter ) { const auto & elem = * iter ; cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( auto iter = map . begin (); iter != map . end (); ++ iter ) { const auto & [ key , value ] = * iter ; // structured binding! cout << key << \":\" << value << \", \" << endl ; } std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( const auto & elem : set ) { cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( const auto & [ key , value ] : map ) { cout << key << \":\" << value << \", \" << endl ; } auto key = ( * iter ). first ; auto key = iter -> first ; //These are equivalent. Pointers \u00b6 When variables are created, they're given an address in memory. Pointers are objects that store an address and type of a variable. To get the value of a pointer, we can dereference it (get the object referenced by the pointer) int x = 5 ; int * pointerToInt = & x ; // creates pointer to int cout << * pointerToInt << endl ; // 5 std :: pair < int , int > pair = { 1 , 2 }; // creates pair std :: pair < int , int >* pointerToPair = & pair ; // creates pointer to pair cout << ( * pair ). first << endl ; // 1 cout << pair -> first << endl ; // 1 Pointers vs. Iterators \u00b6 Iterators are a form of pointers! Pointers are more generic iterators can point to any object, not just elements in a container! std :: string lands = \"Xadia\" ; // iterator auto iter = lands . begin (); // syntax for a pointer. don't worry about the specifics if you're in 106B! they'll be discussed in the latter half of the course. char * firstChar = & lands [ 0 ]; Lec7 Classes \u00b6 Containers are all classes defined in the STL! Iterators are (basically) pointers! More on that later Class: A programmerdefined custom type. An abstraction of an object or data type. But don\u2019t structs do that? \u00b6 struct Student { string name ; // these are called fields string state ; // separate these by semicolons int age ; }; Student s = { \"Frankie\" , \"MN\" , 21 }; Issues with structs Public access to all internal state data by default Users of struct need to explicitly initialize each data member. Classes provide their users with a public interface and separate this from a private implementation. Turning Student into a class: Header File + .cpp File: \u00b6 //student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; //student.cpp #include student.h std :: string Student::getName (){ return name ; } void Student::setName (){ this -> name = name ; } int Student::getAge (){ return age ; } void Student::setAge ( int age ){ if ( age >= 0 ) { this -> age = age ; } else error ( \"Age cannot be negative!\" ); } Function definitions with namespaces! namespace_name::name in a function prototype means \u201cthis is the implementation for an interface function in namespace_name \u201d Inside the {...} the private member variables for namespace_name will be in scope! std::string Student::getName(){...} The this keyword! Here, we mean \u201cset the Student private member variable name equal to the parameter name \u201d void Student::setName (){ name = name ; } this->element_name means \u201cthe item in this Student object with name element_name\u201d. Use this for naming conflicts! void Student::setName ( string name ){ this -> name = name ; //better! } Constructors and Destructors \u00b6 constructors: Define how the member variables of an object is initialized What gets called when you first create a Student object Overloadable! destructors: deleteing (almost) always happens in the destructor of a class! The destructor is defined using Class_name::~Class_name() No one ever explicitly calls it! Its called when Class_name object go out of scope! Just like all member functions, declare it in the .h and implement in the .cpp! \u6784\u9020\u51fd\u6570\u5c31\u662f\u4e00\u4e2a\u4e0e\u7c7b\u540d\u76f8\u540c\u7684\u51fd\u6570\uff0c\u5728\u751f\u6210\u8fd9\u4e2a\u7c7b\u7684\u65f6\u5019\u5c31\u4f1a\u88ab\u8c03\u7528\uff0c\u7528\u6765\u521d\u59cb\u5316\u8fd9\u4e2a\u7c7b\u3002 \u4e0e\u6784\u9020\u51fd\u6570\u76f8\u5bf9\u7684\u662f\u6790\u6784\u51fd\u6570\uff0c\u5728\u5173\u95ed\u6587\u4ef6\u3001\u91ca\u653e\u5185\u5b58\u524d\u91ca\u653e\u8d44\u6e90\uff0c\u540d\u79f0\u662f\u7c7b\u540d\u524d\u52a0\u4e00\u4e2a ~ #include <iostream> class Entity { public : float X , Y ; Entity () { std :: cout << \"Entity is constructed!\" << std :: endl ; } ~ Entity () { std :: cout << \"Entity is destructed!\" << std :: endl ; } }; void Function () { Entity e ; } int main () { Function (); std :: cin . get (); } Public and Private Sections \u00b6 Class: A programmerdefined custom type. An abstraction of an object or data type. //student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; Public section: Users of the Student object can directly access anything here! Defines interface for interacting with the private member variables! Private section: Usually contains all member variables Users can\u2019t access or modify anything in the private section One last thing\u2026 Arrays \u00b6 //int * is the type of an int array variable int * my_int_array ; //my_int_array is a pointer! //this is how you initialize an array my_int_array = new int [ 10 ]; //this is how you index into an array int one_element = my_int_array [ 0 ]; //Arrays are memory WE allocate, so we need to give instructions for when to deallocate that memory! //When we are done using our array, we need to delete [] it! delete [] my_int_array ; Lec8 Template Classes and Const Correctness \u00b6 Template Classes \u00b6 Fundamental Theorem of Software Engineering: Any problem can be solved by adding enough layers of indirection. The problem with IntVector Vectors should be able to contain any data type! Solution? Create StringVector, DoubleVector, BoolVector etc.. What if we want to make a vector of struct Students? How are we supposed to know about every custom class? What if we don\u2019t want to write a class for every type we can think of? SOLUTION: Template classes! Template Class: A class that is parametrized over some number of types. A class that is comprised of member variables of a general type/types. Template Classes You\u2019ve Used Vectors/Maps/Sets... Pretty much all containers! template < class T > T add ( const T & left , const T & right ){ return left + right ; } //\u9690\u5f0f\u5b9e\u4f8b\u5316 int main (){ int a1 = 10 ; double b1 = 10.0 ; //add(a1,b1); add ( a1 ,( int ) b1 ); //\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362 return 0 ; } //\u663e\u5f0f\u5b9e\u4f8b\u5316 int main (){ int a = 10 ; double b = 10.0 ; add < int > ( a , b ); return 0 ; } Writing a Template Class: Syntax //mypair.h template < typename First , typename Second > class MyPair { public : First getFirst (); Second getSecond (); void setFirst ( First f ); void setSecond ( Second f ); private : First first ; Second second ; }; //mypair.cpp #include \u201cmypair.h\u201d //\u5982\u679c\u6ca1\u6709\u4e0b\u9762\u8fd9\u53e5\u8bdd\u4f1aCompile error! Must announce every member function is templated template < typename First , typename Second > First MyPair :: getFirst (){ return first ; } template < typename Second , typename First > Second MyPair :: getSecond (){ return second ; } Member Types Sometimes, we need a name for a type that is dependent on our template types iterator is a member type of vector std :: vector a = { 1 , 2 }; std :: vector :: iterator it = a . begin (); Summary: Used to make sure your clients have a standardized way to access important types. Lives in your namespace: vector<T>::iterator . After class specifier, you can use the alias directly (e.g. inside function arguments, inside function body). Before class specifier, use typename. // main.cpp #include \u201cvector.h\u201d vector < int > a ; a . at ( 5 ); // vector.h #include \u201cvector.h\u201d //\u6ce8\u610f\u662f\u5728.h\u6587\u4ef6\u4e2d\u5f15\u5165verctor.h\uff0c\u800c\u4e0d\u662f\u5728verctor.cpp\u4e2d\u5f15\u5165!!! template < typename T > class vector < T > { T at ( int i ); }; // vector.cpp template < typename T > void vector < T >:: at ( int i ) { // oops } \u200b Templates don\u2019t emit code until instantiated , so include the .cpp in the .h instead of the other way around! Const Correctness \u00b6 const: keyword indicating a variable, function or parameter can\u2019t be modified const indicates a variable can\u2019t be modified! std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference vec . push_back ( 4 ); // OKAY c_vec . push_back ( 9 ); // BAD - const ref . push_back ( 5 ); // OKAY c_ref . push_back ( 6 ); // BAD - const Can\u2019t declare non-const reference to const variable! const std :: vector < int > c_vec { 7 , 8 }; // a const variable // fixed const std :: vector < int >& bad_ref = c_vec ; // BAD - Can't declare a non-const reference as equal // to a const reference! std :: vector < int >& ref = c_ref ; const & subtleties with auto std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference Why const? // Find the typo in this code void f ( const int x , const int y ) { if (( x == 2 && y == 3 ) || ( x == 1 )) cout << 'a' << endl ; if (( y == x -1 ) && ( x == -1 || y = -1 )) //\u8f7b\u677e\u53d1\u73b0\u8fd9\u91cc\u7684y==-1\u5199\u9519\u4e86 cout << 'b' << endl ; if (( x == 3 ) && ( y == 2 * x )) cout << 'c' << endl ; } // Overly ambitious functions in application code long int countPopulation ( const Planet & p ) { // Hats are the cornerstone of modern society addLittleHat ( p ); //compile error // Guaranteed no more population growth, all future calls will be faster sterilize ( p ); //compile error // Optimization: destroy planet // This makes population counting very fast deathStar ( p ); //compile error return 0 ; } //How does the algorithm above work? long int countPopulation ( const Planet & p ) { addLittleHat ( p ); //p is a const reference here ... } void addLittleHat ( Planet & p ) { //p is a (non const) reference here p . add ( something ); } //So it will become compile error Calling addLittleHat on p is like setting a non const variable equal to a const one, it\u2019s not allowed! Const and Classes //student.cpp #include student.h std :: string Student::getName (){ return name ; //we can access name here! } void Student::setName ( string name ){ this -> name = name ; //resolved! } int Student::getAge (){ return age ; } void Student::setAge ( int age ){ //We can define what \u201cage\u201d means! if ( age >= 0 ){ this -> age = age ; } else error ( \"Age cannot be negative!\" ); } //student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; Using a const Student: //main.cpp std :: string stringify ( const Student & s ){ return s . getName () + \" is \" + std :: to_string ( s . getAge ) + \" years old.\" ; } //compile error! The compiler doesn\u2019t know getName and getAge don\u2019t modify s! We need to promise that it doesn\u2019t by defining them as const functions Add const to the end of function signatures! So, we make Student const-correct: //student.cpp #include student.h std :: string Student::getName () const { //there return name ; } void Student::setName ( string name ){ this -> name = name ; } int Student::getAge () const { //there return age ; } void Student::setAge ( int age ){ if ( age >= 0 ){ this -> age = age ; } else error ( \"Age cannot be negative!\" ); } //student.h class Student { public : std :: string getName () const ; //there void setName ( string name ); int getAge const (); //there void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; const-interface: All member functions marked const in a class definition. Objects of type const ClassName may only use the const-interface. Making RealVector\u2018s const-interface: class StrVector { public : using iterator = std :: string * ; const size_t kInitialSize = 2 ; /*...*/ size_t size () const ; bool empty () const ; std :: string & at ( size_t indx ); void insert ( size_t pos , const std :: string & elem ); void push_back ( const std :: string & elem ); iterator begin (); iterator end (); /*...*/ } Should begin() and end() be const? Answer : \u867d\u7136\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u662fconst\u7684\uff0c\u4f46\u662f\u5b83\u4eec\u7ed9\u6211\u4eec\u8fd4\u56de\u4e86\u4e00\u4e2a\u53ef\u4ee5\u53d8\u5316\u7684iterator\uff0c\u6240\u4ee5\u4f1a\u62a5\u9519\uff01 Solution : cbegin() and cend() class StrVector { public : using iterator = std :: string * ; using const_ iterator = const std :: string * ; /*...*/ size_t size () const ; bool empty () const ; /*...*/ void push_back ( const std :: string & elem ); iterator begin (); iterator end (); const_iterator begin () const ; const_iterator end () const ; /*...*/ } void printVec ( const RealVector & vec ){ cout << \"{ \" ; for ( auto it = vec . cbegin (); it != vec . cend (); ++ it ){ cout << * it << cout ; } cout << \" }\" << cout ; } //Fixed! And now we can\u2019t set *it equal to something: it will be a compile error! const iterator vs const_iterator: Nitty Gritty using iterator = std :: string * ; using const_iterator = const std :: string * ; const iterator it_c = vec . begin (); //string * const, const ptr to non-const obj * it_c = \"hi\" ; //OK! it_c is a const pointer to non-const object it_c ++ ; //not ok! cant change where a const pointer points! const_iterator c_it = vec . cbegin (); //const string*, a non-const ptr to const obj c_it ++ ; // totally ok! The pointer itself is non-const * c_it = \"hi\" // not ok! Can\u2019t change underlying const object cout << * c_it << endl ; //allowed! Can always read a const object, just can't change //const string * const, const ptr to const obj const const_iterator c_it_c = vec . cbegin (); cout << c_it_c << \" points to \" << * c_it_c << endl ; //only reads are allowed! Recap \u00b6 Template classes \u00b6 Add template<typename T1, typename T2 ...> before class definition in .h Add template<typename T1, typename T2 ...> before all function signature in .cpp When returning nested types (like iterator types), put template<typename T1, typename T2 ...>::member_type as return type, not just member_type Templates don\u2019t emit code until instantiated, so #include the .cpp file in the .h file, not the other way around Const and Const-correctness \u00b6 Use const parameters and variables wherever you can in application code Every member function of a class that doesn\u2019t change its member variables should be marked const auto will drop all const and &, so be sure to specify Make iterators and const_iterators for all your classes! const iterator = cannot increment the iterator, can dereference and change underlying value const_iterator = can increment the iterator, cannot dereference and change underlying value const const_iterator = cannot increment iterator, cannot dereference and change underlying value Lec9 Template Functions \u00b6 Generic Programming \u00b6 Generic C++ \u00b6 Allow data types to be parameterized (C++ entities that work on any datatypes) Template classes achieve generic classes How can we write methods that work on any data type? Function to get the min of two ints \u00b6 int myMin ( int a , int b ) { return a < b ? a : b ; } int main () { auto min_int = myMin ( 1 , 2 ); // 1 auto min_name = myMin ( \"Sathya\" , \"Frankie\" ); // error! One solution: overloaded functions int myMin ( int a , int b ) { return a < b ? a : b ; } // exactly the same except for types std :: string myMin ( std :: string a , std :: string b ) { return a < b ? a : b ; } int main () { auto min_int = myMin ( 1 , 2 ); // 1 auto min_name = myMin ( \"Sathya\" , \"Frankie\" ); // Frankie } But what about comparing other data types, like doubles, characters, and complex objects? Template functions \u00b6 Writing reusable, unique code with no duplication! //generic, \"template\" functions template < typename Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } //Here, \"class\" is an alternative keyword to typename. //They're 100% equivalent in template function declarations! template < class Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } //Default value for class template parameter template < typename Type = int > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } // int main() {} will be omitted from future examples // we'll instead show the code that'd go inside it cout << myMin < int > ( 3 , 4 ) << endl ; // 3 //let compiler deduce return type template < typename T , typename U > auto smarterMyMin ( T a , U b ) { return a < b ? a : b ; } cout << myMin ( 3.2 , 4 ) << endl ; // 3.2 Template type deduction - case 1 \u00b6 If the template function parameters are regular, pass-by-value parameters: Ignore the \"&\" After ignoring \"&\", ignore const too template < typename Type > Type addFive ( Type a ) { return a + 5 ; // only works for types that support \"+\" } int a = 5 ; addFive ( a ); // Type is int const int b = a ; addFive ( b ); // Type is still int const int & c = a ; addFive ( c ); // even now, Type is still int Template type deduction - case 2 \u00b6 If the template function parameters are references or pointers, this is how types (e.g. Type) are deduced: Ignore the \"&\" Match the type of parameters to inputted arguments Add on const after template < typename Type > void makeMin ( const Type & a , const Type & b , Type & minObj ) { //a and b are references to const values // set minObj to the min of a and b instead of returning. minObj = a < b ? a : b ; } const int a = 20 ; const int & b = 21 ; int c ; myMin ( a , b , c ); // Type is deduced to be int cout << c << endl ; // 20 behind the scenes Normal functions are created during compile time, and used in runtime Template functions are not compiled until used by the code template < typename Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } cout << myMin ( 3 , 4 ) << endl ; // 3 The compiler deduces the parameter types and generates a unique function specifically for each time the template function is called After compilation, the compiled code looks as if you had written each instantiated version of the function yourself Template Metaprogramming \u00b6 Normal code runs during run time. TMP -> run code during compile time make compiled code packages smaller speed up code when it's actually running template < unsigned n > struct Factorial { enum { value = n * Factorial < n - 1 >:: value }; }; template <> // template class \"specialization\" struct Factorial < 0 > { enum { value = 1 }; }; std :: cout << Factorial < 10 >:: value << endl ; // prints 3628800, but run during compile time! How can TMP actually be used? \u00b6 TMP was actually discovered (not invented, discovered) recently! Where can TMP be applied Ensuring dimensional unit correctness Optimizing matrix operations Generating custom design pattern implementation policy-based design (templates generating their own templates) Why write generic functions? \u00b6 Count the # of times 3 appears in a std :: vector < int > . Count the # of times \"Y\" appears in a std :: istream . Count the # of times 5 appears in the second half of a std :: deque < int > . Count the # of times \"X\" appear in the second half of a std :: string . //By using generic functions, we can solve each of these problems with a single function! Counting Occurrences //Attempt 1 //count strings int count_occurrences ( std :: vector < std :: string > vec , std :: string target ){ int count = 0 ; for ( size_t i = 0 ; i < vec . size (); ++ i ){ if ( vec [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //Attempt 2 //generalize this beyond just strings template < typename DataType > int count_occurrences ( const std :: vector < DataType > vec , DataType target ){ int count = 0 ; for ( size_t i = 0 ; i < vec . size (); ++ i ){ if ( vec [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //Attempt 3 //generalize this beyond just vectors template < typename Collection , typename DataType > int count_occurrences ( const Collection & arr , DataType target ){ int count = 0 ; for ( size_t i = 0 ; i < arr . size (); ++ i ){ if ( arr [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //The collection may not be indexable! //Attempt 4 //Solve the problem in Attempt 3 template < typename InputIt , typename DataType > int count_occurrences ( InputIt begin , InputIt end , DataType target ){ int count = 0 ; for ( initialization ; end - condition ; increment ){ if ( element access == target ) count ++ ; } return count ; } vector < std :: string > lands = { \"Xadia\" , \"Drakewood\" , \"Innean\" }; Usage : count_occurrences ( lands . begin (), lands . end (), \"Xadia\" ); //We manually pass in begin and end so that we can customize our search bounds. Lec10 Functions and Lambdas \u00b6 Review of template functions \u00b6 template < typename InputIt , typename DataType > int count_occurrences ( InputIt begin , InputIt end , DataType val ) { int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( * iter == val ) count ++ ; } return count ; } Usage : std :: string str = \"Xadia\" ; count_occurrences ( str . begin (), str . end (), 'a' ); Could we reuse this to find how many vowels are in \u201dXadia\u201d, or how many odd numbers were in a std::vector? Function Pointers and Lambdas \u00b6 Predicate Functions \u00b6 Any function that returns a boolean is a predicate! //Unary Predicate bool isLowercaseA ( char c ) { return c == 'a' ; } bool isVowel ( char c ) { std :: string vowels = \"aeiou\" ; return vowels . find ( c ) != std :: string :: npos ; } //Binary Predicate bool isMoreThan ( int num , int limit ) { return num > limit ; } bool isDivisibleBy ( int a , int b ) { return ( a % b == 0 ); } Function Pointers for generalization \u00b6 template < typename InputIt , typename UnaryPred > //no typename DataType int count_occurrences ( InputIt begin , InputIt end , UnaryPred pred ) { //add UnaryPred pred int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( pred ( * iter )) count ++ ; //no *iter == val } return count ; } bool isVowel ( char c ) { std :: string vowels = \"aeiou\" ; return vowels . find ( c ) != std :: string :: npos ; } Usage : std :: string str = \"Xadia\" ; count_occurrences ( str . begin (), str . end (), isVowel ); isVowel is a pointer, just like Node * or char * ! It\u2019s called a \u201cfunction pointer\u201d, and can be treated like a variable. Function pointers don\u2019t generalize well. Lambdas \u00b6 auto var = [ capture - clause ] ( auto param ) -> bool { ... }; //Capture Clause: Outside variables your function uses //Parameters: You can use auto in lambda parameters! capture clause [] // captures nothing [ limit ] // captures lower by value [ & limit ] // captures lower by reference [ & limit , upper ] // captures lower by reference, higher by value [ & , limit ] // captures everything except lower by reference [ & ] // captures everything by reference [ = ] // captures everything by value auto printNum = [] ( int n ) { std :: cout << n << std :: endl ; }; printNum ( 5 ); // 5 int limit = 5 ; auto isMoreThan = [ limit ] ( int n ) { return n > limit ; }; isMoreThan ( 6 ); // true limit = 7 ; isMoreThan ( 6 ); int upper = 10 ; auto setUpper = [ & upper ] () { upper = 6 ; }; Solution template < typename InputIt , typename UniPred > int count_occurrences ( InputIt begin , InputIt end , UniPred pred ) { int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( pred ( * iter )) count ++ ; } return count ; } Usage : int limit = 5 ; auto isMoreThan = [ limit ] ( int n ) { return n > limit ; }; std :: vector < int > nums = { 3 , 5 , 6 , 7 , 9 , 13 }; count_occurrences ( nums . begin (), nums . end (), isMoreThan ); what really are they Lambdas are cheap, but copying them may not be. Use lambdas when you need a short function, or one with read/write access to local variables Use function pointers for longer logic and for overloading We use \u201cauto\u201d because type is figured out in compile time Functors and Closures \u00b6 class functor { public : int operator () ( int arg ) const { // parameters and function body return num + arg ; } private : int num ; // capture clause }; int num = 0 ; auto lambda = [ & num ] ( int arg ) { num += arg ; }; lambda ( 5 ); A functor is any class that provides an implementation of operator(). Lambdas are essentially syntactic sugar for creating a functor. If lambdas are functor classes, then \u201cclosures\u201d are instances of those classes. At runtime, closures are generated as instances of lambda classes. How do functors, lambdas, and function pointers relate? Answer: standard function, std::function<\u2026>, is the one to rule them all \u2014 it\u2019s the overarching type for anything callable in C++. Functors, lambdas, and function pointers can all be casted to standard functions void functionPointer ( int arg ) { int num = 0 ; num += arg ; } // or int num = 0 ; auto lambda = [ & num ] ( int arg ) { num += arg ; }; lambda ( 5 ); // num = 5; std :: function < void ( int ) > func = lambda ; We could cast either functionPointer or lambda to func, as both of them have a void return signature and take in one integer parameter. Introducing STL Algorithms \u00b6 A collection of completely generic functions written by C++ devs #include <algorithm> : sort \u00b7 reverse \u00b7 min_element \u00b7 max_element \u00b7 binary_search \u00b7 stable_partition \u00b7 find \u00b7 find_if \u00b7 count_if \u00b7 copy \u00b7 transform \u00b7 insert \u00b7 for_each \u00b7 etc.! Lec11 Operator Overloading \u00b6 Redefining what operators mean Function Overloading \u00b6 Allow for calling the same function with different parameters: int sum ( int a , int b ) { return a + b ; } double sum ( double a , double b ) { return a + b ; } // usage: cout << sum ( 1.5 , 2.4 ) << endl ; cout << sum ( 10 , 20 ) << endl ; Operator Overloading \u00b6 \\+ - * / % ^ & | ~ ! , = < > <= >= ++ -- << >> == != && || += -= *= /= %= ^= &= |= <<= >>= [] () -> ->* new new[] delete delete[] if ( before ( a , b )) { // a, b defined earlier cout << \"Time a is before Time b\" << endl ; } //Overloading if ( a < b ) { cout << \"Time a is before Time b\" << endl ; } Two ways to overload operators \u00b6 Member Functions \u00b6 Add a function called operator __ to your class: class Time { bool operator < ( const Time & rhs ) const ; //rhs = Right Hand Side bool operator + ( const Time & rhs ) const ; bool operator ! () const ; // unary, no arguments } //lhs (left hand side) of each operator is this. Call the function on the left hand side of the expression (this) Binary operators (5 + 2, \"a\" < \"b\"): accept the right hand side (& rhs) as an argument(\u53c2\u6570). Unary operators (~a, !b): don't take any arguments class Time { bool operator < ( const Time & rhs ) { if ( hours < rhs . hours ) return true ; if ( rhs . hours < hours ) return false ; // compare minutes, seconds... } } Time a , b ; if ( a . operator < ( b )) { // do something; } Operators can only be called on the left hand side What if we can't control what's on the left hand side of the operation? e.g. if we want to compare a double and a Fraction Non-Member Functions \u00b6 Add a function called operator __ outside of your class: bool operator < ( const Time & lhs , const Time & rhs ); Time operator + ( const Time & lhs , const Time & rhs ); Time & operator += ( const Time & lhs , const Time & rhs ); Time operator ! ( const Time & lhs , const Time & rhs ); Instead of taking only rhs, it takes both the left hand side and right hand side! The STL prefers using non-member functions for operator overloading: allows the LHS to be a non-class type (e.g. double < Fraction) allows us to overload operations with a LHS class that we don't own You may be wondering how non-member functions can access private member variables: The answer : friends! class Time { // core member functions omitted for brevity public : friend bool operator == ( const Time & lhs , const Time & rhs ); private : int hours , minutes , seconds ; } bool operator == ( const Time & lhs , const Time & rhs ) { return lhs . hours == rhs . hours && lhs . minutes == rhs . minutes && lhs . seconds == rhs . seconds ; } << Operator Overloading \u00b6 We can use << to output something to an std::ostream&: std :: ostream & operator << ( std :: ostream & out , const Time & time ) { out << time . hours << \":\" << time . minutes << \":\" << time . seconds ; // 1) print data to ostream return out ; // 2) return original ostream } // in time.h -- friend declaration allows access to private attrs public : friend std :: ostream & operator << ( std :: ostream & out , const Time & time ); // now we can do this! cout << t << endl ; // 5:22:31 This is how std::cout mixes types (and still works)! //Since these two methods are implemented in the STL std :: ostream & operator << ( std :: ostream & out , const std :: string & s ); std :: ostream & operator << ( std :: ostream & out , const int & i ); //then cout << \"test\" << 5 ; // (cout << \"test\") << 5; //then operator << ( operator << ( cout , \"test\" ), 5 ); //then operator << ( cout , 5 ); //then cout ; Don't overuse operator overloading! //Confusing MyString a ( \"opossum\" ); MyString b ( \"quokka\" ); MyString c = a * b ; // what does this even mean?? //Great! MyString a ( \"opossum\" ); MyString b ( \"quokka\" ); MyString c = a . charsInCommon ( b ); // much better! Rules of Operator Overloading \u00b6 Meaning should be obvious when you see it Should be reasonably similar to corresponding arithmetic operations Don't define + to mean set subtraction! When the meaning isn't obvious, give it a normal name instead Lec12 Special Member Function \u00b6 Special Member Functions (SMFs) \u00b6 These functions are generated only when they're called (and before any are explicitly defined by you): Default Constructor Copy Constructor Copy Assignment Operator Destructor Move Constructor Move Assignment Operator class Widget { public : Widget (); // default constructor Widget ( const Widget & w ); // copy constructor Widget & operator = ( const Widget & w ); // copy assignment operator ~ Widget (); // destructor Widget ( Widget && rhs ); // move constructor Widget & operator = ( Widget && rhs ); // move assignment operator } Default Constructor object is created with no parameters constructor also has no parameters all SMFs are public and inline function, meaning that wherever it's used is replaced with the generated code in the function Copy Constructor another type of constructor that creates an instance of a class constructs a member-wise copy of an object (deep copy) Copy Assignment Operator very similar to copy constructor, except called when trying to set one object equal to another e.g. w1 = w2; Destructor called whenever object goes out of scope can be used for deallocating member variables and avoiding memory leaks Move Constructor Move Assignment Operator //Examples: using std :: vector ; vector < int > func ( vector < int > vec0 ) { vector < int > vec1 ; //Default constructor creates empty vector vector < int > vec2 ( 3 ); //Not a SMF - calls a constructor with parameters\u2192{0,0,0} vector < int > vec3 { 3 }; //Also not a SMF, uses initializer_list vector < int > vec4 (); //A function declaration! (C++'s most vexing parse) vector < int > vec5 ( vec2 }; //Copy constructor - vector created as copy of another vector < int > vec {}; //Also the default constructor vector < int > vec { vec3 + vec4 }; //Copy constructor vector < int > vec8 = vec4 ; //Copy constructor - vec8 is newly constructor vec8 = vec2 ; //Copy assignment - vec8 is an existing object return vec8 ; //Copy constructor: copies vec8 to location outside of func } //Destructors on all values (except return value) are called Copy Constructors and Copy Assignment Operators \u00b6 initializer lists \u00b6 template < typename T > vector < T >:: vector < T > () { //members are first default constructed (declared to be their default values) _size = 0 ; _capacity = kInitialSize ; _elems = new T [ kInitialSize ]; //Then each member is reassigned. This seems wasteful! } //The technique below is called an initializer list template < typename T > vector < T >:: vector < T > () : //Directly construct each member with a starting value _size ( 0 ), _capacity ( kInitialSize ), _elems ( new T [ kInitialSize ]) { } Prefer to use member initializer lists, which directly constructs each member with a given value Faster! Why construct, and then immediately reassign? What if members are a non-assignable type (you'll see by the end of lecture how this can be possible!) Important clarification: you can use member initializer lists for ANY constructor, even if it has parameters (and thus isn't an SMF) Why aren't the default SMFs always sufficient? \u00b6 The default compiler-generated copy constructor and copy assignment operator functions work by manually copying each member variable! Moral of the story: in many cases, copying is not as simple as copying each member variable! //the default copy constructor template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( other . _elems ) { } //We can create a new array template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( other . _elems ) { _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //Even better: let's move this to the initializer list template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( new T [ other . _capacity ]) { //We can move our reassignment of _elems up! std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //the default copy assignment operator template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { _size = other . _size ; _capacity = other . _capacity ; _elems = other . _elems ; return * this ; } //Attempt 1: Allocate a new array and copy over elements template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { _size = other . _size ; _capacity = other . _capacity ; _elems = new T [ other . _capacity ]; //We've lost access to the old value of _elems, and leaked the array that it pointed to! std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //Attempt 2: Deallocate the old array and make a new one template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { if ( & other == this ) return * this ; //Also, be careful about self-reassignment! _size = other . _size ; _capacity = other . _capacity ; delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; //Remember to return a reference to the vector itself } Copy operations must perform these tasks: Copy constructor Use initializer list to copy members where simple copying does the correct thing. int, other objects, etc Manually copy all members otherwise pointers to heap memory non-copyable things Copy assignment Clean up any resources in the existing object about to be overwritten Copy members using direct assignment when assignment works Manually copy members where assignment does not work You don't have to do these in this order Summary: Steps to follow for an assignment operator Check for self-assignment. Make sure to free existing members if applicable. Copy assign each automatically assignable member. Manually copy all other members. Return a reference to *this (that was just reassigned). = delete and = default \u00b6 //Explicitly delete the copy member functions //Adding = delete; after a function prototype tells C++ to not generate the corresponding SMF class PasswordManager { public : PasswordManager (); PasswordManager ( const PasswordManager & pm ); ~ PasswordManager (); // other methods ... PasswordManager ( const PasswordManager & rhs ) = delete ; PasswordManager & operator = ( const PasswordManager & rhs ) = delete ; private : // other important members ... } //Is there a way to keep, say, the default copy constructor if you write another constructor? //Adding = default; after a function prototype tells C++ to still generate the default SMF, even if you're defining other SMFs class PasswordManager { public : PasswordManager (); PasswordManager ( const PasswordManager & pm ) = default ; ~ PasswordManager (); // other methods ... PasswordManager ( const PasswordManager & rhs ) = delete ; PasswordManager & operator = ( const PasswordManager & rhs ) = delete ; private : // other important members ... } Rule of 0 and Rule of 3 \u00b6 Rule of 0 \u00b6 If the default operations work, then don't define your own! When should you define your own SMFs When the default ones generated by the compiler won't work Most common reason: there's a resource that our class uses that's not stored inside of our class e.g. dynamically allocated memory our class only stores the pointers to arrays, not the arrays in memory itself Rule of 3 (C++ 98) \u00b6 If you explicitly define a copy constructor, copy assignment operator, or destructor, you should define all three What's the rationale? If you're explicitly writing your own copy operation, you're controlling certain resources manually You should then manage the creation, use, and releasing of those resources! Recap of Special Member Functions (SMFs) Default Constructor Object created with no parameters, no member variables instantiated Copy Constructor Object created as a copy of existing object (member variable-wise) Copy Assignment Operator Existing object replaced as a copy of another existing object. Destructor Object destroyed when it is out of scope. Are these 4 enough? class StringTable { public : StringTable () {} StringTable ( const StringTable & st ) {} // functions for insertion, erasure, lookup, etc., // but no move/dtor functionality // ... private : std :: map < int , std :: string > values ; } Move constructors and move assignment operators \u00b6 Move Operations (C++11) \u00b6 These functions are generated only when they're called (and before any are explicitly defined by you) //Allow for moving objects and std::move operations (rvalue refs) class Widget { public : Widget (); // default constructor Widget ( const Widget & w ); // copy constructor Widget & operator = ( const Widget & w ); // copy assignment operator ~ Widget (); // destructor Widget ( Widget && rhs ); // move constructor Widget & operator = ( Widget && rhs ); // move assignment operator } Move constructors and move assignment operators will perform \"memberwise moves\" Defining a copy constructor does not affect generation of a default copy assignment operator, and vice versa Defining a move assignment operator prevents generation of a move copy constructor, and vice versa Rationale: if the move assignment operator needs to be re-implemented, there'd likely be a problem with the move constructor Some nuances to move operation SMFs \u00b6 Move operations are generated for classes only if these things are true: No copy operations are declared in the class No move operations are declared in the class No destructor is declared in the class Can get around all of these by using default: Widget ( Widget && ) = default ; Widget & operator = ( Widget && ) = default ; // support moving Widget ( const Widget & ) = default ; Widget & operator = ( const Widget & ) = default ; // support copying Lec13 Move Semantics in C++ \u00b6 l-values live until the end of the scope r-values live until the end of the line //Find the r-values! (Only consider the items on the right of = signs) int x = 3 ; //3 is an r-value int * ptr = 0x02248837 ; //0x02248837 is an r-value vector < int > v1 { 1 , 2 , 3 }; //{1, 2, 3} is an r-value,v1 is an l-value auto v4 = v1 + v2 ; //v1 + v2 is an r-value size_t size = v . size (); //v.size()is an r-value v1 [ 1 ] = 4 * i ; //4*i is an r-value, v1[1] is an l-value ptr = & x ; //&x is an r-value v1 [ 2 ] = * ptr ; //*ptr is an l-value MyClass obj ; //obj is an l-value x = obj . public_member_variable ; //obj.public_member_variable is l-value How many arrays will be allocated, copied and destroyed here? \u00b6 int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); // //make_me_a_vec(123) is an r-value } vector < int > make_me_a_vec ( int num ) { vector < int > res ; while ( num != 0 ) { res . push_back ( num % 10 ); num /= 10 ; } return res ; } vec is created using the default constructor make_me_a_vec creates a vector using the default constructor and returns it vec is reassigned to a copy of that return value using copy assignment copy assignment creates a new array and copies the contents of the old one The original return value\u2019s lifetime ends and it calls its destructor vec\u2019s lifetime ends and it calls its destructor How do we know when to use move assignment and when to use copy assignment? \u00b6 Answer : When the item on the right of the = is an r-value we should use move assignment Why? r-values are always about to die, so we can steal their resources //Examples //Using move assignment int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); } //Using copy assignment int main () { vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = vec1 ; vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } //and vec2 never saw a thing the r-value reference \u00b6 How to make two different assignment operators? Overload vector::operator= ! How? Introducing\u2026 the r-value reference && (This is different from the l-value reference & you have see before) (it has one more ampersand) Overloading with && int main () { int x = 1 ; change ( x ); //this will call version 2 change ( 7 ); //this will call version 1 } void change ( int && num ){...} //version 1 takes r-values void change ( int & num ){...} //version 2 takes l-values //num is a reference to vec Copy assignment and Move assignment \u00b6 //Copy assignment vector < T >& operator = ( const vector < T >& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //must copy entire array delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; } //Move assignment vector < T >& operator = ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //we can steal the array delete [] _elems ; _elems = other . _elems return * this ; } //This works int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); //this will use move assignment vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = vec1 ; //this will use copy assignment vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } The compiler will pick which vector::operator= to use based on whether the RHS is an l-value or an r-value Can we make it even better? \u00b6 In the move assignment above, these are also making copies (using int/ptr copy assignment) _size = other . _size ; _capacity = other . _capacity ; _elems = other . _elems ; We can force move assignment rather than copy assignment of these ints by using std::move vector < T >& operator = ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = std :: move ( other . _size ); _capacity = std :: move ( other . _capacity ); //we can steal the array delete [] _elems ; _elems = std :: move ( other . _elems ); return * this ; } The compiler will pick which vector::operator= to use based on whether the RHS is an l-value or an r-value Constructor \u00b6 //How about this int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); //this will use move assignment vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } //this should use move vector < string > vec2 = vec1 ; //this will use copy construction vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } //copy constructor vector < T > ( const vector < T >& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //must copy entire array delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; } //move constructor vector < T > ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = std :: move ( other . _size ); _capacity = std :: move ( other . _capacity ); //we can steal the array delete [] _elems ; _elems = std :: move ( other . _elems ); return * this ; } Where else should we use std::move? Answer : Wherever we take in a const & parameter in a class member function and assign it to something else in our function Don\u2019t use std::move outside of class definitions, never use it in application code! vector::push_back \u00b6 //Copy push_back void push_back ( const T & element ) { elems [ _size ++ ] = element ; //this is copy assignment } //Move push_back void push_back ( T && element ) { elems [ _size ++ ] = std :: move ( element ); //this forces T\u2019s move assignment } Be careful with std::move \u00b6 int main () { vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = std :: move ( vec1 ); vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) //wrong!!! } After a variable is moved via std::move, it should never be used until it is reassigned to a new variable! The C++ compiler might warn you about this mistake, but the code above compiles! TLDR: Move Semantics \u00b6 If your class has copy constructor and copy assignment defined, you should also define a move constructor and move assignment Define these by overloading your copy constructor and assignment to be defined for Type&& other as well as Type& other Use std::move to force the use of other types\u2019 move assignments and constructors All std::move(x) does is cast x as an rvalue Be wary of std::move(x) in main function code Bonus: std::move and RAII \u00b6 Recall: RAII means all resources required by an object are acquired in its constructor and destroyed in its destructor To be consistent with RAII, you should have no half-ready resources, such as a vector whose underlying array has been deallocated Is std::move consistent with RAII? I say NO! This is a sticky language design flaw, C++ has a lot of those! Lec14 Type Safety and std::optional \u00b6 Recap: Const-Correctness \u00b6 We pass big pieces of data by reference into helper functions by to avoid making copies of that data If this function accidentally or sneakily changes that piece of data, it can lead to hard to find bugs! Solution : mark those reference parameters const to guarantee they won\u2019t be changed in the function! How does the compiler know when it\u2019s safe to call member functions of const variables? \u00b6 const-interface: All member functions marked const in a class definition. Objects of type const ClassName may only use the const-interface. RealVector\u2019s const-interface template < class ValueType > class RealVector { public : using iterator = ValueType * ; using const_ iterator = const ValueType * ; /*...*/ size_t size () const ; bool empty () const ; /*...*/ void push_back ( const ValueType & elem ); iterator begin (); iterator end (); const_iterator cbegin () const ; const_iterator cend () const ; /*...*/ } Key Idea: Sometimes less functionality is better functionality Technically, adding a const-interface only limits what RealVector objects marked const can do Using types to enforce assumptions we make about function calls help us prevent programmer errors! Type Safety \u00b6 Type Safety: The extent to which a language prevents typing errors. guarantees the behavior of programs. What does this code do? void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back () % 2 == 1 ){ vec . pop_back (); } } //What happens when input is {} ? //One solution void removeOddsFromEnd ( vector < int >& vec ){ while ( ! vec . empty () && vec . back () % 2 == 1 ){ vec . pop_back (); } } //Key idea: it is the programmers job to enforce the precondition that vec be non-empty, otherwise we get undefined behavior! There may or may not be a \u201clast element\u201d in vec. How can vec.back() have deterministic behavior in either case? The problem valueType & vector < valueType >:: back (){ return * ( begin () + size () - 1 ); } //Dereferencing a pointer without verifying it points to real memory is undefined behavior! valueType & vector < valueType >:: back (){ if ( empty ()) throw std :: out_of_range ; return * ( begin () + size () - 1 ); } //Now, we will at least reliably error and stop the program or return the last element whenever back() is called Type Safety: The extent to which a function signature guarantees the behavior of a function . The problem //back() is promising to return something of type valueType when its possible no such value exists! valueType & vector < valueType >:: back (){ return * ( begin () + size () - 1 ); } //A first solution? std :: pair < bool , valueType &> vector < valueType >:: back (){ if ( empty ()){ return { false , valueType ()}; //valueType may not have a default constructor } return { true , * ( begin () + size () - 1 )}; } //Even if it does, calling constructors is expensive //So, what should back() return? ??? vector < valueType >:: back (){ if ( empty ()){ return ?? ; } return * ( begin () + size () - 1 ); } //Introducing std::optional std::optional \u00b6 What is std::optional<T> ? std::optional is a template class which will either contain a value of type T or contain nothing (expressed as nullopt ) void main (){ std :: optional < int > num1 = {}; //num1 does not have a value num1 = 1 ; //now it does! num1 = std :: nullopt ; //now it doesn't anymore } What if back() returned an optional? std :: optional < valueType > vector < valueType >:: back (){ if ( empty ()){ return {}; } return * ( begin () + size () - 1 ); } std::optional interface .value() returns the contained value or throws bad_optional_access error .value_or(valueType val) returns the contained value or default value, parameter val .has_value() returns true if contained value exists, false otherwise Checking if an optional has value std :: optional < Student > lookupStudent ( string name ){ //something} std :: optional < Student > output = lookupStudent ( \u201c Keith \u201d ); if ( student ){ cout << output . value (). name << \u201c is from \u201c << output . value (). state << endl ; } else { cout << \u201c No student found \u201d << endl ; } So we have perfect solutions void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back (). has_value () && vec . back (). value () % 2 == 1 ){ vec . pop_back (); } } //Below totally hacky, but totally works, but don't do this! void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back (). value_or ( 2 ) % 2 == 1 ){ vec . pop_back (); } } Recap: The problem with std::vector::back() Why is it so easy to accidentally call back() on empty vectors if the outcome is so dangerous? The function signature gives us a false promise! Promises to return an something of type valueType But in reality, there either may or may not be a \u201clast element\u201d in a vector std::optional \u201cmonadic\u201d interface (C++23 sneak peek!) .and_then(function f) returns the result of calling f(value) if contained value exists, otherwise null_opt (f must return optional) .transform(function f) returns the result of calling f(value) if contained value exists, otherwise null_opt (f must return optional) .or_else(function f) returns value if it exists, otherwise returns result of calling f Recall: Design Philosophy of C++ Only add features if they solve an actual problem Programmers should be free to choose their own style Compartmentalization is key Allow the programmer full control if they want it Don\u2019t sacrifice performance except as a last resort Enforce safety at compile time whenever possible Recap: Type Safety and std::optional \u00b6 You can guarantee the behavior of your programs by using a strict type system! std::optional is a tool that could make this happen: you can return either a value or nothing .has_value() .value_or() .value() This can be unwieldy and slow, so cpp doesn\u2019t use optionals in most stl data structures Many languages, however, do! The ball is in your court! \u201cWell typed programs cannot go wrong.\u201d Robert Milner (very important and good CS dude) Lec15 RAII, Smart Pointers, and C++ Project Building \u00b6 Exceptions - Why care? \u00b6 How many code paths are in this function? \u00b6 string get_name_and_print_sweet_tooth ( Person p ) { if ( p . favorite_food () == \"chocolate\" || p . favorite_drink () == \"milkshake\" ) { cout << p . first () << \" \" << p . last () << \" has a sweet tooth!\" << endl ; } return p . first () + \" \" + p . last (); } Code Path 1 - favors neither chocolate nor milkshakes Code Path 2 - favors milkshakes Code Path 3 - favors chocolate (and possibly milkshakes) Are there any more code paths? Hint: Exceptions \u00b6 Exceptions are ways to signal that something has gone wrong during run-time Exceptions are \"thrown\" and can crash the program, but can be \"caught\" to avoid this Hidden Code Paths \u00b6 There are (at least) 23 code paths in the code before! (1) copy constructor of Person parameter may throw (5) constructor of temp string may throw (6) call to favorite_food, favorite_drink, first (2), last (2), may throw (10) operators may be user-overloaded, thus may throw (1) copy constructor of string for return value may throw What could go wrong here? \u00b6 string get_name_and_print_sweet_tooth ( int id_number ) { Person * p = new Person ( id_number ); // assume the constructor fills in variables if ( p -> favorite_food () == \"chocolate\" || p -> favorite_drink () == \"milkshake\" ) { cout << p -> first () << \" \" << p -> last () << \" has a sweet tooth!\" << endl ; } auto result = p -> first () + \" \" + p -> last (); delete p ; //must release!!! return result ; } This problem isn't just unique to pointers \u00b6 Acquire Release Heap memory new delete Files open close Locks try_lock unlock Cockets socket close How do we guarantee resources get released, even if there are exceptions? RAII \u00b6 Resource Acquisition Is Initialization What is R\u00b7A\u00b7Double I? \u00b6 All resources used by a class should be acquired in the constructor All resources used by a class should be released in the destructor Why? Objects should be usable immediately after creation There should never be a \"half-valid\" state of an object, where it exists in memory but is not accessible to/used by the program The destructor is always called (when the object goes out of scope), so the resource is always freed Is it RAII Compliant? \u00b6 //The following three algorithms are not RALL void printFile () { ifstream input ; input . open ( \"hamlet.txt\" ); string line ; while ( getline ( input , line )) { // might throw exception cout << line << endl ; } input . close (); } void printFile () { ifstream input ( \"hamlet.txt\" ); string line ; while ( getline ( input , line )) { // might throw exception cout << line << endl ; } } void cleanDatabase ( mutex & databaseLock , map < int , int >& database ) { databaseLock . lock (); // other threads will not modify database // modify the database // if exception thrown, mutex never unlocked! databaseLock . unlock (); } This fixes it! void cleanDatabase ( mutex & databaseLock , map < int , int >& database ) { lock_guard < mutex > lg ( databaseLock ); // other threads will not modify database // modify the database // if exception thrown, mutex is unlocked! // no need to unlock at end, as it's handle by the lock_guard } class lock_guard { public : lock_guard ( mutex & lock ) : acquired_lock ( lock ){ acquired_lock . lock (); } ~ lock_guard () { acquired_lock . unlock (); } private : mutex & acquired_lock ; } What about RAII for memory? \u00b6 This is where we're going with RAII: from the C++ Core Guidelines: Avoid calling new and delete explicitly Smart Pointers \u00b6 RAII for memory We saw how this was not RAII-compliant because of the \"naked\" delete. string get_name_and_print_sweet_tooth ( int id_number ) { Person * p = new Person ( id_number ); //assume the constructor fills in variables if ( p -> favorite_food () == \"chocolate\" || p -> favorite_drink () == \"milkshake\" ) { cout << p -> first () << \" \" << p -> last () << \" has a sweet tooth!\" << endl ; } auto result = p -> first () + \" \" + p -> last (); delete p ; return result ; } Solution: built-in \"smart\" (RAII-safe) pointers \u00b6 Three types of smart pointers in C++ that automatically free underlying memory when destructed std::unique_ptr \u2022 Uniquely owns its resource, can't be copied std::shared_ptr \u2022 Can make copies, destructed when underlying memory goes out of scope std::weak_ptr \u2022 models temporary ownership: when an object only needs to be accessed if it exists (convert to shared_ptr to access) std::unique_ptr \u00b6 //Before void rawPtrFn () { Node * n = new Node ; // do things with n delete n ; } //After void rawPtrFn () { std :: unique_ptr < Node > n ( new Node ); // do things with n // automatically freed! } what if we wanted to have multiple pointers to the same object? std::shared_ptr std::shared_ptr \u00b6 Resources can be stored by any number of shared_ptrs The resource is deleted when none of the pointers points to the resource { std :: shared_ptr < int > p1 ( new int ); // use p1 { std :: shared_ptr < int > p2 = p1 ; // use p1 and p2 } // use p1, like so cout << * p1 . get () << endl ; } // the integer is now deallocated! Smart pointers: RAII Wrapper for pointers \u00b6 std :: unique_ptr < T > up { new T }; std :: unique_ptr < T > up = std :: make_unique < T > (); std :: shared_ptr < T > sp { new T }; std :: shared_ptr < T > sp = std :: make_shared < T > (); std :: weak_ptr < T > wp = sp ; //A weak_ptr is a container for a raw pointer. It is created as a copy of a shared_ptr. The existence or destruction of weak_ptr copies of a shared_ptr have no effect on the shared_ptr or its other copies. After all copies of a shared_ptr have been destroyed, all weak_ptr copies become empty. // can only be copy/move constructed (or empty)! //So which way is better? //Always use std::make_unique<T>()! std :: unique_ptr < T > up { new T }; std :: unique_ptr < T > up = std :: make_unique < T > (); std :: shared_ptr < T > sp { new T }; std :: shared_ptr < T > sp = std :: make_shared < T > (); If we don't use make_shared, then we're allocating memory twice (once for sp, and once for new T)! We should be consistent across smart pointers Building C++ Projects \u00b6 What happens when you run our \"./build_and_run.sh\"? What do make and Makefiles do? \u00b6 make is a \"build system\" uses g++ as its main engine several stages to the compiler system can be utilized through a Makefile! let's take a look at a simple makefile to get some practice! So why do we use cmake in our assignments? \u00b6 cmake is a cross-platform make cmake creates build systems! It takes in an even higher-level config file, ties in external libraries, and outputs a Makefile, which is then run. Let's take a look at our makefiles! Example cmake file (CMakeLists.txt) \u00b6 cmake_minimum_required ( VERSION 3 .0 ) # \u6307\u5b9a cmake \u6700\u4f4e\u7248\u672c project ( wikiracer ) # \u6307\u5b9a\u9879\u76ee\u540d\u79f0(\u968f\u610f) set ( CMAKE_CXX_STANDARD 17 ) set ( CMAKE_CXX_STANDARD_REQUIRED True ) find_package ( cpr CONFIG REQUIRED ) # adding all files add_executable ( main main.cpp wikiscraper.cpp.o error.cpp ) # \u6307\u5b9a\u7f16\u8bd1\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\uff0cmain\u662f\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8868\u793a\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6587\u4ef6\u540d\uff08\u8fd9\u4e2a\u6587\u4ef6\u540d\u4e5f\u662f\u4efb\u610f\u7684\uff09\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570main.cpp\u5219\u7528\u4e8e\u6307\u5b9a\u6e90\u6587\u4ef6\u3002 target_link_libraries ( main PRIVATE cpr ) Components of C++'s compilation system \u00b6 graph LR A[Preprocessing <br>in: cpp files out: full cpp files]-->B[Compiling <br>in: full cpp files out: .s files]-->C[Assembling <br>in: .s files out: .o files]-->D[Linking<br> in: .o files out: executable] Preprocessing (g++ -E) \u00b6 The C/C++ preprocessor handles preprocessor directives: replaces includes (#include \u2026) and and expands any macros (#define \u2026) Replace #includes with content of respective files (which is usually just function/variable declarations, so low bloat) Replaces macros (#define) and selecting different portions of text depending on #if, #ifdef, #ifndef Outputs a stream of tokens resulting from these transformations If you want, you can produce some errors at even this stage (#if, #error) Compilation (g++ -S) \u00b6 Performed on output of the preprocessor (full C++ code) Structure of a compiler: Lexical Analysis Parsing Semantic Analysis Optimization Code Generation (assembly code) This is where traditional \"compiler errors\" are caught Assembling (g++ -c) \u00b6 Runs on the assembly code as outputted by the compiler Converts assembly code to binary machine code Assumes that all functions are defined somewhere without checking Final output: object files Can't be run by themselves! Linking (ld, g++) \u00b6 Creates a single executable file from multiple object files Combine the pieces of a program Figure out a memory organization so that all the pieces can fit together Resolve references so that the program can run under the new memory organization .h files declare functions, but the actual functions may be in separate files from where they're called! Output is fully self-suficient\u2014no other files needed to run","title":"CS106L\u8bfe\u7a0b\u7b14\u8bb0"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec1-welcome-to-cs-106l","text":"","title":"Lec1 Welcome to CS 106L!"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#why-c-is-important","text":"","title":"Why C++ is important"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#what-is-c","text":"#include <iostream> int main () { std :: cout << \"Hello World!\" << std :: endl ; return 0 ; } #include \"stdio.h\" #include \"stdlib.h\" int main ( int argc , char * argv ) { asm ( \"sub $0x20,%rsp \\n\\t \" // assembly code! \"movabs $0x77202c6f6c6c6548,%rax \\n\\t \" \"mov %rax,(%rsp) \\n\\t \" \"movl $0x646c726f, 0x8(%rsp) \\n\\t \" \"movw $0x21, 0xc(%rsp) \\n\\t \" \"movb $0x0,0xd(%rsp) \\n\\t \" \"leaq (%rsp),%rax \\n\\t \" \"mov %rax,%rdi \\n\\t \" \"call __Z6myputsPc \\n\\t \" \"add $0x20, %rsp \\n\\t \" ); return EXIT_SUCCESS ; }","title":"What is C++"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec2-types-and-structs","text":"Types make things better...and sometimes harder...but still better","title":"Lec2 Types and Structs"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#types","text":"","title":"Types"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#fundamental-types","text":"int val = 5 ; //32 bits char ch = 'F' ; //8 bits (usually) float decimalVal1 = 5.0 ; //32 bits (usually) double decimalVal2 = 5.0 ; //64 bits (usually) bool bVal = true ; //1 bit #include <string> std :: string str = \"Frankie\" ; \u200b C++ is a statically typed language: everything with a name (variables, functions, etc) is given a type before runtime \u200b static typing helps us to prevent errors before our code runs","title":"Fundamental Types"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#static-types--function","text":"int add ( int a , int b ); int , int -> int string echo ( string phrase ); string -> string string helloworld (); void -> string double divide ( int a , int b ); int , int -> double","title":"Static Types + Function"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#overloading","text":"int half ( int x , int divisor = 2 ) { // (1) return x / divisor ; } double half ( double x ) { // (2) return x / 2 ; } half ( 3 ) // uses version (1), returns 1 half ( 3 , 3 ) // uses version (1), returns 1 half ( 3.0 ) // uses version (2), returns 1.5","title":"Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#intro-to-structs","text":"struct: a group of named variables each with their own type. A way to bundle different types together struct Student { string name ; // these are called fields string state ; // separate these by semicolons int age ; }; Student s ; s . name = \"Frankie\" ; s . state = \"MN\" ; s . age = 21 ; // use . to access fields void printStudentInfo ( Student student ) { cout << s . name << \" from \" << s . state ; cout << \" (\" << s . age \")\" << endl ; } Student randomStudentFrom ( std :: string state ) { Student s ; s . name = \"Frankie\" ; //random = always Frankie s . state = state ; s . age = std :: randint ( 0 , 100 ); return s ; } Student foundStudent = randomStudentFrom ( \"MN\" ); cout << foundStudent . name << endl ; // Frankie std::pair: An STL built-in struct with two fields of any type std :: pair < int , string > numSuffix = { 1 , \"st\" }; cout << numSuffix . first << numSuffix . second ; //prints 1st struct Pair { fill_in_type first ; fill_in_type second ; }; //pair in functions std :: pair < bool , Student > lookupStudent ( string name ) { Student blank ; if ( found ( name )) return std :: make_pair ( false , blank ); Student result = getStudentWithName ( name ); return std :: make_pair ( true , result ); } std :: pair < bool , Student > output = lookupStudent ( \u201c Keith \u201d ); auto: Keyword used in lieu of type when declaring a variable, tells the compiler to deduce the type. //It means that the type is deduced by the compiler. auto a = 3 ; auto b = 4.3 ; auto c = \u2018 X \u2019 ; auto d = \u201c Hello \u201d ; auto e = std :: make_pair ( 3 , \u201c Hello \u201d );","title":"Intro to structs"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#sneak-peek-at-streams","text":"stream: an abstraction for input/output. Streams convert between data and the string representation of data. std :: cout << 5 << std :: endl ; // prints 5 // use a stream to print any primitive type! std :: cout << \"Frankie\" << std :: endl ; // Mix types! std :: cout << \"Frankie is \" << 21 << std :: endl ; // structs? Student s = { \"Frankie\" , \"MN\" , 21 }; std :: cout << s . name << s . age << std :: endl ;","title":"Sneak peek at streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap","text":"Everything with a name in your program has a type Strong type systems prevent errors before your code runs! Structs are a way to bundle a bunch of variables of many types std::pair is a type of struct that had been defined for you and is in the STL So you access it through the std:: namespace (std::pair) auto is a keyword that tells the compiler to deduce the type of a variable, it should be used when the type is obvious or very cumbersome to write out","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec3-initialization--references","text":"","title":"Lec3 Initialization &amp; References"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#initialization","text":"Initialization: How we provide initial values to variables // Recall: Two ways to initialize a struct Student s ; s . name = \"Frankie\" ; s . state = \"MN\" ; s . age = 21 ; //is the same as ... Student s = { \"Frankie\" , \"MN\" , 21 }; //Multiple ways to initialize a pair std :: pair < int , string > numSuffix1 = { 1 , \"st\" }; std :: pair < int , string > numSuffix2 ; numSuffix2 . first = 2 ; numSuffix2 . second = \"nd\" ; std :: pair < int , string > numSuffix2 = std :: make_pair ( 3 , \"rd\" ); //Initialization of vectors std :: vector < int > vec1 ( 3 , 5 ); // makes {5, 5, 5}, not {3, 5}! std :: vector < int > vec2 ; vec2 = { 3 , 5 }; // initialize vec2 to {3, 5} after its declared Uniform initialization: curly bracket initialization. Available for all types, immediate initialization on declaration(\u7edf\u4e00\u521d\u59cb\u5316\uff1a\u58f0\u660e\u65f6\u7528\u82b1\u62ec\u53f7\u5b9a\u4e49) std :: vector < int > vec { 1 , 3 , 5 }; std :: pair < int , string > numSuffix1 { 1 , \"st\" }; Student s { \"Frankie\" , \"MN\" , 21 }; // less common/nice for primitive types, but possible! int x { 5 }; string f { \"Frankie\" }; //Careful with Vector initialization! std :: vector < int > vec1 ( 3 , 5 ); // makes {5, 5, 5}, not {3, 5}! //uses a std::initializer_list (more later) std :: vector < int > vec2 { 3 , 5 }; // makes {3, 5} //TLDR: use uniform initialization to initialize every field of your non-primitive typed variables - but be careful not to use vec(n, k)! auto: use it to reduce long type names std :: pair < bool , std :: pair < double , double >> result = quadratic ( a , b , c ); //It can be write as below auto result = quadratic ( a , b , c ); Don\u2019t overuse auto! //A better way to use quadratic int main () { auto a , b , c ; std :: cin >> a >> b >> c ; auto [ found , solutions ] = quadratic ( a , b , c ); if ( found ) { auto [ x1 , x2 ] = solutions ; std :: cout << x1 << \u201c \u201d << x2 << endl ; } else { std :: cout << \u201c No solutions found ! \u201d << endl ; } } //This is better is because it\u2019s semantically clearer: variables have clear names","title":"Initialization"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#references","text":"Reference: An alias (another name) for a named variable References in 106B void changeX ( int & x ){ //changes to x will persist x = 0 ; } void keepX ( int x ){ x = 0 ; } int a = 100 ; int b = 100 ; changeX ( a ); //a becomes a reference to x keepX ( b ); //b becomes a copy of x cout << a << endl ; //0 cout << b << endl ; //100 References in 106L: References to variables vector < int > original { 1 , 2 }; vector < int > copy = original ; vector < int >& ref = original ; original . push_back ( 3 ); copy . push_back ( 4 ); ref . push_back ( 5 ); cout << original << endl ; // {1, 2, 3, 5} cout << copy << endl ; // {1, 2, 4} cout << ref << endl ; // {1, 2, 3, 5} //\u201c=\u201d automatically makes a copy! Must use & to avoid this. Reference-copy bug //bug void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } //fixed void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } l-values l-values can appear on the left or right of an = x is an l-value l-values have names l-values are not temporary r-values r-values can ONLY appear on the right of an = 3 is an r-value r-values don\u2019t have names r-values are temporary The classic reference-rvalue error //\u53ef\u4ee5\u53d6\u5730\u5740\u7684\uff0c\u6709\u540d\u5b57\u7684\uff0c\u975e\u4e34\u65f6\u7684\u5c31\u662f\u5de6\u503c\uff1b\u4e0d\u80fd\u53d6\u5730\u5740\u7684\uff0c\u6ca1\u6709\u540d\u5b57\u7684\uff0c\u4e34\u65f6\u7684\u5c31\u662f\u53f3\u503c\uff1b void shift ( vector < std :: pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } shift ({{ 1 , 1 }}); // {{1, 1}} is an rvalue, it can\u2019t be referenced //fixed void shift ( vector < pair < int , int >>& nums ) { for ( auto & [ num1 , num2 ] : nums ) { num1 ++ ; num2 ++ ; } } auto my_nums = {{ 1 , 1 }}; shift ( my_nums );","title":"References"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#bonus-const-and-const-references","text":"const indicates a variable can\u2019t be modified! std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference, \u6ce8\u610f\u524d\u9762\u4e5f\u8981\u52a0\u4e0a const vec . push_back ( 3 ); // OKAY c_vec . push_back ( 3 ); // BAD - const ref . push_back ( 3 ); // OKAY c_ref . push_back ( 3 ); // BAD - const const std :: vector < int > c_vec { 7 , 8 }; // a const variable // BAD - can't declare non-const ref to const vector std :: vector < int >& bad_ref = c_vec ; // fixed const std :: vector < int >& bad_ref = c_vec ; // BAD - Can't declare a non-const reference as equal to a const reference! std :: vector < int >& ref = c_ref ; const & subtleties std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference \u200b Remember: C++, by default, makes copies when we do variable assignment! We need to use & if we need references instead.","title":"BONUS: Const and Const References"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap_1","text":"Use input streams to get information Use structs to bundle information Use uniform initialization wherever possible Use references to have multiple aliases to the same thing Use const references to avoid making copies whenever possible","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec4-streams","text":"stream: an abstraction for input/output. Streams convert between data and the string representation of data.","title":"Lec4 Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#input-streams","text":"std::cin is an input stream. It has type std::istream Have type std::istream Can only receive strings using the >> operator Receives a string from the stream and converts it to data std::cin is the input stream that gets input from the console int x ; string str ; std :: cin >> x >> str ; //reads exactly one int then 1 string from console First call to std::cin >> creates a command line prompt that allows the user to type until they hit enter Each >> ONLY reads until the next whitespace Whitespace = tab, space, newline Everything after the first whitespace gets saved and used the next time std::cin >> is called If there is nothing waiting in the buffer, std::cin >> creates a new command line prompt Whitespace is eaten: it won\u2019t show up in output string str ; int x ; std :: cin >> str >> x ; //what happens if input is \"blah blah\"? std :: cout << str << x ; //once an error is detected, the input stream\u2019s //fail bit is set, and it will no longer accept //input To read a whole line, use std::getline(istream& stream, string& line); std :: string line ; std :: getline ( cin , line ); //now line has changed! //say the user entered \u201cHello World 42!\u201d std :: cout << line << std :: endl ; //should print out\u201cHello World 42!\u201d >> reads up to the next whitespace character and does not go past that whitespace character. getline reads up to the next delimiter (by default, \u2018\\n\u2019), and does go past that delimiter.","title":"Input streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#output-streams","text":"std::cout is an output stream. It has type std::ostream Can only send data using the << operator Converts any type into string and sends it to the stream std::cout is the output stream that goes to the console","title":"Output streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#file-streams","text":"","title":"File streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#input-file-streams","text":"Have type std::ifstream Only send data using the >> operator Receives strings from a file and converts it to data of any type Must initialize your own ifstream object linked to your file std :: ifstream in ( \u201c out . txt \u201d ); // in is now an ifstream that reads from out.txt string str ; in >> str ; // first word in out.txt goes into str","title":"Input File Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#output-file-streams","text":"Have type std::ofstream Only send data using the << operator Converts data of any type into a string and sends it to the file stream Must initialize your own ofstream object linked to your file std :: ofstream out ( \u201c out . txt \u201d ); // out is now an ofstream that outputs to out.txt out << 5 << std :: endl ; // out.txt contains 5","title":"Output File Streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#string-streams","text":"Input stream: std::istringstream Give any data type to the istringstream, it\u2019ll store it as a string! Output stream: std::ostringstream Make an ostringstream out of a string, read from it word/type by word/type The same as the other i/ostreams you\u2019ve seen!","title":"string streams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#ostringstreams","text":"string judgementCall ( int age , string name , bool lovesCpp ) { std :: ostringstream formatter ; formatter << name << \", age \" << age ; if ( lovesCpp ) formatter << \", rocks.\" ; else formatter << \" could be better\" ; return formatter . str (); }","title":"ostringstreams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#istringstreams","text":"Student reverseJudgementCall ( string judgement ){ //input: \u201cFrankie age 22, rocks\u201d std :: istringstream converter ; string fluff ; int age ; bool lovesCpp ; string name ; converter >> name ; converter >> fluff ; converter >> age ; converter >> fluff ; string cool ; converter >> cool ; if ( cool == \"rocks\" ) return Student { name , age , \"bliss\" }; else return Student { name , age , \"misery\" }; } // returns: {\u201cFrankie\u201d, 22, \u201cbliss\u201d}","title":"istringstreams"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap_2","text":"Streams convert between data of any type and the string representation of that data. Streams have an endpoint: console for cin/cout, files for i/o fstreams, string variables for i/o streams where they read in a string from or output a string to. To send data (in string form) to a stream, use stream_name << data. To extract data from a stream, use stream_name >> data, and the stream will try to convert a string to whatever type data is.","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec5-containers","text":"What's in the STL: Containers Iterators Functions Algorithms","title":"Lec5 Containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#types-of-containers","text":"All containers can hold almost all elements graph TB A[Sequence Containers]-->B[Simple] A-->C[Adaptors] B-->d[vector] B-->e[deque] B-->f[list] B-->q[tuple] C-->p[stack] C-->o[queue] C-->m[priority_queue] graph TB A[Associative Containers]-->B[Ordered] A-->C[Unordered] B-->set B-->map C-->unordered_set C-->unordered_map","title":"Types of containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#sequence-containers","text":"","title":"Sequence Containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#vector","text":"#include <vector> //construct std :: vector < int > intArr ; //Create a new, empty vector std :: vector < int > vec ( n ); //Create a vector with n copies of 0 std :: vector < int > vec ( n , k ); //Create a vector with n copies of a value k std :: vector < string > strArr ; std :: vector < myStruct > structArr ; std :: vector < std :: vector < string >> vecArr ; //\u4e8c\u7ef4\u6570\u7ec4 //use int k = vec [ i ]; //Get the element at index i (does not bounds check) vec . push_back ( k ); //Add a value k to the end of a vector for ( std :: size_t i = 0 ; i < vec . size (); ++ i ) //Loop through vector by index i vec [ i ] = k ; //Replace the element at index i(does not bounds check) vec . clear (); //Remove all elements of a vector vec . size (); //Check size of vector vec . pop_back (); //\u5220\u9664\u672b\u5c3e vec . capacity (); //\u7ed9vector\u5206\u914d\u7684\u7a7a\u95f4\u5927\u5c0f vec . empty (); //\u5224\u65ad\u662f\u5426\u4e3a\u7a7a vec . at ( 2 ); //\u4f4d\u7f6e\u4e3a2\u5904\u5143\u7d20\u5f15\u7528 vec . begin (); //\u5934\u6307\u9488 vec . end (); //\u5c3e\u6307\u9488 \u83dc\u9e1f\u6559\u7a0b","title":"vector"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#array","text":"#include <array> //construct std :: array < int , 3 > arr = { 1 , 2 , 3 }; std :: array < std :: array < string , 3 > , 4 > ; //4*3\u7684string\u6570\u7ec4 //\u8bbf\u95ee arr . at ( 2 ). at ( 1 ); //\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u8bbf\u95ee","title":"array"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#deque","text":"\u200b deque \u652f\u6301 vector \u7684\u6240\u6709\u64cd\u4f5c\uff0c\u5e76\u4e14\u652f\u6301\u5feb\u901f push_front() \uff0c\u4f46\u662f\u5b9e\u8df5\u4e2d\u4e00\u822c\u4f7f\u7528 vector \uff0c\u56e0\u4e3a\u5176\u4ed6\u64cd\u4f5c\u66f4\u5feb\u3002","title":"deque"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#list","text":"\u200b A list provides fast insertion anywhere, but no random (indexed) access. What you want to do std::vector std::deque std::list Insert/remove in the front Slow Fast Fast Insert/remove in the back Super Fast Very Fast Fast Indexed Access Super Fast Fast Impossible Insert/remove in the middle Slow Fast Very Fast Memory usage Low High High Combining (splicing/joining) Slow Very Slow Fast Stability (iterators/concurrency) Bad Very Bad Good wrapper: A wrapper on an object changes how external users can interact with that object. Container adaptors are wrappers in C++!","title":"list"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#queue","text":"queue . push_back (); queue . pop_front ();","title":"queue"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#stack","text":"stack . push_back (); stack . pop_back ();","title":"stack"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#priority_queue","text":"\u200b Adding elements with a priority, always removing the highest priority-element.","title":"priority_queue"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#associative-containers","text":"","title":"Associative Containers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#set","text":"set \u5c31\u662f\u96c6\u5408\uff0c\u6bcf\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u6309\u952e\u503c\u5347\u5e8f\u6392\u5217\u3002\u8bbf\u95ee\u5143\u7d20\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(logn). std :: set < int > s ; //Create an empty set s . insert ( k ); //Add a value k to the set s . erase ( k ); //Remove value k from the set if ( s . count ( k ))... //Check if a value k is in the set if ( vec . empty ())... //Check if vector is empty","title":"set"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#map","text":"map \u662fc++\u6807\u51c6\u5e93\u4e2d\u5b9a\u4e49\u7684\u5173\u8054\u5bb9\u5668\uff0c\u662f\u952e\uff08key\uff09\u503c\uff08value\uff09\u5bf9\u7684\u7ed3\u5408\u4f53\u3002 std :: map < int , char > m ; //Create an empty map m . insert ({ k , v }); m [ k ] = v ; //Add key k with value v into the map m . erase ( k ); //Remove key k from the map if ( m . count ( k )) ... //Check if key k is in the map if ( m . empty ()) ... //Check if the map is empty //Retrieve or overwrite value associated with key k (error if key isn\u2019t in map) char c = m . at ( k ); m . at ( k ) = v ; //Retrieve or overwrite value associated with key k (auto-insert if key isn\u2019t in map) char c = m [ k ]; m [ k ] = v ; Every std::map<k, v> is actually backed by: std::pair<const k, v> //Iterating through maps and sets std :: set < ... > s ; std :: map < ..., ... > m ; for ( const auto & element : s ) { // do stuff with element } for ( const auto & [ key , value ] : m ) { // do stuff with key and value }","title":"map"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#unordered_map-and-unordered_set","text":"Each STL set/map comes with an unordered sibling. They\u2019re almost the same, except: Instead of a comparison operator, the set/map type must have a hash function defined for it. Simple types, like int, char, bool, double, and even std::string are already supported! Any containers/collections need you to provide a hash function to use them. unordered_map/unordered_set are generally faster than map/set.","title":"unordered_map and unordered_set"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap_3","text":"Sequence Containers std::vector - use for almost everything std::deque - use when you need fast insertion to front AND back Container Adaptors sta::stack and std::queue Associative Containers std::map and std::set if using simple data types/you\u2019re familiar with hash functions, use std::unordered_map and std::unordered_set","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec6-iterators-and-pointers","text":"","title":"Lec6 Iterators and Pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#iterators","text":"A way to access all containers programmatically! Iterators are objects that point to elements inside containers. Each STL container has its own iterator, but all of these iterators exhibit a similar behavior! Generally, STL iterators support the following operations: std :: set < type > s = { 0 , 1 , 2 , 3 , 4 }; std :: set :: iterator iter = s . begin (); // at 0 ++ iter ; // at 1 * iter ; // 1 ( iter != s . end ()); // can compare iterator equality auto second_iter = iter ; // \"copy construction\" Types: Input Iterator\uff1a\u53ea\u80fd\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\uff0c\u4e0d\u5141\u8bb8\u4fee\u6539\u7531\u8be5\u7c7b\u8fed\u4ee3\u5668\u5f15\u7528\u7684\u5143\u7d20\u3002 Output Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u548cInput Iterator\u6781\u5176\u76f8\u4f3c\uff0c\u4e5f\u53ea\u80fd\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\uff0c\u4e0d\u540c\u7684\u662f\u8be5\u7c7b\u8fed\u4ee3\u5668\u5bf9\u5143\u7d20\u53ea\u6709\u5199\u7684\u6743\u529b\u3002 Forward Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u53ef\u4ee5\u5728\u4e00\u4e2a\u6b63\u786e\u7684\u533a\u95f4\u4e2d\u8fdb\u884c\u8bfb\u5199\u64cd\u4f5c\uff0c\u5b83\u62e5\u6709Input Iterator\u7684\u6240\u6709\u7279\u6027\uff0c\u548cOutput Iterator\u7684\u90e8\u5206\u7279\u6027\uff0c\u4ee5\u53ca\u5355\u6b65\u5411\u524d\u8fed\u4ee3\u5143\u7d20\u7684\u80fd\u529b\u3002 Bidirectional Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u662f\u5728Forward Iterator\u7684\u57fa\u7840\u4e0a\u63d0\u4f9b\u4e86\u5355\u6b65\u5411\u540e\u8fed\u4ee3\u5143\u7d20\u7684\u80fd\u529b\u3002 Random Access Iterator\uff1a\u8be5\u7c7b\u8fed\u4ee3\u5668\u80fd\u5b8c\u6210\u4e0a\u9762\u6240\u6709\u8fed\u4ee3\u5668\u7684\u5de5\u4f5c\uff0c\u5b83\u81ea\u5df1\u72ec\u6709\u7684\u7279\u6027\u5c31\u662f\u53ef\u4ee5\u50cf\u6307\u9488\u90a3\u6837\u8fdb\u884c\u7b97\u672f\u8ba1\u7b97\uff0c\u800c\u4e0d\u662f\u4ec5\u4ec5\u53ea\u6709\u5355\u6b65\u5411\u524d\u6216\u5411\u540e\u8fed\u4ee3\u3002 Explain: There are a few different types of iterators, since containers are different! All iterators can be incremented (++) Input iterators can be on the RHS (right hand side) of an = sign: auto elem = *it; Output iterators can be on the LHS of = : *elem = value; Random access iterators support indexing by integers! it += 3 ; // move forward by 3 it -= 70 ; // move backwards by 70 auto elem = it [ 5 ]; // offset by 5 Why ++iter and not iter++? \u200b Answer : ++iter returns the value after being incremented! iter++ returns the previous value and then increments it. (wastes just a bit of time) std :: map < int , int > map {{ 1 , 2 }, { 3 , 4 }}; auto iter = map . begin (); // what is *iter? ++ iter ; auto iter2 = iter ; // what is (*iter2).second? ++ iter2 ; // now what is (*iter).first? // ++iter: go to the next element // *iter: retrieve what's at iter's position // copy constructor: create another iterator pointing to the same thing std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( auto iter = set . begin (); iter != set . end (); ++ iter ) { const auto & elem = * iter ; cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( auto iter = map . begin (); iter != map . end (); ++ iter ) { const auto & [ key , value ] = * iter ; // structured binding! cout << key << \":\" << value << \", \" << endl ; } std :: set < int > set { 3 , 1 , 4 , 1 , 5 , 9 }; for ( const auto & elem : set ) { cout << elem << endl ; } std :: map < int > map {{ 1 , 6 }, { 1 , 8 }, { 0 , 3 }, { 3 , 9 }}; for ( const auto & [ key , value ] : map ) { cout << key << \":\" << value << \", \" << endl ; } auto key = ( * iter ). first ; auto key = iter -> first ; //These are equivalent.","title":"Iterators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#pointers","text":"When variables are created, they're given an address in memory. Pointers are objects that store an address and type of a variable. To get the value of a pointer, we can dereference it (get the object referenced by the pointer) int x = 5 ; int * pointerToInt = & x ; // creates pointer to int cout << * pointerToInt << endl ; // 5 std :: pair < int , int > pair = { 1 , 2 }; // creates pair std :: pair < int , int >* pointerToPair = & pair ; // creates pointer to pair cout << ( * pair ). first << endl ; // 1 cout << pair -> first << endl ; // 1","title":"Pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#pointers-vs-iterators","text":"Iterators are a form of pointers! Pointers are more generic iterators can point to any object, not just elements in a container! std :: string lands = \"Xadia\" ; // iterator auto iter = lands . begin (); // syntax for a pointer. don't worry about the specifics if you're in 106B! they'll be discussed in the latter half of the course. char * firstChar = & lands [ 0 ];","title":"Pointers vs. Iterators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec7-classes","text":"Containers are all classes defined in the STL! Iterators are (basically) pointers! More on that later Class: A programmerdefined custom type. An abstraction of an object or data type.","title":"Lec7 Classes"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#but-dont-structs-do-that","text":"struct Student { string name ; // these are called fields string state ; // separate these by semicolons int age ; }; Student s = { \"Frankie\" , \"MN\" , 21 }; Issues with structs Public access to all internal state data by default Users of struct need to explicitly initialize each data member. Classes provide their users with a public interface and separate this from a private implementation.","title":"But don\u2019t structs do that?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#turning-student-into-a-class-header-file--cpp-file","text":"//student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; //student.cpp #include student.h std :: string Student::getName (){ return name ; } void Student::setName (){ this -> name = name ; } int Student::getAge (){ return age ; } void Student::setAge ( int age ){ if ( age >= 0 ) { this -> age = age ; } else error ( \"Age cannot be negative!\" ); } Function definitions with namespaces! namespace_name::name in a function prototype means \u201cthis is the implementation for an interface function in namespace_name \u201d Inside the {...} the private member variables for namespace_name will be in scope! std::string Student::getName(){...} The this keyword! Here, we mean \u201cset the Student private member variable name equal to the parameter name \u201d void Student::setName (){ name = name ; } this->element_name means \u201cthe item in this Student object with name element_name\u201d. Use this for naming conflicts! void Student::setName ( string name ){ this -> name = name ; //better! }","title":"Turning Student into a class: Header File + .cpp File:"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#constructors-and-destructors","text":"constructors: Define how the member variables of an object is initialized What gets called when you first create a Student object Overloadable! destructors: deleteing (almost) always happens in the destructor of a class! The destructor is defined using Class_name::~Class_name() No one ever explicitly calls it! Its called when Class_name object go out of scope! Just like all member functions, declare it in the .h and implement in the .cpp! \u6784\u9020\u51fd\u6570\u5c31\u662f\u4e00\u4e2a\u4e0e\u7c7b\u540d\u76f8\u540c\u7684\u51fd\u6570\uff0c\u5728\u751f\u6210\u8fd9\u4e2a\u7c7b\u7684\u65f6\u5019\u5c31\u4f1a\u88ab\u8c03\u7528\uff0c\u7528\u6765\u521d\u59cb\u5316\u8fd9\u4e2a\u7c7b\u3002 \u4e0e\u6784\u9020\u51fd\u6570\u76f8\u5bf9\u7684\u662f\u6790\u6784\u51fd\u6570\uff0c\u5728\u5173\u95ed\u6587\u4ef6\u3001\u91ca\u653e\u5185\u5b58\u524d\u91ca\u653e\u8d44\u6e90\uff0c\u540d\u79f0\u662f\u7c7b\u540d\u524d\u52a0\u4e00\u4e2a ~ #include <iostream> class Entity { public : float X , Y ; Entity () { std :: cout << \"Entity is constructed!\" << std :: endl ; } ~ Entity () { std :: cout << \"Entity is destructed!\" << std :: endl ; } }; void Function () { Entity e ; } int main () { Function (); std :: cin . get (); }","title":"Constructors and Destructors"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#public-and-private-sections","text":"Class: A programmerdefined custom type. An abstraction of an object or data type. //student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; Public section: Users of the Student object can directly access anything here! Defines interface for interacting with the private member variables! Private section: Usually contains all member variables Users can\u2019t access or modify anything in the private section","title":"Public and Private Sections"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#one-last-thing-arrays","text":"//int * is the type of an int array variable int * my_int_array ; //my_int_array is a pointer! //this is how you initialize an array my_int_array = new int [ 10 ]; //this is how you index into an array int one_element = my_int_array [ 0 ]; //Arrays are memory WE allocate, so we need to give instructions for when to deallocate that memory! //When we are done using our array, we need to delete [] it! delete [] my_int_array ;","title":"One last thing\u2026 Arrays"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec8-template-classes-and-const--correctness","text":"","title":"Lec8 Template Classes and Const  Correctness"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-classes","text":"Fundamental Theorem of Software Engineering: Any problem can be solved by adding enough layers of indirection. The problem with IntVector Vectors should be able to contain any data type! Solution? Create StringVector, DoubleVector, BoolVector etc.. What if we want to make a vector of struct Students? How are we supposed to know about every custom class? What if we don\u2019t want to write a class for every type we can think of? SOLUTION: Template classes! Template Class: A class that is parametrized over some number of types. A class that is comprised of member variables of a general type/types. Template Classes You\u2019ve Used Vectors/Maps/Sets... Pretty much all containers! template < class T > T add ( const T & left , const T & right ){ return left + right ; } //\u9690\u5f0f\u5b9e\u4f8b\u5316 int main (){ int a1 = 10 ; double b1 = 10.0 ; //add(a1,b1); add ( a1 ,( int ) b1 ); //\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362 return 0 ; } //\u663e\u5f0f\u5b9e\u4f8b\u5316 int main (){ int a = 10 ; double b = 10.0 ; add < int > ( a , b ); return 0 ; } Writing a Template Class: Syntax //mypair.h template < typename First , typename Second > class MyPair { public : First getFirst (); Second getSecond (); void setFirst ( First f ); void setSecond ( Second f ); private : First first ; Second second ; }; //mypair.cpp #include \u201cmypair.h\u201d //\u5982\u679c\u6ca1\u6709\u4e0b\u9762\u8fd9\u53e5\u8bdd\u4f1aCompile error! Must announce every member function is templated template < typename First , typename Second > First MyPair :: getFirst (){ return first ; } template < typename Second , typename First > Second MyPair :: getSecond (){ return second ; } Member Types Sometimes, we need a name for a type that is dependent on our template types iterator is a member type of vector std :: vector a = { 1 , 2 }; std :: vector :: iterator it = a . begin (); Summary: Used to make sure your clients have a standardized way to access important types. Lives in your namespace: vector<T>::iterator . After class specifier, you can use the alias directly (e.g. inside function arguments, inside function body). Before class specifier, use typename. // main.cpp #include \u201cvector.h\u201d vector < int > a ; a . at ( 5 ); // vector.h #include \u201cvector.h\u201d //\u6ce8\u610f\u662f\u5728.h\u6587\u4ef6\u4e2d\u5f15\u5165verctor.h\uff0c\u800c\u4e0d\u662f\u5728verctor.cpp\u4e2d\u5f15\u5165!!! template < typename T > class vector < T > { T at ( int i ); }; // vector.cpp template < typename T > void vector < T >:: at ( int i ) { // oops } \u200b Templates don\u2019t emit code until instantiated , so include the .cpp in the .h instead of the other way around!","title":"Template Classes"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#const-correctness","text":"const: keyword indicating a variable, function or parameter can\u2019t be modified const indicates a variable can\u2019t be modified! std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; // a const variable std :: vector < int >& ref = vec ; // a regular reference const std :: vector < int >& c_ref = vec ; // a const reference vec . push_back ( 4 ); // OKAY c_vec . push_back ( 9 ); // BAD - const ref . push_back ( 5 ); // OKAY c_ref . push_back ( 6 ); // BAD - const Can\u2019t declare non-const reference to const variable! const std :: vector < int > c_vec { 7 , 8 }; // a const variable // fixed const std :: vector < int >& bad_ref = c_vec ; // BAD - Can't declare a non-const reference as equal // to a const reference! std :: vector < int >& ref = c_ref ; const & subtleties with auto std :: vector < int > vec { 1 , 2 , 3 }; const std :: vector < int > c_vec { 7 , 8 }; std :: vector < int >& ref = vec ; const std :: vector < int >& c_ref = vec ; auto copy = c_ref ; // a non-const copy const auto copy = c_ref ; // a const copy auto & a_ref = ref ; // a non-const reference const auto & c_aref = ref ; // a const reference Why const? // Find the typo in this code void f ( const int x , const int y ) { if (( x == 2 && y == 3 ) || ( x == 1 )) cout << 'a' << endl ; if (( y == x -1 ) && ( x == -1 || y = -1 )) //\u8f7b\u677e\u53d1\u73b0\u8fd9\u91cc\u7684y==-1\u5199\u9519\u4e86 cout << 'b' << endl ; if (( x == 3 ) && ( y == 2 * x )) cout << 'c' << endl ; } // Overly ambitious functions in application code long int countPopulation ( const Planet & p ) { // Hats are the cornerstone of modern society addLittleHat ( p ); //compile error // Guaranteed no more population growth, all future calls will be faster sterilize ( p ); //compile error // Optimization: destroy planet // This makes population counting very fast deathStar ( p ); //compile error return 0 ; } //How does the algorithm above work? long int countPopulation ( const Planet & p ) { addLittleHat ( p ); //p is a const reference here ... } void addLittleHat ( Planet & p ) { //p is a (non const) reference here p . add ( something ); } //So it will become compile error Calling addLittleHat on p is like setting a non const variable equal to a const one, it\u2019s not allowed! Const and Classes //student.cpp #include student.h std :: string Student::getName (){ return name ; //we can access name here! } void Student::setName ( string name ){ this -> name = name ; //resolved! } int Student::getAge (){ return age ; } void Student::setAge ( int age ){ //We can define what \u201cage\u201d means! if ( age >= 0 ){ this -> age = age ; } else error ( \"Age cannot be negative!\" ); } //student.h class Student { public : std :: string getName (); void setName ( string name ); int getAge (); void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; Using a const Student: //main.cpp std :: string stringify ( const Student & s ){ return s . getName () + \" is \" + std :: to_string ( s . getAge ) + \" years old.\" ; } //compile error! The compiler doesn\u2019t know getName and getAge don\u2019t modify s! We need to promise that it doesn\u2019t by defining them as const functions Add const to the end of function signatures! So, we make Student const-correct: //student.cpp #include student.h std :: string Student::getName () const { //there return name ; } void Student::setName ( string name ){ this -> name = name ; } int Student::getAge () const { //there return age ; } void Student::setAge ( int age ){ if ( age >= 0 ){ this -> age = age ; } else error ( \"Age cannot be negative!\" ); } //student.h class Student { public : std :: string getName () const ; //there void setName ( string name ); int getAge const (); //there void setAge ( int age ); private : std :: string name ; std :: string state ; int age ; }; const-interface: All member functions marked const in a class definition. Objects of type const ClassName may only use the const-interface. Making RealVector\u2018s const-interface: class StrVector { public : using iterator = std :: string * ; const size_t kInitialSize = 2 ; /*...*/ size_t size () const ; bool empty () const ; std :: string & at ( size_t indx ); void insert ( size_t pos , const std :: string & elem ); void push_back ( const std :: string & elem ); iterator begin (); iterator end (); /*...*/ } Should begin() and end() be const? Answer : \u867d\u7136\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u662fconst\u7684\uff0c\u4f46\u662f\u5b83\u4eec\u7ed9\u6211\u4eec\u8fd4\u56de\u4e86\u4e00\u4e2a\u53ef\u4ee5\u53d8\u5316\u7684iterator\uff0c\u6240\u4ee5\u4f1a\u62a5\u9519\uff01 Solution : cbegin() and cend() class StrVector { public : using iterator = std :: string * ; using const_ iterator = const std :: string * ; /*...*/ size_t size () const ; bool empty () const ; /*...*/ void push_back ( const std :: string & elem ); iterator begin (); iterator end (); const_iterator begin () const ; const_iterator end () const ; /*...*/ } void printVec ( const RealVector & vec ){ cout << \"{ \" ; for ( auto it = vec . cbegin (); it != vec . cend (); ++ it ){ cout << * it << cout ; } cout << \" }\" << cout ; } //Fixed! And now we can\u2019t set *it equal to something: it will be a compile error! const iterator vs const_iterator: Nitty Gritty using iterator = std :: string * ; using const_iterator = const std :: string * ; const iterator it_c = vec . begin (); //string * const, const ptr to non-const obj * it_c = \"hi\" ; //OK! it_c is a const pointer to non-const object it_c ++ ; //not ok! cant change where a const pointer points! const_iterator c_it = vec . cbegin (); //const string*, a non-const ptr to const obj c_it ++ ; // totally ok! The pointer itself is non-const * c_it = \"hi\" // not ok! Can\u2019t change underlying const object cout << * c_it << endl ; //allowed! Can always read a const object, just can't change //const string * const, const ptr to const obj const const_iterator c_it_c = vec . cbegin (); cout << c_it_c << \" points to \" << * c_it_c << endl ; //only reads are allowed!","title":"Const Correctness"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap_4","text":"","title":"Recap"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-classes_1","text":"Add template<typename T1, typename T2 ...> before class definition in .h Add template<typename T1, typename T2 ...> before all function signature in .cpp When returning nested types (like iterator types), put template<typename T1, typename T2 ...>::member_type as return type, not just member_type Templates don\u2019t emit code until instantiated, so #include the .cpp file in the .h file, not the other way around","title":"Template classes"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#const-and-const-correctness","text":"Use const parameters and variables wherever you can in application code Every member function of a class that doesn\u2019t change its member variables should be marked const auto will drop all const and &, so be sure to specify Make iterators and const_iterators for all your classes! const iterator = cannot increment the iterator, can dereference and change underlying value const_iterator = can increment the iterator, cannot dereference and change underlying value const const_iterator = cannot increment iterator, cannot dereference and change underlying value","title":"Const and Const-correctness"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec9-template-functions","text":"","title":"Lec9 Template Functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#generic-programming","text":"","title":"Generic Programming"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#generic-c","text":"Allow data types to be parameterized (C++ entities that work on any datatypes) Template classes achieve generic classes How can we write methods that work on any data type?","title":"Generic C++"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#function-to-get-the-min-of-two-ints","text":"int myMin ( int a , int b ) { return a < b ? a : b ; } int main () { auto min_int = myMin ( 1 , 2 ); // 1 auto min_name = myMin ( \"Sathya\" , \"Frankie\" ); // error! One solution: overloaded functions int myMin ( int a , int b ) { return a < b ? a : b ; } // exactly the same except for types std :: string myMin ( std :: string a , std :: string b ) { return a < b ? a : b ; } int main () { auto min_int = myMin ( 1 , 2 ); // 1 auto min_name = myMin ( \"Sathya\" , \"Frankie\" ); // Frankie } But what about comparing other data types, like doubles, characters, and complex objects?","title":"Function to get the min of two ints"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-functions","text":"Writing reusable, unique code with no duplication! //generic, \"template\" functions template < typename Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } //Here, \"class\" is an alternative keyword to typename. //They're 100% equivalent in template function declarations! template < class Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } //Default value for class template parameter template < typename Type = int > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } // int main() {} will be omitted from future examples // we'll instead show the code that'd go inside it cout << myMin < int > ( 3 , 4 ) << endl ; // 3 //let compiler deduce return type template < typename T , typename U > auto smarterMyMin ( T a , U b ) { return a < b ? a : b ; } cout << myMin ( 3.2 , 4 ) << endl ; // 3.2","title":"Template functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-type-deduction---case-1","text":"If the template function parameters are regular, pass-by-value parameters: Ignore the \"&\" After ignoring \"&\", ignore const too template < typename Type > Type addFive ( Type a ) { return a + 5 ; // only works for types that support \"+\" } int a = 5 ; addFive ( a ); // Type is int const int b = a ; addFive ( b ); // Type is still int const int & c = a ; addFive ( c ); // even now, Type is still int","title":"Template type deduction - case 1"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-type-deduction---case-2","text":"If the template function parameters are references or pointers, this is how types (e.g. Type) are deduced: Ignore the \"&\" Match the type of parameters to inputted arguments Add on const after template < typename Type > void makeMin ( const Type & a , const Type & b , Type & minObj ) { //a and b are references to const values // set minObj to the min of a and b instead of returning. minObj = a < b ? a : b ; } const int a = 20 ; const int & b = 21 ; int c ; myMin ( a , b , c ); // Type is deduced to be int cout << c << endl ; // 20 behind the scenes Normal functions are created during compile time, and used in runtime Template functions are not compiled until used by the code template < typename Type > Type myMin ( Type a , Type b ) { return a < b ? a : b ; } cout << myMin ( 3 , 4 ) << endl ; // 3 The compiler deduces the parameter types and generates a unique function specifically for each time the template function is called After compilation, the compiled code looks as if you had written each instantiated version of the function yourself","title":"Template type deduction - case 2"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#template-metaprogramming","text":"Normal code runs during run time. TMP -> run code during compile time make compiled code packages smaller speed up code when it's actually running template < unsigned n > struct Factorial { enum { value = n * Factorial < n - 1 >:: value }; }; template <> // template class \"specialization\" struct Factorial < 0 > { enum { value = 1 }; }; std :: cout << Factorial < 10 >:: value << endl ; // prints 3628800, but run during compile time!","title":"Template Metaprogramming"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#how-can-tmp-actually-be-used","text":"TMP was actually discovered (not invented, discovered) recently! Where can TMP be applied Ensuring dimensional unit correctness Optimizing matrix operations Generating custom design pattern implementation policy-based design (templates generating their own templates)","title":"How can TMP actually be used?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#why-write-generic-functions","text":"Count the # of times 3 appears in a std :: vector < int > . Count the # of times \"Y\" appears in a std :: istream . Count the # of times 5 appears in the second half of a std :: deque < int > . Count the # of times \"X\" appear in the second half of a std :: string . //By using generic functions, we can solve each of these problems with a single function! Counting Occurrences //Attempt 1 //count strings int count_occurrences ( std :: vector < std :: string > vec , std :: string target ){ int count = 0 ; for ( size_t i = 0 ; i < vec . size (); ++ i ){ if ( vec [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //Attempt 2 //generalize this beyond just strings template < typename DataType > int count_occurrences ( const std :: vector < DataType > vec , DataType target ){ int count = 0 ; for ( size_t i = 0 ; i < vec . size (); ++ i ){ if ( vec [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //Attempt 3 //generalize this beyond just vectors template < typename Collection , typename DataType > int count_occurrences ( const Collection & arr , DataType target ){ int count = 0 ; for ( size_t i = 0 ; i < arr . size (); ++ i ){ if ( arr [ i ] == target ) count ++ ; } return count ; } Usage : count_occurrences ({ \"Xadia\" , \"Drakewood\" , \"Innean\" }, \"Xadia\" ); //The collection may not be indexable! //Attempt 4 //Solve the problem in Attempt 3 template < typename InputIt , typename DataType > int count_occurrences ( InputIt begin , InputIt end , DataType target ){ int count = 0 ; for ( initialization ; end - condition ; increment ){ if ( element access == target ) count ++ ; } return count ; } vector < std :: string > lands = { \"Xadia\" , \"Drakewood\" , \"Innean\" }; Usage : count_occurrences ( lands . begin (), lands . end (), \"Xadia\" ); //We manually pass in begin and end so that we can customize our search bounds.","title":"Why write generic functions?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec10-functions-and-lambdas","text":"","title":"Lec10 Functions and Lambdas"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#review-of-template-functions","text":"template < typename InputIt , typename DataType > int count_occurrences ( InputIt begin , InputIt end , DataType val ) { int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( * iter == val ) count ++ ; } return count ; } Usage : std :: string str = \"Xadia\" ; count_occurrences ( str . begin (), str . end (), 'a' ); Could we reuse this to find how many vowels are in \u201dXadia\u201d, or how many odd numbers were in a std::vector?","title":"Review of template functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#function-pointers-and-lambdas","text":"","title":"Function Pointers and Lambdas"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#predicate-functions","text":"Any function that returns a boolean is a predicate! //Unary Predicate bool isLowercaseA ( char c ) { return c == 'a' ; } bool isVowel ( char c ) { std :: string vowels = \"aeiou\" ; return vowels . find ( c ) != std :: string :: npos ; } //Binary Predicate bool isMoreThan ( int num , int limit ) { return num > limit ; } bool isDivisibleBy ( int a , int b ) { return ( a % b == 0 ); }","title":"Predicate Functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#function-pointers-for-generalization","text":"template < typename InputIt , typename UnaryPred > //no typename DataType int count_occurrences ( InputIt begin , InputIt end , UnaryPred pred ) { //add UnaryPred pred int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( pred ( * iter )) count ++ ; //no *iter == val } return count ; } bool isVowel ( char c ) { std :: string vowels = \"aeiou\" ; return vowels . find ( c ) != std :: string :: npos ; } Usage : std :: string str = \"Xadia\" ; count_occurrences ( str . begin (), str . end (), isVowel ); isVowel is a pointer, just like Node * or char * ! It\u2019s called a \u201cfunction pointer\u201d, and can be treated like a variable. Function pointers don\u2019t generalize well.","title":"Function Pointers for generalization"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lambdas","text":"auto var = [ capture - clause ] ( auto param ) -> bool { ... }; //Capture Clause: Outside variables your function uses //Parameters: You can use auto in lambda parameters! capture clause [] // captures nothing [ limit ] // captures lower by value [ & limit ] // captures lower by reference [ & limit , upper ] // captures lower by reference, higher by value [ & , limit ] // captures everything except lower by reference [ & ] // captures everything by reference [ = ] // captures everything by value auto printNum = [] ( int n ) { std :: cout << n << std :: endl ; }; printNum ( 5 ); // 5 int limit = 5 ; auto isMoreThan = [ limit ] ( int n ) { return n > limit ; }; isMoreThan ( 6 ); // true limit = 7 ; isMoreThan ( 6 ); int upper = 10 ; auto setUpper = [ & upper ] () { upper = 6 ; }; Solution template < typename InputIt , typename UniPred > int count_occurrences ( InputIt begin , InputIt end , UniPred pred ) { int count = 0 ; for ( auto iter = begin ; iter != end ; ++ iter ) { if ( pred ( * iter )) count ++ ; } return count ; } Usage : int limit = 5 ; auto isMoreThan = [ limit ] ( int n ) { return n > limit ; }; std :: vector < int > nums = { 3 , 5 , 6 , 7 , 9 , 13 }; count_occurrences ( nums . begin (), nums . end (), isMoreThan ); what really are they Lambdas are cheap, but copying them may not be. Use lambdas when you need a short function, or one with read/write access to local variables Use function pointers for longer logic and for overloading We use \u201cauto\u201d because type is figured out in compile time","title":"Lambdas"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#functors-and-closures","text":"class functor { public : int operator () ( int arg ) const { // parameters and function body return num + arg ; } private : int num ; // capture clause }; int num = 0 ; auto lambda = [ & num ] ( int arg ) { num += arg ; }; lambda ( 5 ); A functor is any class that provides an implementation of operator(). Lambdas are essentially syntactic sugar for creating a functor. If lambdas are functor classes, then \u201cclosures\u201d are instances of those classes. At runtime, closures are generated as instances of lambda classes. How do functors, lambdas, and function pointers relate? Answer: standard function, std::function<\u2026>, is the one to rule them all \u2014 it\u2019s the overarching type for anything callable in C++. Functors, lambdas, and function pointers can all be casted to standard functions void functionPointer ( int arg ) { int num = 0 ; num += arg ; } // or int num = 0 ; auto lambda = [ & num ] ( int arg ) { num += arg ; }; lambda ( 5 ); // num = 5; std :: function < void ( int ) > func = lambda ; We could cast either functionPointer or lambda to func, as both of them have a void return signature and take in one integer parameter.","title":"Functors and Closures"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#introducing-stl-algorithms","text":"A collection of completely generic functions written by C++ devs #include <algorithm> : sort \u00b7 reverse \u00b7 min_element \u00b7 max_element \u00b7 binary_search \u00b7 stable_partition \u00b7 find \u00b7 find_if \u00b7 count_if \u00b7 copy \u00b7 transform \u00b7 insert \u00b7 for_each \u00b7 etc.!","title":"Introducing STL Algorithms"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec11-operator-overloading","text":"Redefining what operators mean","title":"Lec11 Operator Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#function-overloading","text":"Allow for calling the same function with different parameters: int sum ( int a , int b ) { return a + b ; } double sum ( double a , double b ) { return a + b ; } // usage: cout << sum ( 1.5 , 2.4 ) << endl ; cout << sum ( 10 , 20 ) << endl ;","title":"Function Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#operator-overloading","text":"\\+ - * / % ^ & | ~ ! , = < > <= >= ++ -- << >> == != && || += -= *= /= %= ^= &= |= <<= >>= [] () -> ->* new new[] delete delete[] if ( before ( a , b )) { // a, b defined earlier cout << \"Time a is before Time b\" << endl ; } //Overloading if ( a < b ) { cout << \"Time a is before Time b\" << endl ; }","title":"Operator Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#two-ways-to-overload-operators","text":"","title":"Two ways to overload operators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#member-functions","text":"Add a function called operator __ to your class: class Time { bool operator < ( const Time & rhs ) const ; //rhs = Right Hand Side bool operator + ( const Time & rhs ) const ; bool operator ! () const ; // unary, no arguments } //lhs (left hand side) of each operator is this. Call the function on the left hand side of the expression (this) Binary operators (5 + 2, \"a\" < \"b\"): accept the right hand side (& rhs) as an argument(\u53c2\u6570). Unary operators (~a, !b): don't take any arguments class Time { bool operator < ( const Time & rhs ) { if ( hours < rhs . hours ) return true ; if ( rhs . hours < hours ) return false ; // compare minutes, seconds... } } Time a , b ; if ( a . operator < ( b )) { // do something; } Operators can only be called on the left hand side What if we can't control what's on the left hand side of the operation? e.g. if we want to compare a double and a Fraction","title":"Member Functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#non-member-functions","text":"Add a function called operator __ outside of your class: bool operator < ( const Time & lhs , const Time & rhs ); Time operator + ( const Time & lhs , const Time & rhs ); Time & operator += ( const Time & lhs , const Time & rhs ); Time operator ! ( const Time & lhs , const Time & rhs ); Instead of taking only rhs, it takes both the left hand side and right hand side! The STL prefers using non-member functions for operator overloading: allows the LHS to be a non-class type (e.g. double < Fraction) allows us to overload operations with a LHS class that we don't own You may be wondering how non-member functions can access private member variables: The answer : friends! class Time { // core member functions omitted for brevity public : friend bool operator == ( const Time & lhs , const Time & rhs ); private : int hours , minutes , seconds ; } bool operator == ( const Time & lhs , const Time & rhs ) { return lhs . hours == rhs . hours && lhs . minutes == rhs . minutes && lhs . seconds == rhs . seconds ; }","title":"Non-Member Functions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#-operator-overloading","text":"We can use << to output something to an std::ostream&: std :: ostream & operator << ( std :: ostream & out , const Time & time ) { out << time . hours << \":\" << time . minutes << \":\" << time . seconds ; // 1) print data to ostream return out ; // 2) return original ostream } // in time.h -- friend declaration allows access to private attrs public : friend std :: ostream & operator << ( std :: ostream & out , const Time & time ); // now we can do this! cout << t << endl ; // 5:22:31 This is how std::cout mixes types (and still works)! //Since these two methods are implemented in the STL std :: ostream & operator << ( std :: ostream & out , const std :: string & s ); std :: ostream & operator << ( std :: ostream & out , const int & i ); //then cout << \"test\" << 5 ; // (cout << \"test\") << 5; //then operator << ( operator << ( cout , \"test\" ), 5 ); //then operator << ( cout , 5 ); //then cout ; Don't overuse operator overloading! //Confusing MyString a ( \"opossum\" ); MyString b ( \"quokka\" ); MyString c = a * b ; // what does this even mean?? //Great! MyString a ( \"opossum\" ); MyString b ( \"quokka\" ); MyString c = a . charsInCommon ( b ); // much better!","title":"&lt;&lt; Operator Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#rules-of-operator-overloading","text":"Meaning should be obvious when you see it Should be reasonably similar to corresponding arithmetic operations Don't define + to mean set subtraction! When the meaning isn't obvious, give it a normal name instead","title":"Rules of Operator Overloading"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec12-special-member-function","text":"","title":"Lec12 Special Member Function"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#special-member-functions-smfs","text":"These functions are generated only when they're called (and before any are explicitly defined by you): Default Constructor Copy Constructor Copy Assignment Operator Destructor Move Constructor Move Assignment Operator class Widget { public : Widget (); // default constructor Widget ( const Widget & w ); // copy constructor Widget & operator = ( const Widget & w ); // copy assignment operator ~ Widget (); // destructor Widget ( Widget && rhs ); // move constructor Widget & operator = ( Widget && rhs ); // move assignment operator } Default Constructor object is created with no parameters constructor also has no parameters all SMFs are public and inline function, meaning that wherever it's used is replaced with the generated code in the function Copy Constructor another type of constructor that creates an instance of a class constructs a member-wise copy of an object (deep copy) Copy Assignment Operator very similar to copy constructor, except called when trying to set one object equal to another e.g. w1 = w2; Destructor called whenever object goes out of scope can be used for deallocating member variables and avoiding memory leaks Move Constructor Move Assignment Operator //Examples: using std :: vector ; vector < int > func ( vector < int > vec0 ) { vector < int > vec1 ; //Default constructor creates empty vector vector < int > vec2 ( 3 ); //Not a SMF - calls a constructor with parameters\u2192{0,0,0} vector < int > vec3 { 3 }; //Also not a SMF, uses initializer_list vector < int > vec4 (); //A function declaration! (C++'s most vexing parse) vector < int > vec5 ( vec2 }; //Copy constructor - vector created as copy of another vector < int > vec {}; //Also the default constructor vector < int > vec { vec3 + vec4 }; //Copy constructor vector < int > vec8 = vec4 ; //Copy constructor - vec8 is newly constructor vec8 = vec2 ; //Copy assignment - vec8 is an existing object return vec8 ; //Copy constructor: copies vec8 to location outside of func } //Destructors on all values (except return value) are called","title":"Special Member Functions (SMFs)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#copy-constructors-and-copy--assignment-operators","text":"","title":"Copy Constructors and Copy  Assignment Operators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#initializer-lists","text":"template < typename T > vector < T >:: vector < T > () { //members are first default constructed (declared to be their default values) _size = 0 ; _capacity = kInitialSize ; _elems = new T [ kInitialSize ]; //Then each member is reassigned. This seems wasteful! } //The technique below is called an initializer list template < typename T > vector < T >:: vector < T > () : //Directly construct each member with a starting value _size ( 0 ), _capacity ( kInitialSize ), _elems ( new T [ kInitialSize ]) { } Prefer to use member initializer lists, which directly constructs each member with a given value Faster! Why construct, and then immediately reassign? What if members are a non-assignable type (you'll see by the end of lecture how this can be possible!) Important clarification: you can use member initializer lists for ANY constructor, even if it has parameters (and thus isn't an SMF)","title":"initializer lists"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#why-arent-the-default-smfs--always-sufficient","text":"The default compiler-generated copy constructor and copy assignment operator functions work by manually copying each member variable! Moral of the story: in many cases, copying is not as simple as copying each member variable! //the default copy constructor template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( other . _elems ) { } //We can create a new array template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( other . _elems ) { _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //Even better: let's move this to the initializer list template < typename T > vector < T >:: vector < T > ( const vector :: vector < T >& other ) : _size ( other . _size ), _capacity ( other . _capacity ), _elems ( new T [ other . _capacity ]) { //We can move our reassignment of _elems up! std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //the default copy assignment operator template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { _size = other . _size ; _capacity = other . _capacity ; _elems = other . _elems ; return * this ; } //Attempt 1: Allocate a new array and copy over elements template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { _size = other . _size ; _capacity = other . _capacity ; _elems = new T [ other . _capacity ]; //We've lost access to the old value of _elems, and leaked the array that it pointed to! std :: copy ( other . _elems , other . _elems + other . _size , _elems ); } //Attempt 2: Deallocate the old array and make a new one template < typename T > vector < T >& vector < T >:: operator = ( const vector < T >& other ) { if ( & other == this ) return * this ; //Also, be careful about self-reassignment! _size = other . _size ; _capacity = other . _capacity ; delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; //Remember to return a reference to the vector itself } Copy operations must perform these tasks: Copy constructor Use initializer list to copy members where simple copying does the correct thing. int, other objects, etc Manually copy all members otherwise pointers to heap memory non-copyable things Copy assignment Clean up any resources in the existing object about to be overwritten Copy members using direct assignment when assignment works Manually copy members where assignment does not work You don't have to do these in this order Summary: Steps to follow for an assignment operator Check for self-assignment. Make sure to free existing members if applicable. Copy assign each automatically assignable member. Manually copy all other members. Return a reference to *this (that was just reassigned).","title":"Why aren't the default SMFs  always sufficient?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#-delete-and--default","text":"//Explicitly delete the copy member functions //Adding = delete; after a function prototype tells C++ to not generate the corresponding SMF class PasswordManager { public : PasswordManager (); PasswordManager ( const PasswordManager & pm ); ~ PasswordManager (); // other methods ... PasswordManager ( const PasswordManager & rhs ) = delete ; PasswordManager & operator = ( const PasswordManager & rhs ) = delete ; private : // other important members ... } //Is there a way to keep, say, the default copy constructor if you write another constructor? //Adding = default; after a function prototype tells C++ to still generate the default SMF, even if you're defining other SMFs class PasswordManager { public : PasswordManager (); PasswordManager ( const PasswordManager & pm ) = default ; ~ PasswordManager (); // other methods ... PasswordManager ( const PasswordManager & rhs ) = delete ; PasswordManager & operator = ( const PasswordManager & rhs ) = delete ; private : // other important members ... }","title":"= delete and = default"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#rule-of-0-and-rule-of-3","text":"","title":"Rule of 0 and Rule of 3"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#rule-of-0","text":"If the default operations work, then don't define your own! When should you define your own SMFs When the default ones generated by the compiler won't work Most common reason: there's a resource that our class uses that's not stored inside of our class e.g. dynamically allocated memory our class only stores the pointers to arrays, not the arrays in memory itself","title":"Rule of 0"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#rule-of-3-c-98","text":"If you explicitly define a copy constructor, copy assignment operator, or destructor, you should define all three What's the rationale? If you're explicitly writing your own copy operation, you're controlling certain resources manually You should then manage the creation, use, and releasing of those resources! Recap of Special Member Functions (SMFs) Default Constructor Object created with no parameters, no member variables instantiated Copy Constructor Object created as a copy of existing object (member variable-wise) Copy Assignment Operator Existing object replaced as a copy of another existing object. Destructor Object destroyed when it is out of scope. Are these 4 enough? class StringTable { public : StringTable () {} StringTable ( const StringTable & st ) {} // functions for insertion, erasure, lookup, etc., // but no move/dtor functionality // ... private : std :: map < int , std :: string > values ; }","title":"Rule of 3 (C++ 98)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#move-constructors-and-move--assignment-operators","text":"","title":"Move constructors and move  assignment operators"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#move-operations-c11","text":"These functions are generated only when they're called (and before any are explicitly defined by you) //Allow for moving objects and std::move operations (rvalue refs) class Widget { public : Widget (); // default constructor Widget ( const Widget & w ); // copy constructor Widget & operator = ( const Widget & w ); // copy assignment operator ~ Widget (); // destructor Widget ( Widget && rhs ); // move constructor Widget & operator = ( Widget && rhs ); // move assignment operator } Move constructors and move assignment operators will perform \"memberwise moves\" Defining a copy constructor does not affect generation of a default copy assignment operator, and vice versa Defining a move assignment operator prevents generation of a move copy constructor, and vice versa Rationale: if the move assignment operator needs to be re-implemented, there'd likely be a problem with the move constructor","title":"Move Operations (C++11)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#some-nuances-to-move-operation-smfs","text":"Move operations are generated for classes only if these things are true: No copy operations are declared in the class No move operations are declared in the class No destructor is declared in the class Can get around all of these by using default: Widget ( Widget && ) = default ; Widget & operator = ( Widget && ) = default ; // support moving Widget ( const Widget & ) = default ; Widget & operator = ( const Widget & ) = default ; // support copying","title":"Some nuances to move operation SMFs"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec13-move-semantics-in-c","text":"l-values live until the end of the scope r-values live until the end of the line //Find the r-values! (Only consider the items on the right of = signs) int x = 3 ; //3 is an r-value int * ptr = 0x02248837 ; //0x02248837 is an r-value vector < int > v1 { 1 , 2 , 3 }; //{1, 2, 3} is an r-value,v1 is an l-value auto v4 = v1 + v2 ; //v1 + v2 is an r-value size_t size = v . size (); //v.size()is an r-value v1 [ 1 ] = 4 * i ; //4*i is an r-value, v1[1] is an l-value ptr = & x ; //&x is an r-value v1 [ 2 ] = * ptr ; //*ptr is an l-value MyClass obj ; //obj is an l-value x = obj . public_member_variable ; //obj.public_member_variable is l-value","title":"Lec13 Move Semantics in C++"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#how-many-arrays-will-be-allocated-copied-and-destroyed-here","text":"int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); // //make_me_a_vec(123) is an r-value } vector < int > make_me_a_vec ( int num ) { vector < int > res ; while ( num != 0 ) { res . push_back ( num % 10 ); num /= 10 ; } return res ; } vec is created using the default constructor make_me_a_vec creates a vector using the default constructor and returns it vec is reassigned to a copy of that return value using copy assignment copy assignment creates a new array and copies the contents of the old one The original return value\u2019s lifetime ends and it calls its destructor vec\u2019s lifetime ends and it calls its destructor","title":"How many arrays will be allocated, copied and destroyed here?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#how-do-we-know-when-to-use-move-assignment-and--when-to-use-copy-assignment","text":"Answer : When the item on the right of the = is an r-value we should use move assignment Why? r-values are always about to die, so we can steal their resources //Examples //Using move assignment int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); } //Using copy assignment int main () { vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = vec1 ; vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } //and vec2 never saw a thing","title":"How do we know when to use move assignment and  when to use copy assignment?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#the-r-value-reference","text":"How to make two different assignment operators? Overload vector::operator= ! How? Introducing\u2026 the r-value reference && (This is different from the l-value reference & you have see before) (it has one more ampersand) Overloading with && int main () { int x = 1 ; change ( x ); //this will call version 2 change ( 7 ); //this will call version 1 } void change ( int && num ){...} //version 1 takes r-values void change ( int & num ){...} //version 2 takes l-values //num is a reference to vec","title":"the r-value reference"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#copy-assignment-and-move-assignment","text":"//Copy assignment vector < T >& operator = ( const vector < T >& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //must copy entire array delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; } //Move assignment vector < T >& operator = ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //we can steal the array delete [] _elems ; _elems = other . _elems return * this ; } //This works int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); //this will use move assignment vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = vec1 ; //this will use copy assignment vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } The compiler will pick which vector::operator= to use based on whether the RHS is an l-value or an r-value","title":"Copy assignment and Move assignment"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#can-we-make-it-even-better","text":"In the move assignment above, these are also making copies (using int/ptr copy assignment) _size = other . _size ; _capacity = other . _capacity ; _elems = other . _elems ; We can force move assignment rather than copy assignment of these ints by using std::move vector < T >& operator = ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = std :: move ( other . _size ); _capacity = std :: move ( other . _capacity ); //we can steal the array delete [] _elems ; _elems = std :: move ( other . _elems ); return * this ; } The compiler will pick which vector::operator= to use based on whether the RHS is an l-value or an r-value","title":"Can we make it even better?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#constructor","text":"//How about this int main () { vector < int > vec ; vec = make_me_a_vec ( 123 ); //this will use move assignment vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } //this should use move vector < string > vec2 = vec1 ; //this will use copy construction vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) } //copy constructor vector < T > ( const vector < T >& other ) { if ( & other == this ) return * this ; _size = other . _size ; _capacity = other . _capacity ; //must copy entire array delete [] _elems ; _elems = new T [ other . _capacity ]; std :: copy ( other . _elems , other . _elems + other . _size , _elems ); return * this ; } //move constructor vector < T > ( vector < T >&& other ) { if ( & other == this ) return * this ; _size = std :: move ( other . _size ); _capacity = std :: move ( other . _capacity ); //we can steal the array delete [] _elems ; _elems = std :: move ( other . _elems ); return * this ; } Where else should we use std::move? Answer : Wherever we take in a const & parameter in a class member function and assign it to something else in our function Don\u2019t use std::move outside of class definitions, never use it in application code!","title":"Constructor"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#vectorpush_back","text":"//Copy push_back void push_back ( const T & element ) { elems [ _size ++ ] = element ; //this is copy assignment } //Move push_back void push_back ( T && element ) { elems [ _size ++ ] = std :: move ( element ); //this forces T\u2019s move assignment }","title":"vector::push_back"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#be-careful-with-stdmove","text":"int main () { vector < string > vec1 = { \u201c hello \u201d , \u201c world \u201d } vector < string > vec2 = std :: move ( vec1 ); vec1 . push_back ( \u201c Sure hope vec2 doesn \u2019 t see this ! \u201d ) //wrong!!! } After a variable is moved via std::move, it should never be used until it is reassigned to a new variable! The C++ compiler might warn you about this mistake, but the code above compiles!","title":"Be careful with std::move"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#tldr-move-semantics","text":"If your class has copy constructor and copy assignment defined, you should also define a move constructor and move assignment Define these by overloading your copy constructor and assignment to be defined for Type&& other as well as Type& other Use std::move to force the use of other types\u2019 move assignments and constructors All std::move(x) does is cast x as an rvalue Be wary of std::move(x) in main function code","title":"TLDR: Move Semantics"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#bonus-stdmove-and-raii","text":"Recall: RAII means all resources required by an object are acquired in its constructor and destroyed in its destructor To be consistent with RAII, you should have no half-ready resources, such as a vector whose underlying array has been deallocated Is std::move consistent with RAII? I say NO! This is a sticky language design flaw, C++ has a lot of those!","title":"Bonus: std::move and RAII"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec14-type-safety-and-stdoptional","text":"","title":"Lec14 Type Safety and std::optional"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap-const-correctness","text":"We pass big pieces of data by reference into helper functions by to avoid making copies of that data If this function accidentally or sneakily changes that piece of data, it can lead to hard to find bugs! Solution : mark those reference parameters const to guarantee they won\u2019t be changed in the function!","title":"Recap: Const-Correctness"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#how-does-the-compiler-know-when-its-safe-to-call--member-functions-of-const-variables","text":"const-interface: All member functions marked const in a class definition. Objects of type const ClassName may only use the const-interface. RealVector\u2019s const-interface template < class ValueType > class RealVector { public : using iterator = ValueType * ; using const_ iterator = const ValueType * ; /*...*/ size_t size () const ; bool empty () const ; /*...*/ void push_back ( const ValueType & elem ); iterator begin (); iterator end (); const_iterator cbegin () const ; const_iterator cend () const ; /*...*/ } Key Idea: Sometimes less functionality is better functionality Technically, adding a const-interface only limits what RealVector objects marked const can do Using types to enforce assumptions we make about function calls help us prevent programmer errors!","title":"How does the compiler know when it\u2019s safe to call  member functions of const variables?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#type-safety","text":"Type Safety: The extent to which a language prevents typing errors. guarantees the behavior of programs. What does this code do? void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back () % 2 == 1 ){ vec . pop_back (); } } //What happens when input is {} ? //One solution void removeOddsFromEnd ( vector < int >& vec ){ while ( ! vec . empty () && vec . back () % 2 == 1 ){ vec . pop_back (); } } //Key idea: it is the programmers job to enforce the precondition that vec be non-empty, otherwise we get undefined behavior! There may or may not be a \u201clast element\u201d in vec. How can vec.back() have deterministic behavior in either case? The problem valueType & vector < valueType >:: back (){ return * ( begin () + size () - 1 ); } //Dereferencing a pointer without verifying it points to real memory is undefined behavior! valueType & vector < valueType >:: back (){ if ( empty ()) throw std :: out_of_range ; return * ( begin () + size () - 1 ); } //Now, we will at least reliably error and stop the program or return the last element whenever back() is called Type Safety: The extent to which a function signature guarantees the behavior of a function . The problem //back() is promising to return something of type valueType when its possible no such value exists! valueType & vector < valueType >:: back (){ return * ( begin () + size () - 1 ); } //A first solution? std :: pair < bool , valueType &> vector < valueType >:: back (){ if ( empty ()){ return { false , valueType ()}; //valueType may not have a default constructor } return { true , * ( begin () + size () - 1 )}; } //Even if it does, calling constructors is expensive //So, what should back() return? ??? vector < valueType >:: back (){ if ( empty ()){ return ?? ; } return * ( begin () + size () - 1 ); } //Introducing std::optional","title":"Type Safety"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#stdoptional","text":"What is std::optional<T> ? std::optional is a template class which will either contain a value of type T or contain nothing (expressed as nullopt ) void main (){ std :: optional < int > num1 = {}; //num1 does not have a value num1 = 1 ; //now it does! num1 = std :: nullopt ; //now it doesn't anymore } What if back() returned an optional? std :: optional < valueType > vector < valueType >:: back (){ if ( empty ()){ return {}; } return * ( begin () + size () - 1 ); } std::optional interface .value() returns the contained value or throws bad_optional_access error .value_or(valueType val) returns the contained value or default value, parameter val .has_value() returns true if contained value exists, false otherwise Checking if an optional has value std :: optional < Student > lookupStudent ( string name ){ //something} std :: optional < Student > output = lookupStudent ( \u201c Keith \u201d ); if ( student ){ cout << output . value (). name << \u201c is from \u201c << output . value (). state << endl ; } else { cout << \u201c No student found \u201d << endl ; } So we have perfect solutions void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back (). has_value () && vec . back (). value () % 2 == 1 ){ vec . pop_back (); } } //Below totally hacky, but totally works, but don't do this! void removeOddsFromEnd ( vector < int >& vec ){ while ( vec . back (). value_or ( 2 ) % 2 == 1 ){ vec . pop_back (); } } Recap: The problem with std::vector::back() Why is it so easy to accidentally call back() on empty vectors if the outcome is so dangerous? The function signature gives us a false promise! Promises to return an something of type valueType But in reality, there either may or may not be a \u201clast element\u201d in a vector std::optional \u201cmonadic\u201d interface (C++23 sneak peek!) .and_then(function f) returns the result of calling f(value) if contained value exists, otherwise null_opt (f must return optional) .transform(function f) returns the result of calling f(value) if contained value exists, otherwise null_opt (f must return optional) .or_else(function f) returns value if it exists, otherwise returns result of calling f Recall: Design Philosophy of C++ Only add features if they solve an actual problem Programmers should be free to choose their own style Compartmentalization is key Allow the programmer full control if they want it Don\u2019t sacrifice performance except as a last resort Enforce safety at compile time whenever possible","title":"std::optional"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#recap-type-safety-and-stdoptional","text":"You can guarantee the behavior of your programs by using a strict type system! std::optional is a tool that could make this happen: you can return either a value or nothing .has_value() .value_or() .value() This can be unwieldy and slow, so cpp doesn\u2019t use optionals in most stl data structures Many languages, however, do! The ball is in your court! \u201cWell typed programs cannot go wrong.\u201d Robert Milner (very important and good CS dude)","title":"Recap: Type Safety and std::optional"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#lec15-raii-smart-pointers-and-c--project-building","text":"","title":"Lec15 RAII, Smart Pointers, and C++  Project Building"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#exceptions---why-care","text":"","title":"Exceptions - Why care?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#how-many-code-paths-are-in-this-function","text":"string get_name_and_print_sweet_tooth ( Person p ) { if ( p . favorite_food () == \"chocolate\" || p . favorite_drink () == \"milkshake\" ) { cout << p . first () << \" \" << p . last () << \" has a sweet tooth!\" << endl ; } return p . first () + \" \" + p . last (); } Code Path 1 - favors neither chocolate nor milkshakes Code Path 2 - favors milkshakes Code Path 3 - favors chocolate (and possibly milkshakes) Are there any more code paths?","title":"How many code paths are in this function?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#hint-exceptions","text":"Exceptions are ways to signal that something has gone wrong during run-time Exceptions are \"thrown\" and can crash the program, but can be \"caught\" to avoid this","title":"Hint: Exceptions"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#hidden-code-paths","text":"There are (at least) 23 code paths in the code before! (1) copy constructor of Person parameter may throw (5) constructor of temp string may throw (6) call to favorite_food, favorite_drink, first (2), last (2), may throw (10) operators may be user-overloaded, thus may throw (1) copy constructor of string for return value may throw","title":"Hidden Code Paths"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#what-could-go-wrong-here","text":"string get_name_and_print_sweet_tooth ( int id_number ) { Person * p = new Person ( id_number ); // assume the constructor fills in variables if ( p -> favorite_food () == \"chocolate\" || p -> favorite_drink () == \"milkshake\" ) { cout << p -> first () << \" \" << p -> last () << \" has a sweet tooth!\" << endl ; } auto result = p -> first () + \" \" + p -> last (); delete p ; //must release!!! return result ; }","title":"What could go wrong here?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#this-problem-isnt-just-unique-to-pointers","text":"Acquire Release Heap memory new delete Files open close Locks try_lock unlock Cockets socket close How do we guarantee resources get released, even if there are exceptions?","title":"This problem isn't just unique to pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#raii","text":"Resource Acquisition Is Initialization","title":"RAII"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#what-is-radouble-i","text":"All resources used by a class should be acquired in the constructor All resources used by a class should be released in the destructor Why? Objects should be usable immediately after creation There should never be a \"half-valid\" state of an object, where it exists in memory but is not accessible to/used by the program The destructor is always called (when the object goes out of scope), so the resource is always freed","title":"What is R\u00b7A\u00b7Double I?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#is-it-raii-compliant","text":"//The following three algorithms are not RALL void printFile () { ifstream input ; input . open ( \"hamlet.txt\" ); string line ; while ( getline ( input , line )) { // might throw exception cout << line << endl ; } input . close (); } void printFile () { ifstream input ( \"hamlet.txt\" ); string line ; while ( getline ( input , line )) { // might throw exception cout << line << endl ; } } void cleanDatabase ( mutex & databaseLock , map < int , int >& database ) { databaseLock . lock (); // other threads will not modify database // modify the database // if exception thrown, mutex never unlocked! databaseLock . unlock (); } This fixes it! void cleanDatabase ( mutex & databaseLock , map < int , int >& database ) { lock_guard < mutex > lg ( databaseLock ); // other threads will not modify database // modify the database // if exception thrown, mutex is unlocked! // no need to unlock at end, as it's handle by the lock_guard } class lock_guard { public : lock_guard ( mutex & lock ) : acquired_lock ( lock ){ acquired_lock . lock (); } ~ lock_guard () { acquired_lock . unlock (); } private : mutex & acquired_lock ; }","title":"Is it RAII Compliant?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#what-about-raii-for-memory","text":"This is where we're going with RAII: from the C++ Core Guidelines: Avoid calling new and delete explicitly","title":"What about RAII for memory?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#smart-pointers","text":"RAII for memory We saw how this was not RAII-compliant because of the \"naked\" delete. string get_name_and_print_sweet_tooth ( int id_number ) { Person * p = new Person ( id_number ); //assume the constructor fills in variables if ( p -> favorite_food () == \"chocolate\" || p -> favorite_drink () == \"milkshake\" ) { cout << p -> first () << \" \" << p -> last () << \" has a sweet tooth!\" << endl ; } auto result = p -> first () + \" \" + p -> last (); delete p ; return result ; }","title":"Smart Pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#solution-built-in-smart-raii-safe-pointers","text":"Three types of smart pointers in C++ that automatically free underlying memory when destructed std::unique_ptr \u2022 Uniquely owns its resource, can't be copied std::shared_ptr \u2022 Can make copies, destructed when underlying memory goes out of scope std::weak_ptr \u2022 models temporary ownership: when an object only needs to be accessed if it exists (convert to shared_ptr to access)","title":"Solution: built-in \"smart\" (RAII-safe) pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#stdunique_ptr","text":"//Before void rawPtrFn () { Node * n = new Node ; // do things with n delete n ; } //After void rawPtrFn () { std :: unique_ptr < Node > n ( new Node ); // do things with n // automatically freed! } what if we wanted to have multiple pointers to the same object? std::shared_ptr","title":"std::unique_ptr"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#stdshared_ptr","text":"Resources can be stored by any number of shared_ptrs The resource is deleted when none of the pointers points to the resource { std :: shared_ptr < int > p1 ( new int ); // use p1 { std :: shared_ptr < int > p2 = p1 ; // use p1 and p2 } // use p1, like so cout << * p1 . get () << endl ; } // the integer is now deallocated!","title":"std::shared_ptr"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#smart-pointers-raii-wrapper-for-pointers","text":"std :: unique_ptr < T > up { new T }; std :: unique_ptr < T > up = std :: make_unique < T > (); std :: shared_ptr < T > sp { new T }; std :: shared_ptr < T > sp = std :: make_shared < T > (); std :: weak_ptr < T > wp = sp ; //A weak_ptr is a container for a raw pointer. It is created as a copy of a shared_ptr. The existence or destruction of weak_ptr copies of a shared_ptr have no effect on the shared_ptr or its other copies. After all copies of a shared_ptr have been destroyed, all weak_ptr copies become empty. // can only be copy/move constructed (or empty)! //So which way is better? //Always use std::make_unique<T>()! std :: unique_ptr < T > up { new T }; std :: unique_ptr < T > up = std :: make_unique < T > (); std :: shared_ptr < T > sp { new T }; std :: shared_ptr < T > sp = std :: make_shared < T > (); If we don't use make_shared, then we're allocating memory twice (once for sp, and once for new T)! We should be consistent across smart pointers","title":"Smart pointers: RAII Wrapper for pointers"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#building-c-projects","text":"What happens when you run our \"./build_and_run.sh\"?","title":"Building C++ Projects"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#what-do-make-and-makefiles-do","text":"make is a \"build system\" uses g++ as its main engine several stages to the compiler system can be utilized through a Makefile! let's take a look at a simple makefile to get some practice!","title":"What do make and Makefiles do?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#so-why-do-we-use-cmake-in-our-assignments","text":"cmake is a cross-platform make cmake creates build systems! It takes in an even higher-level config file, ties in external libraries, and outputs a Makefile, which is then run. Let's take a look at our makefiles!","title":"So why do we use cmake in our assignments?"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#example-cmake-file-cmakeliststxt","text":"cmake_minimum_required ( VERSION 3 .0 ) # \u6307\u5b9a cmake \u6700\u4f4e\u7248\u672c project ( wikiracer ) # \u6307\u5b9a\u9879\u76ee\u540d\u79f0(\u968f\u610f) set ( CMAKE_CXX_STANDARD 17 ) set ( CMAKE_CXX_STANDARD_REQUIRED True ) find_package ( cpr CONFIG REQUIRED ) # adding all files add_executable ( main main.cpp wikiscraper.cpp.o error.cpp ) # \u6307\u5b9a\u7f16\u8bd1\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\uff0cmain\u662f\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8868\u793a\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6587\u4ef6\u540d\uff08\u8fd9\u4e2a\u6587\u4ef6\u540d\u4e5f\u662f\u4efb\u610f\u7684\uff09\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570main.cpp\u5219\u7528\u4e8e\u6307\u5b9a\u6e90\u6587\u4ef6\u3002 target_link_libraries ( main PRIVATE cpr )","title":"Example cmake file (CMakeLists.txt)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#components-of-cs-compilation-system","text":"graph LR A[Preprocessing <br>in: cpp files out: full cpp files]-->B[Compiling <br>in: full cpp files out: .s files]-->C[Assembling <br>in: .s files out: .o files]-->D[Linking<br> in: .o files out: executable]","title":"Components of C++'s compilation system"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#preprocessing-g--e","text":"The C/C++ preprocessor handles preprocessor directives: replaces includes (#include \u2026) and and expands any macros (#define \u2026) Replace #includes with content of respective files (which is usually just function/variable declarations, so low bloat) Replaces macros (#define) and selecting different portions of text depending on #if, #ifdef, #ifndef Outputs a stream of tokens resulting from these transformations If you want, you can produce some errors at even this stage (#if, #error)","title":"Preprocessing (g++ -E)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#compilation-g--s","text":"Performed on output of the preprocessor (full C++ code) Structure of a compiler: Lexical Analysis Parsing Semantic Analysis Optimization Code Generation (assembly code) This is where traditional \"compiler errors\" are caught","title":"Compilation (g++ -S)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#assembling-g--c","text":"Runs on the assembly code as outputted by the compiler Converts assembly code to binary machine code Assumes that all functions are defined somewhere without checking Final output: object files Can't be run by themselves!","title":"Assembling (g++ -c)"},{"location":"CS%E8%AF%BE%E7%A8%8B/CS106L/CS106L%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/#linking-ld-g","text":"Creates a single executable file from multiple object files Combine the pieces of a program Figure out a memory organization so that all the pieces can fit together Resolve references so that the program can run under the new memory organization .h files declare functions, but the actual functions may be in separate files from where they're called! Output is fully self-suficient\u2014no other files needed to run","title":"Linking (ld, g++)"},{"location":"%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/","text":"\u5fae\u4fe1\u516c\u4f17\u53f7\u4f8b\u4f1a\u7b7e\u5230\u63a8\u3002 \u5199\u5728\u524d\u9762 \u00b6 \u6700\u8fd1NovelAi\u7206\u706b\uff0c\u5f88\u591a\u4eba\u5f00\u59cb\u7528\u8fd9\u73a9\u610f\u8fdb\u884c\u81ea\u5df1\u5934\u50cf\u7684\u521b\u4f5c\uff0c\u4e5f\u6709\u5927\u4e00\u7684\u540c\u5b66\u6765\u95ee\u6280\u672f\u7ec4\u8001\u4eba\u80fd\u4e0d\u80fd\u6559\u4e00\u6559\u600e\u4e48\u628a\u81ea\u5df1\u53d8\u6210\u8001\u5a46\uff08bushi\uff09\uff0c\u6240\u4ee5\u8fd9\u671f\u63a8\u6587\u5c31\u6559\u5927\u5bb6\u7528\u4e00\u7528\u8fd9\u4e2a\u201c\u795e\u5947\u201d\u7684\u8f6f\u4ef6\u3002 \u6ce8\u610f\u4e8b\u9879 \u00b6 start\uff01 \u7531\u4e8e\u6bcf\u4e2a\u4eba\u7535\u8111\u4e0d\u4e00\u6837\uff0c\u800c\u4e14\u6709\u516c\u5b50\u5bcc\u5a46\u5728\u7528Mac\u5b66\u4e60\u5de5\u4f5c\uff09\uff0c\u6240\u4ee5\u8fd9\u7bc7\u63a8\u6587\u4e2d\u53ea\u6d89\u53ca\u5728\u7ebf\u521b\u4f5c\uff0c\u5982\u679c\u60f3\u8981\u5c06\u6574\u4e2a\u9879\u76ee\u90e8\u7f72\u5230\u81ea\u5df1\u7684\u7535\u8111/\u670d\u52a1\u5668\u4e0a\uff08\u4e0d\u8981\u5728\u52e4\u521b\u670d\u52a1\u5668\u4e0a\u641e\u8fd9\u4e2a\uff09\uff0c\u8bf7\u81ea\u884c\u53c2\u9605github\u6216\u8005\u5404\u5927\u6559\u5b66\u7f51\u7ad9\uff08Youtube\u3001Bilibili\uff09\u3002 NovelAi \u00b6 \u65e2\u7136\u8fd9\u4e2a\u9879\u76ee\u7684\u706b\u7206\u662f\u7531\u5b83\u5f15\u8d77\u7684\uff0c\u90a3\u6211\u4eec\u81ea\u7136\u4ece\u672c\u4f53\u5f00\u59cb\u8bb2\u89e3\u3002 \u9996\u5148\u8fdb\u5165 \u6709\u624b\u5c31\u4f1a \u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002 \u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002\u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002 \u6309\u7167\u6307\u5f15\u8fdb\u884c\u4e00\u6b65\u6b65\u64cd\u4f5c\uff0c\u81ea\u5df1\u641e\u7740\u73a9\u7684\u8bdd\u53ea\u9700\u8981\u628a\u56fe\u7247\u4e0a\u4f20\u4e0a\u53bb\uff0c\u7136\u540e\u7b49\u5f85\u751f\u6210\u5373\u53ef\u3002 \u4f46\u662f\uff0c\u6211\u4eec\u81ea\u7136\u8981\u8bb2\u70b9\u4e0d\u4e00\u6837\u7684\u4e1c\u897f\uff0c\u5982\u679c\u53ea\u662f\u5355\u7eaf\u4f7f\u7528\u600e\u4e48\u53ef\u4ee5\u5462\uff1f \u6211\u4eec\u53d1\u73b0\uff0c\u8f93\u5165\u4e00\u5f20\u56fe\u7247\uff0c\u5b83\u53ea\u80fd\u8f93\u51fa\u540c\u6837\u7684\u56fe\u7247\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u9700\u8981\u53bb\u5b66\u4e60\u5982\u4f55\u66f4\u6539\u56fe\u7247\u7684\u98ce\u683c\u3002 \u7ed9\u56fe\u7247\u6539\u98ce\u683c\u6709\u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u81ea\u5df1\u642d\u914d\uff0c\u4e00\u79cd\u662f\u6309\u7167\u73b0\u6709\u7684\u6a21\u677f\uff0c\u4e0b\u9762\u5c06\u5206\u522b\u8bb2\u89e3\u3002 https://yun.wafuwafu.com/aliyun/Resources/novelai-naifu \u8fd9\u662f\u6709\u5927\u4f6c\u5206\u4eab\u7684\u5355\u8bcd\u96c6\uff0c\u4f60\u5e0c\u671b\u751f\u6210\u7684\u56fe\u7247\u662f\u4ec0\u4e48\u98ce\u683c\uff0c\u53ea\u9700\u8981\u6309\u7167\u76f8\u5bf9\u7684tag\u8f93\u5165\u8fdb\u53bb\u5c31\u597d\uff0c\u5c3d\u60c5\u53d1\u6325\u4f60\u4eec\u7684\u60f3\u8c61\u529b\uff0c\u505a\u51fa\u66f4\u591a\u7684\u5947\u884c\u79cd\u5427\uff01 tips\uff1a\u4e00\u822c\u6765\u8bf4tag\u81ea\u5df1\u642d\u914d\u8981\u548c\u56fe\u751f\u56fe\u4e00\u8d77\u98df\u7528\uff0c\u5426\u5219AI\u65e0\u6cd5\u8bc6\u522b\u4f60\u60f3\u8981\u4ec0\u4e48\u7684\u65f6\u5019\u505a\u51fa\u7684\u56fe\u5c31\u4f1a\u6bd4\u8f83\u60ca\u8273\u4e86\u3002 \u300a\u5143\u7d20\u6cd5\u5178\u300b \u591a\u4e48\u7f8e\u5999\u7684\u4e00\u672c\u4e66~\u7531SteelPlate\uff08\u7f51\u540d\uff09\u7f16\u7e82\uff0c\u65e8\u5728\u6536\u5f55\u6240\u6709\u8d34\u5427\u4f5c\u54c1\u7fa4\u5185\u7684\u4f18\u8d28tag\u548c\u5143\u7d20\u9b54\u6cd5\u3002\u540c\u65f6\u4ed6\u8fd8\u5236\u4f5c\u4e86\u300a\u4ece\u96f6\u5f00\u59cb\u7684\u9b54\u6cd5\u4e66\u2014\u2014Novel AI \u5165\u95e8\u5bfc\u8bba\u300b\u3002 \u8fd9\u672c\u4e66\u6536\u5f55\u4e86\u76ee\u524d\u51e0\u4e4e\u6240\u6709\u98ce\u683c\u7684ai\u7ed8\u753b\u4f18\u8d28tag\uff0c\u7528\u8fd9\u4e9b\u201c\u9b54\u6cd5\u201d\u4f60\u53ef\u4ee5\u8f7b\u6613\u521b\u4f5c\u51fa\u975e\u5e38\u552f\u7f8e\u7684\u753b\u9762\uff0c\u4f46\u662f\u7531\u4e8e\u8fd9\u672c\u4e66\u7684\u7535\u5b50\u7248\u8fdd\u53cd\u4e86\u817e\u8baf\u516c\u7ea6\uff0c\u6240\u4ee5\u76ee\u524d\u7f16\u8005\u624b\u5934\u6ca1\u6709\u8fd9\u672c\u4e66\u7684\u7535\u5b50\u7248\uff0c\u9700\u8981\u7684\u7c73\u5a1c\u6851\u53ef\u4ee5\u79c1\u6233lhmd\u9886\u53d6\uff09\u3002 \u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u661f\u7a7a\u6cd5~ animeGAN \u00b6 \u66f4\u771f\u5b9e\u7684\u4f53\u9a8c\uff01 \u4e00\u822c\u6765\u8bf4\uff0cNovelAi\u751f\u6210\u7684\u56fe\u7247\u548c\u672c\u4eba\u662f\u4e0d\u592a\u50cf\u7684\uff0c\u5982\u679c\u60f3\u8981\u66f4\u771f\u5b9e\u7684\u7167\u7247\u7ea7\u522b\u7684\u4f53\u9a8c\uff0c\u4e0d\u5982\u6765\u8bd5\u8bd5\u8fd9\u4e2a\u9879\u76ee\uff1aanimeGAN\u3002 https://github.com/TachibanaYoshino/AnimeGAN\u8fd9\u662fgithub\u4e0a\u5f00\u6e90\u7684\u9879\u76ee \uff0c\u4e0d\u8fc7\u5927\u591a\u6570\u4eba\u4e0d\u4f1a\u53bb\u7814\u7a76\u5b83\u3002 \u4ec5\u4ec5\u4f7f\u7528\u7684\u8bdd\u53ef\u4ee5\u8bd5\u8bd5https://animegan.js.org/ \u8fd9\u662f\u4e00\u4e2a\u5728\u7ebf\u7684\u7f16\u8f91\u5668\uff0c\u53ef\u4ee5\u5728\u7ebf\u751f\u6210\u76f8\u5e94\u7684\u56fe\u7247\uff0c\u5efa\u8bae\u4f7f\u7528\u8fd9\u4e2a\u9879\u76ee\u65f6\u4e0a\u4f20\u81ea\u5df1/\u4ed6\u4eba\u7684\u5927\u5934\u7167\uff0c\u5426\u5219\u6548\u679c\u4f1a\u975e\u5e38\u6a21\u7cca\u3002 \u5982\u679c\u5bf9\u539f\u7406\u5f88\u611f\u5174\u8da3\u7684\u8bdd\uff0c\u6b22\u8fce\u5b66\u4e60\uff1a\u300a\u673a\u5668\u5b66\u4e60\u300b\u300a\u6df1\u5ea6\u5b66\u4e60\u300b\u300a\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u300b\u300a\u8ba1\u7b97\u673a\u89c6\u89c9\u300b\u7b49\u76f8\u5173\u8bfe\u7a0b/\u9879\u76ee \u672c\u5468\u7b7e\u5230\u95ee\u9898\uff1a\u731c\u731c\u8fd9\u662f\u8c01\uff1f \u7b54\u6848\u662f\u9a6c\u8001\u5e08 \u2014\u2014(animeGAN )\u5236\u4f5c","title":"11/25\u7b7e\u5230\u63a8"},{"location":"%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/#\u5199\u5728\u524d\u9762","text":"\u6700\u8fd1NovelAi\u7206\u706b\uff0c\u5f88\u591a\u4eba\u5f00\u59cb\u7528\u8fd9\u73a9\u610f\u8fdb\u884c\u81ea\u5df1\u5934\u50cf\u7684\u521b\u4f5c\uff0c\u4e5f\u6709\u5927\u4e00\u7684\u540c\u5b66\u6765\u95ee\u6280\u672f\u7ec4\u8001\u4eba\u80fd\u4e0d\u80fd\u6559\u4e00\u6559\u600e\u4e48\u628a\u81ea\u5df1\u53d8\u6210\u8001\u5a46\uff08bushi\uff09\uff0c\u6240\u4ee5\u8fd9\u671f\u63a8\u6587\u5c31\u6559\u5927\u5bb6\u7528\u4e00\u7528\u8fd9\u4e2a\u201c\u795e\u5947\u201d\u7684\u8f6f\u4ef6\u3002","title":"\u5199\u5728\u524d\u9762"},{"location":"%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/#\u6ce8\u610f\u4e8b\u9879","text":"start\uff01 \u7531\u4e8e\u6bcf\u4e2a\u4eba\u7535\u8111\u4e0d\u4e00\u6837\uff0c\u800c\u4e14\u6709\u516c\u5b50\u5bcc\u5a46\u5728\u7528Mac\u5b66\u4e60\u5de5\u4f5c\uff09\uff0c\u6240\u4ee5\u8fd9\u7bc7\u63a8\u6587\u4e2d\u53ea\u6d89\u53ca\u5728\u7ebf\u521b\u4f5c\uff0c\u5982\u679c\u60f3\u8981\u5c06\u6574\u4e2a\u9879\u76ee\u90e8\u7f72\u5230\u81ea\u5df1\u7684\u7535\u8111/\u670d\u52a1\u5668\u4e0a\uff08\u4e0d\u8981\u5728\u52e4\u521b\u670d\u52a1\u5668\u4e0a\u641e\u8fd9\u4e2a\uff09\uff0c\u8bf7\u81ea\u884c\u53c2\u9605github\u6216\u8005\u5404\u5927\u6559\u5b66\u7f51\u7ad9\uff08Youtube\u3001Bilibili\uff09\u3002","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/#novelai","text":"\u65e2\u7136\u8fd9\u4e2a\u9879\u76ee\u7684\u706b\u7206\u662f\u7531\u5b83\u5f15\u8d77\u7684\uff0c\u90a3\u6211\u4eec\u81ea\u7136\u4ece\u672c\u4f53\u5f00\u59cb\u8bb2\u89e3\u3002 \u9996\u5148\u8fdb\u5165 \u6709\u624b\u5c31\u4f1a \u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002 \u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002\u7cfb\u5217\uff0c\u5728\u98de\u6868AI\u4e0a\u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\uff08\u53ef\u4ee5\u4e0d\u586b\u771f\u5b9e\u59d3\u540d\uff09\uff0c\u70b9\u51fb\u542f\u52a8\u73af\u5883\uff0c\u9009\u62e9\u201c\u9ad8\u7ea7CPU\u201d\u53ca\u4ee5\u4e0a\u7684\u73af\u5883\u3002 \u6309\u7167\u6307\u5f15\u8fdb\u884c\u4e00\u6b65\u6b65\u64cd\u4f5c\uff0c\u81ea\u5df1\u641e\u7740\u73a9\u7684\u8bdd\u53ea\u9700\u8981\u628a\u56fe\u7247\u4e0a\u4f20\u4e0a\u53bb\uff0c\u7136\u540e\u7b49\u5f85\u751f\u6210\u5373\u53ef\u3002 \u4f46\u662f\uff0c\u6211\u4eec\u81ea\u7136\u8981\u8bb2\u70b9\u4e0d\u4e00\u6837\u7684\u4e1c\u897f\uff0c\u5982\u679c\u53ea\u662f\u5355\u7eaf\u4f7f\u7528\u600e\u4e48\u53ef\u4ee5\u5462\uff1f \u6211\u4eec\u53d1\u73b0\uff0c\u8f93\u5165\u4e00\u5f20\u56fe\u7247\uff0c\u5b83\u53ea\u80fd\u8f93\u51fa\u540c\u6837\u7684\u56fe\u7247\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u9700\u8981\u53bb\u5b66\u4e60\u5982\u4f55\u66f4\u6539\u56fe\u7247\u7684\u98ce\u683c\u3002 \u7ed9\u56fe\u7247\u6539\u98ce\u683c\u6709\u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u81ea\u5df1\u642d\u914d\uff0c\u4e00\u79cd\u662f\u6309\u7167\u73b0\u6709\u7684\u6a21\u677f\uff0c\u4e0b\u9762\u5c06\u5206\u522b\u8bb2\u89e3\u3002 https://yun.wafuwafu.com/aliyun/Resources/novelai-naifu \u8fd9\u662f\u6709\u5927\u4f6c\u5206\u4eab\u7684\u5355\u8bcd\u96c6\uff0c\u4f60\u5e0c\u671b\u751f\u6210\u7684\u56fe\u7247\u662f\u4ec0\u4e48\u98ce\u683c\uff0c\u53ea\u9700\u8981\u6309\u7167\u76f8\u5bf9\u7684tag\u8f93\u5165\u8fdb\u53bb\u5c31\u597d\uff0c\u5c3d\u60c5\u53d1\u6325\u4f60\u4eec\u7684\u60f3\u8c61\u529b\uff0c\u505a\u51fa\u66f4\u591a\u7684\u5947\u884c\u79cd\u5427\uff01 tips\uff1a\u4e00\u822c\u6765\u8bf4tag\u81ea\u5df1\u642d\u914d\u8981\u548c\u56fe\u751f\u56fe\u4e00\u8d77\u98df\u7528\uff0c\u5426\u5219AI\u65e0\u6cd5\u8bc6\u522b\u4f60\u60f3\u8981\u4ec0\u4e48\u7684\u65f6\u5019\u505a\u51fa\u7684\u56fe\u5c31\u4f1a\u6bd4\u8f83\u60ca\u8273\u4e86\u3002 \u300a\u5143\u7d20\u6cd5\u5178\u300b \u591a\u4e48\u7f8e\u5999\u7684\u4e00\u672c\u4e66~\u7531SteelPlate\uff08\u7f51\u540d\uff09\u7f16\u7e82\uff0c\u65e8\u5728\u6536\u5f55\u6240\u6709\u8d34\u5427\u4f5c\u54c1\u7fa4\u5185\u7684\u4f18\u8d28tag\u548c\u5143\u7d20\u9b54\u6cd5\u3002\u540c\u65f6\u4ed6\u8fd8\u5236\u4f5c\u4e86\u300a\u4ece\u96f6\u5f00\u59cb\u7684\u9b54\u6cd5\u4e66\u2014\u2014Novel AI \u5165\u95e8\u5bfc\u8bba\u300b\u3002 \u8fd9\u672c\u4e66\u6536\u5f55\u4e86\u76ee\u524d\u51e0\u4e4e\u6240\u6709\u98ce\u683c\u7684ai\u7ed8\u753b\u4f18\u8d28tag\uff0c\u7528\u8fd9\u4e9b\u201c\u9b54\u6cd5\u201d\u4f60\u53ef\u4ee5\u8f7b\u6613\u521b\u4f5c\u51fa\u975e\u5e38\u552f\u7f8e\u7684\u753b\u9762\uff0c\u4f46\u662f\u7531\u4e8e\u8fd9\u672c\u4e66\u7684\u7535\u5b50\u7248\u8fdd\u53cd\u4e86\u817e\u8baf\u516c\u7ea6\uff0c\u6240\u4ee5\u76ee\u524d\u7f16\u8005\u624b\u5934\u6ca1\u6709\u8fd9\u672c\u4e66\u7684\u7535\u5b50\u7248\uff0c\u9700\u8981\u7684\u7c73\u5a1c\u6851\u53ef\u4ee5\u79c1\u6233lhmd\u9886\u53d6\uff09\u3002 \u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u661f\u7a7a\u6cd5~","title":"NovelAi"},{"location":"%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/#animegan","text":"\u66f4\u771f\u5b9e\u7684\u4f53\u9a8c\uff01 \u4e00\u822c\u6765\u8bf4\uff0cNovelAi\u751f\u6210\u7684\u56fe\u7247\u548c\u672c\u4eba\u662f\u4e0d\u592a\u50cf\u7684\uff0c\u5982\u679c\u60f3\u8981\u66f4\u771f\u5b9e\u7684\u7167\u7247\u7ea7\u522b\u7684\u4f53\u9a8c\uff0c\u4e0d\u5982\u6765\u8bd5\u8bd5\u8fd9\u4e2a\u9879\u76ee\uff1aanimeGAN\u3002 https://github.com/TachibanaYoshino/AnimeGAN\u8fd9\u662fgithub\u4e0a\u5f00\u6e90\u7684\u9879\u76ee \uff0c\u4e0d\u8fc7\u5927\u591a\u6570\u4eba\u4e0d\u4f1a\u53bb\u7814\u7a76\u5b83\u3002 \u4ec5\u4ec5\u4f7f\u7528\u7684\u8bdd\u53ef\u4ee5\u8bd5\u8bd5https://animegan.js.org/ \u8fd9\u662f\u4e00\u4e2a\u5728\u7ebf\u7684\u7f16\u8f91\u5668\uff0c\u53ef\u4ee5\u5728\u7ebf\u751f\u6210\u76f8\u5e94\u7684\u56fe\u7247\uff0c\u5efa\u8bae\u4f7f\u7528\u8fd9\u4e2a\u9879\u76ee\u65f6\u4e0a\u4f20\u81ea\u5df1/\u4ed6\u4eba\u7684\u5927\u5934\u7167\uff0c\u5426\u5219\u6548\u679c\u4f1a\u975e\u5e38\u6a21\u7cca\u3002 \u5982\u679c\u5bf9\u539f\u7406\u5f88\u611f\u5174\u8da3\u7684\u8bdd\uff0c\u6b22\u8fce\u5b66\u4e60\uff1a\u300a\u673a\u5668\u5b66\u4e60\u300b\u300a\u6df1\u5ea6\u5b66\u4e60\u300b\u300a\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u300b\u300a\u8ba1\u7b97\u673a\u89c6\u89c9\u300b\u7b49\u76f8\u5173\u8bfe\u7a0b/\u9879\u76ee \u672c\u5468\u7b7e\u5230\u95ee\u9898\uff1a\u731c\u731c\u8fd9\u662f\u8c01\uff1f \u7b54\u6848\u662f\u9a6c\u8001\u5e08 \u2014\u2014(animeGAN )\u5236\u4f5c","title":"animeGAN"},{"location":"%E6%9D%82%E9%A1%B9/Complete-Binary-Search-Tree/","tags":["\u9012\u5f52","c++"],"text":"Complete Binary Search Tree \u00b6 \u200b \u672c\u9898\u91c7\u53d6\u5148\u6392\u5e8f\uff0c\u518d\u5c06\u8fd9\u4e2a\u95ee\u9898\u8f6c\u6362\u4e3a\u4e2d\u5e8f\u904d\u5386\u586b\u6570\u5b57\u7684\u95ee\u9898\uff0c\u7b80\u5316\u4e86\u4ee3\u7801\u3002 #include <stdio.h> int a [ 10005 ], b [ 10005 ], n , flag ; void sort (){ int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { int cnt = 0 ; for ( j = 0 ; j < n - 1 - i ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; cnt = 1 ; } } if ( ! cnt ) break ; } } void inorder ( int i ) { if ( 2 * i <= n ) inorder ( 2 * i ); b [ i ] = a [ flag ]; flag ++ ; if ( 2 * i + 1 <= n ) inorder ( 2 * i + 1 ); } int main () { int i ; scanf ( \"%d\" , & n ); for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } sort (); inorder ( 1 ); for ( i = 1 ; i < n ; i ++ ) { printf ( \"%d \" , b [ i ]); } printf ( \"%d\" , b [ i ]); }","title":"Complete Binary Search Tree"},{"location":"%E6%9D%82%E9%A1%B9/Complete-Binary-Search-Tree/#complete-binary-search-tree","text":"\u200b \u672c\u9898\u91c7\u53d6\u5148\u6392\u5e8f\uff0c\u518d\u5c06\u8fd9\u4e2a\u95ee\u9898\u8f6c\u6362\u4e3a\u4e2d\u5e8f\u904d\u5386\u586b\u6570\u5b57\u7684\u95ee\u9898\uff0c\u7b80\u5316\u4e86\u4ee3\u7801\u3002 #include <stdio.h> int a [ 10005 ], b [ 10005 ], n , flag ; void sort (){ int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { int cnt = 0 ; for ( j = 0 ; j < n - 1 - i ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; cnt = 1 ; } } if ( ! cnt ) break ; } } void inorder ( int i ) { if ( 2 * i <= n ) inorder ( 2 * i ); b [ i ] = a [ flag ]; flag ++ ; if ( 2 * i + 1 <= n ) inorder ( 2 * i + 1 ); } int main () { int i ; scanf ( \"%d\" , & n ); for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } sort (); inorder ( 1 ); for ( i = 1 ; i < n ; i ++ ) { printf ( \"%d \" , b [ i ]); } printf ( \"%d\" , b [ i ]); }","title":"Complete Binary Search Tree"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/","tags":["code","c++"],"text":"fds\u5237\u9898\u8bb0\u5f55 \u00b6 PTA B 1003 \u6211\u8981\u901a\u8fc7! \u00b6 #include <stdio.h> #include <stdlib.h> int main () { int n , k , flag ; char ch ; scanf ( \"%d\" , & n ); getchar (); while ( n -- ) { int a [ 3 ] = { 0 }; k = 0 ; flag = 1 ; while (( ch = getchar ()) != '\\n' ) { if ( ch == 'A' ) a [ k ] ++ ; else if ( ch == 'P' && k == 0 ) k = 1 ; else if ( ch == 'T' && k == 1 ) k = 2 ; else flag = 0 ; } if ( flag && k == 2 && a [ 0 ] * a [ 1 ] == a [ 2 ] && a [ 1 ] != 0 ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; } \u521d\u8bc6dp\uff1a\u4e70\u5356\u80a1\u7968\u6700\u4f73\u65f6\u673a \u00b6 class Solution { public : int maxProfit ( vector < int >& prices ) { int size = prices . size (); int dp [ 30005 ][ 2 ] = { 0 }, i ; dp [ 0 ][ 1 ] =- prices [ 0 ]; for ( i = 1 ; i < size ; i ++ ) { dp [ i ][ 0 ] = ( dp [ i -1 ][ 0 ] > dp [ i -1 ][ 1 ] + prices [ i ]) ? dp [ i -1 ][ 0 ] : dp [ i -1 ][ 1 ] + prices [ i ]; dp [ i ][ 1 ] = ( dp [ i -1 ][ 0 ] - prices [ i ] > dp [ i -1 ][ 1 ]) ? dp [ i -1 ][ 0 ] - prices [ i ] : dp [ i -1 ][ 1 ]; } return dp [ size -1 ][ 0 ]; } }; /*\u6b64\u9898\u5229\u6da6\u7d2f\u52a0\u6cd5\u4e5f\u53ef\u89e3<\u8d2a\u5fc3\u7b97\u6cd5> public int maxProfit(int[] prices) { if (prices == null || prices.length < 2) return 0; int total = 0, index = 0, length = prices.length; while (index < length) { //\u5982\u679c\u80a1\u7968\u4e0b\u8dcc\u5c31\u4e00\u76f4\u627e\uff0c\u76f4\u5230\u627e\u5230\u80a1\u7968\u5f00\u59cb\u4e0a\u6da8\u4e3a\u6b62 while (index < length - 1 && prices[index] >= prices[index + 1]) index++; //\u80a1\u7968\u4e0a\u6da8\u5f00\u59cb\u7684\u503c\uff0c\u4e5f\u5c31\u662f\u8fd9\u6bb5\u65f6\u95f4\u4e0a\u6da8\u7684\u6700\u5c0f\u503c int min = prices[index]; //\u4e00\u76f4\u627e\u5230\u80a1\u7968\u4e0a\u6da8\u7684\u6700\u5927\u503c\u4e3a\u6b62 while (index < length - 1 && prices[index] <= prices[index + 1]) index++; //\u8ba1\u7b97\u8fd9\u6bb5\u4e0a\u6da8\u65f6\u95f4\u7684\u5dee\u503c\uff0c\u7136\u540e\u7d2f\u52a0 total += prices[index++] - min; } return total; }*/ \u5f02\u6216\u8fd0\u7b97\u7684\u5e94\u7528\uff1a\u67e5\u91cd \u00b6 class Solution { public : int singleNumber ( vector < int >& nums ) { int res = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { res = res ^ nums [ i ]; } return res ; } }; \u4f4d\u8fd0\u7b97\u7684\u5e94\u7528\uff1a\u5224\u65ad\u6570\u5b57\u662f\u5426\u91cd\u590d \u00b6 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { int line [ 9 ] = { 0 }; int column [ 9 ] = { 0 }; int block [ 9 ] = { 0 }; int shift = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) continue ; shift = 1 << ( board [ i ][ j ] - '0' ); int k = ( i / 3 ) * 3 + j / 3 ; //\u5982\u679c\u5bf9\u5e94\u7684\u4f4d\u7f6e\u53ea\u8981\u6709\u4e00\u4e2a\u5927\u4e8e0\uff0c\u8bf4\u660e\u6709\u51b2\u7a81\uff0c\u76f4\u63a5\u8fd4\u56defalse if (( column [ i ] & shift ) > 0 || ( line [ j ] & shift ) > 0 || ( block [ k ] & shift ) > 0 ) return false ; column [ i ] |= shift ; line [ j ] |= shift ; block [ k ] |= shift ; } } return true ; } };","title":"code before this website"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/#fds\u5237\u9898\u8bb0\u5f55","text":"","title":"fds\u5237\u9898\u8bb0\u5f55"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/#pta-b-1003-\u6211\u8981\u901a\u8fc7","text":"#include <stdio.h> #include <stdlib.h> int main () { int n , k , flag ; char ch ; scanf ( \"%d\" , & n ); getchar (); while ( n -- ) { int a [ 3 ] = { 0 }; k = 0 ; flag = 1 ; while (( ch = getchar ()) != '\\n' ) { if ( ch == 'A' ) a [ k ] ++ ; else if ( ch == 'P' && k == 0 ) k = 1 ; else if ( ch == 'T' && k == 1 ) k = 2 ; else flag = 0 ; } if ( flag && k == 2 && a [ 0 ] * a [ 1 ] == a [ 2 ] && a [ 1 ] != 0 ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } return 0 ; }","title":"PTA B 1003 \u6211\u8981\u901a\u8fc7!"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/#\u521d\u8bc6dp\u4e70\u5356\u80a1\u7968\u6700\u4f73\u65f6\u673a","text":"class Solution { public : int maxProfit ( vector < int >& prices ) { int size = prices . size (); int dp [ 30005 ][ 2 ] = { 0 }, i ; dp [ 0 ][ 1 ] =- prices [ 0 ]; for ( i = 1 ; i < size ; i ++ ) { dp [ i ][ 0 ] = ( dp [ i -1 ][ 0 ] > dp [ i -1 ][ 1 ] + prices [ i ]) ? dp [ i -1 ][ 0 ] : dp [ i -1 ][ 1 ] + prices [ i ]; dp [ i ][ 1 ] = ( dp [ i -1 ][ 0 ] - prices [ i ] > dp [ i -1 ][ 1 ]) ? dp [ i -1 ][ 0 ] - prices [ i ] : dp [ i -1 ][ 1 ]; } return dp [ size -1 ][ 0 ]; } }; /*\u6b64\u9898\u5229\u6da6\u7d2f\u52a0\u6cd5\u4e5f\u53ef\u89e3<\u8d2a\u5fc3\u7b97\u6cd5> public int maxProfit(int[] prices) { if (prices == null || prices.length < 2) return 0; int total = 0, index = 0, length = prices.length; while (index < length) { //\u5982\u679c\u80a1\u7968\u4e0b\u8dcc\u5c31\u4e00\u76f4\u627e\uff0c\u76f4\u5230\u627e\u5230\u80a1\u7968\u5f00\u59cb\u4e0a\u6da8\u4e3a\u6b62 while (index < length - 1 && prices[index] >= prices[index + 1]) index++; //\u80a1\u7968\u4e0a\u6da8\u5f00\u59cb\u7684\u503c\uff0c\u4e5f\u5c31\u662f\u8fd9\u6bb5\u65f6\u95f4\u4e0a\u6da8\u7684\u6700\u5c0f\u503c int min = prices[index]; //\u4e00\u76f4\u627e\u5230\u80a1\u7968\u4e0a\u6da8\u7684\u6700\u5927\u503c\u4e3a\u6b62 while (index < length - 1 && prices[index] <= prices[index + 1]) index++; //\u8ba1\u7b97\u8fd9\u6bb5\u4e0a\u6da8\u65f6\u95f4\u7684\u5dee\u503c\uff0c\u7136\u540e\u7d2f\u52a0 total += prices[index++] - min; } return total; }*/","title":"\u521d\u8bc6dp\uff1a\u4e70\u5356\u80a1\u7968\u6700\u4f73\u65f6\u673a"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/#\u5f02\u6216\u8fd0\u7b97\u7684\u5e94\u7528\u67e5\u91cd","text":"class Solution { public : int singleNumber ( vector < int >& nums ) { int res = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { res = res ^ nums [ i ]; } return res ; } };","title":"\u5f02\u6216\u8fd0\u7b97\u7684\u5e94\u7528\uff1a\u67e5\u91cd"},{"location":"%E6%9D%82%E9%A1%B9/code-before-this-website/#\u4f4d\u8fd0\u7b97\u7684\u5e94\u7528\u5224\u65ad\u6570\u5b57\u662f\u5426\u91cd\u590d","text":"class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { int line [ 9 ] = { 0 }; int column [ 9 ] = { 0 }; int block [ 9 ] = { 0 }; int shift = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) continue ; shift = 1 << ( board [ i ][ j ] - '0' ); int k = ( i / 3 ) * 3 + j / 3 ; //\u5982\u679c\u5bf9\u5e94\u7684\u4f4d\u7f6e\u53ea\u8981\u6709\u4e00\u4e2a\u5927\u4e8e0\uff0c\u8bf4\u660e\u6709\u51b2\u7a81\uff0c\u76f4\u63a5\u8fd4\u56defalse if (( column [ i ] & shift ) > 0 || ( line [ j ] & shift ) > 0 || ( block [ k ] & shift ) > 0 ) return false ; column [ i ] |= shift ; line [ j ] |= shift ; block [ k ] |= shift ; } } return true ; } };","title":"\u4f4d\u8fd0\u7b97\u7684\u5e94\u7528\uff1a\u5224\u65ad\u6570\u5b57\u662f\u5426\u91cd\u590d"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/","tags":["\u9762\u8bd5","\u4e13\u4e1a\u5206\u6d41"],"text":"Welcome to QC family \u00b6 professional introduction for tech team from:lhmd Let's start! \u4e13\u4e1a\u9009\u62e9 \u00b6 \u4eca\u5e74\u8ba1\u79d1120\u4e2a\u540d\u989d\uff0c\u5de5\u8bbe\u8981\u54ed\u4e86 \u4fe1\u5b89\u4e5f\u6269\u62db\u4e86\uff0c\u4eba\u9ebb\u4e86 \u8ba1\u79d1\u548c\u8f6f\u5de580%\u8bfe\u7a0b\u4e00\u6837\uff0c\u8f6f\u5de5\u6709\u4e00\u4e9bsb\u8bfe\u4e0d\u4fbf\u63cf\u8ff0\uff0c\u8ba1\u79d1have\u786c\u4ef6\u8bfe \u4fe1\u5b89\u57f9\u517b\u65b9\u6848\u5e74\u5e74\u5927\u6539\uff0c\u603b\u4f53\u6765\u8bf4\u5f88\u786c\u6838 \u80fd\u53bb\u8ba1\u79d1\u5c31\u4e0d\u8981\u6765\u8f6f\u5de5 \u8ba1\u79d1\u4e5f\u5728\u8bfe\u6539\uff0c\u4f46\u662f\u662f\u5411\u597d\u7684\u65b9\u5411\uff0c\u8f6f\u5de5\u5728\u6539\u4f46\u6539\u7684\u4e0d\u591a \u4e2a\u4eba\u7b80\u5386 \u00b6 \u7b80\u7ea6 \u57fa\u672c\u4fe1\u606f \u9ad8\u8003\u6210\u7ee9 \u6559\u80b2\u80cc\u666f \u5956\u9879\u8bc1\u4e66 \u81ea\u6211\u8bc4\u4ef7 \u6821\u56ed\u7ecf\u5386 \u4e0d\u8981\u5199\u81ea\u5df1\u7684 \u7f3a\u70b9 \u8f85\u52a9\u6750\u6599 \u00b6 \u8001\u5e08\u4f1a\u770b\u7684 \u6709\u4ec0\u4e48\u5199\u4ec0\u4e48 \u80fd\u5199\u591a\u5c11\u662f\u591a\u5c11 \u548c\u7ade\u8d5b\u672c\u8eab\u6ca1\u4ec0\u4e48\u5173\u7cfb\uff0c\u53ea\u662f\u52a0\u5206\u624b\u6bb5 ~\u9664\u975e\u4f60\u548c\u592a\u5b97\u4e00\u6837\u5f3a ~ \u81ea\u6211\u4ecb\u7ecd \u00b6 \u534a\u5206\u949f\u5230\u4e00\u5206\u534a\uff0c\u6709\u4e09\u4e2a\u6863\u4f4d \u8981\u6709\u81ea\u5df1\u6765\u8fd9\u4e2a\u4e13\u4e1a\u7684\u539f\u56e0 \u6709\u8fc7\u76f8\u5173\u7ecf\u5386\u4e00\u5b9a\u8981\u8bf4 \u7f16\u4e00\u4e2a \u60c5\u611f\u65b9\u9762\u7684\u7406\u7531 () \u81ea\u6211\u4ecb\u7ecd\u4e2d\u63d0\u5230\u7684\u6bcf\u4e00\u4e2a\u8bcd\u4f60\u90fd\u5fc5\u987b\u5f88\u6e05\u695a\u4ed6\u5982\u679c\u7ee7\u7eed\u95ee\u4f60\u4f60\u80fd\u7b54\u4e0a\u6765 \u4e0d\u8981\u592a\u88c5\u5b66\u4e60 \u4e00\u5206\u949f\u5185\u4f20\u8fbe\u66f4\u591a\u8981\u70b9 \u81ea\u6211\u4ecb\u7ecd\u65f6\u6700\u597d\u6bcf\u4e2a\u6559\u6388\u90fd\u770b\u8fc7\u53bb \u7f16\u7a0b\u80fd\u529b\u4e0d\u9519\uff0c\u6570\u5b66\u82f1\u8bed\u597d\uff0c\u672a\u6765\u8003\u8651 \u57fa\u672c\u4e0d\u4f1a\u6709\u82f1\u6587\u81ea\u6211\u4ecb\u7ecd\uff0c\u9047\u5230\u7b97\u4f60\u5012\u9709 example \u00b6 \u5c0a\u656c\u7684\u8001\u5e08\uff1a \u6211\u662f\u5de5\u4fe12119\u73ed\u7684\u738b\u4f1f\u6770\uff0c\u6765\u81ea\u9655\u897f\u897f\u5b89\u3002 \u6211\u5c0f\u5b66\u65f6\u5019\u5b66\u4e60\u8fc7scratch\uff0c\u7b2c\u4e00\u6b21\u5bf9\u8f6f\u4ef6\u611f\u5174\u8da3\u662f\u5728\u521d\u4e2d\u770b\u4e09\u4f53\u65f6\u88ab\u51af\u8bfa\u4f9d\u66fc\u7528\u4eba\u5217\u8ba1\u7b97\u673a\u5236\u4f5c\u7684\u8f6f\u4ef6\u6765\u63a8\u7b97\u4e09\u4f53\u7684\u8fd0\u52a8\u89c4\u5f8b\u6240\u6253\u52a8\uff0c\u89c9\u5f97\u8ba1\u7b97\u673a\u771f\u7684\u5f88\u795e\u5947\uff0c\u4ece\u6b64\u5bf9\u8f6f\u4ef6\u7684\u5174\u8da3\u4fbf\u4e00\u53d1\u4e0d\u53ef\u6536\u62fe\uff0c\u539f\u6765\u751f\u6d3b\u4e2d\u4e30\u5bcc\u591a\u5f69\u7684\u8f6f\u4ef6\u7528\u8fd9\u4e9b\u5c0f\u5c0f\u7684\u4ee3\u7801\u5c31\u80fd\u6253\u51fa\u6765\uff0c\u5bf9\u8f6f\u4ef6\u65b9\u9762\u77e5\u8bc6\u7684\u70ed\u60c5\u4e00\u76f4\u5230\u9ad8\u4e2d\u6bd5\u4e1a\u4e5f\u6ca1\u6709\u8870\u51cf\u534a\u5206\u3002\u6240\u4ee5\u6211\u6bc5\u7136\u9009\u62e9\u4e86\u6d59\u6c5f\u5927\u5b66\uff0c\u6000\u7740\u6700\u521d\u7684\u68a6\u60f3\u6765\u5230\u4e86\u8fd9\u91cc\u3002 \u6211\u5728\u9ad8\u4e2d\u7684\u65f6\u5019\u66fe\u83b7\u5f97\u6570\u5b66\u3001\u82f1\u8bed\u7ade\u8d5b\u4e8c\u7b49\u5956\uff0c\u8fd8\u88ab\u63a8\u4e3e\u4e3a\u9655\u897f\u7701\u4e09\u597d\u5b66\u751f\uff0c\u6709\u826f\u597d\u7684\u6570\u7406\u57fa\u7840\uff0c\u5728\u81ea\u5b66C\u8bed\u8a00\u548c\u5927\u8ba1\u57fa\u7684\u8fc7\u7a0b\u4e2d\u4e5f\u8ba9\u6211\u575a\u5b9a\u4e86\u6765\u5230\u8f6f\u4ef6\u5de5\u7a0b\u4e13\u4e1a\u7684\u4fe1\u5fc3\u3002\u6765\u5230\u5927\u5b66\u540e\uff0c\u6211\u52a0\u5165\u4e86\u8ba1\u7b97\u673a\u5b66\u9662\u5b66\u751f\u4f1a\u548c\u52e4\u521b\u7684\u89c6\u89c9\u4e0e\u6280\u672f\u63a8\u5e7f\u90e8\u7684\u6280\u672f\u7ec4\uff0c\u5728\u4e0e\u540c\u5b66\u548c\u5b66\u957f\u4eec\u7684\u4ea4\u6d41\u4e2d\u953b\u70bc\u4e86\u81ea\u5df1\u7684\u6c9f\u901a\u6280\u5de7\u548c\u903b\u8f91\u601d\u8003\u80fd\u529b\u3002 \u5728\u4ed4\u7ec6\u9605\u8bfb\u8f6f\u4ef6\u5de5\u7a0b\u7684\u57f9\u517b\u65b9\u6848\u548c\u81ea\u5b66\u300a\u8f6f\u4ef6\u5de5\u7a0b\u5bfc\u8bba\u300b\u540e\uff0c\u6211\u53d1\u73b0\u8f6f\u4ef6\u5de5\u7a0b\u786e\u5b9e\u662f\u4e00\u95e8\u9002\u5408\u6211\u5e76\u4e14\u53ef\u4ee5\u8ba9\u6211\u70ed\u7231\u5e76\u4e3a\u4e4b\u594b\u6597\u3001\u94bb\u7814\u7684\u4e13\u4e1a\uff0c\u56e0\u6b64\uff0c\u6211\u5e0c\u671b\u5728\u5927\u5b66\u7684\u56db\u5e74\u4e2d\u53ef\u4ee5\u5728\u8f6f\u4ef6\u5de5\u7a0b\u8fd9\u4e2a\u9886\u57df\u4e2d\u4e0d\u65ad\u94bb\u7814\u4e8e\u63d0\u5347\u81ea\u6211\uff0c\u5728\u672a\u6765\u7684\u67d0\u4e00\u5929\u5b9e\u73b0\u81ea\u5df1\u7684\u7406\u60f3\u3002 \u5927\u5b66\u89c4\u5212\uff1a\u5728\u5927\u5b66\u6253\u597d\u57fa\u7840\uff0c\u4e3b\u52a8\u5b66\u4e60\uff0c\u62d3\u5bbd\u89c6\u91ce\uff0c\u5e76\u53c2\u52a0\u4e00\u4e9b\u8ba1\u7b97\u673a\u6bd4\u8d5b\uff0c\u5b9e\u4e60\u79ef\u7d2f\u7ecf\u9a8c\uff0c\u5e76\u4e89\u53d6\u51fa\u56fd\u4ea4\u6d41\u7684\u673a\u4f1a\u3002\u6bd5\u4e1a\u540e\u4fdd\u7814\u672c\u6821\u6216\u8003\u7814\u3002 \u751f\u6daf\u89c4\u5212\uff1a\u6211\u76ee\u6807\u5728\u79fb\u52a8\u5f00\u53d1\u548c\u524d\u7aef\u9886\u57df\u5de5\u4f5c\uff0c\u5e76\u81f4\u529b\u4e8e\u4e2a\u6027\u5316\u7684SaaS\u9886\u57df\uff0c\u540c\u65f6\u4e3a\u56fd\u5bb6\u201c\u5927\u6570\u636e\u80cc\u666f\u4e0b\u667a\u6167\u653f\u52a1\u7684\u5efa\u8bbe\u201d\u65b9\u5411\u5949\u732e\u81ea\u5df1\u7684\u4e00\u4efd\u529b\u3002 \u4e2a\u4eba\u9648\u8ff0 \u00b6 \u5199\u51fa\u6765\u7684\u4e1c\u897f\u5c3d\u91cf\u6311\u5173\u952e\u8bcd \u6807\u91cd\u70b9 \u4e2a\u4eba\u4f18\u52bf\uff0c\u9009\u62e9\u539f\u56e0\uff0c\u4e2a\u4eba\u5174\u8da3\uff0c\u672a\u6765\u89c4\u5212\uff08\u5177\u4f53\uff09 \u5fd7\u613f\u8bf4\u660e\uff1a\u6ca1\u6709\u5fc5\u8981\u5168\u8ba1\u9662 \u4e00\u4e9btips \u00b6 \u63d0\u524d\u60f3\u597d \u8bdd\u672f \uff0c\u4f8b\u5982\u6211\u5728\u56de\u7b54\u975e\u4e13\u4e1a\u6027\u95ee\u9898\u65f6\u8981\u91cd\u70b9\u7a81\u51fa\u6211\u7684\u54ea\u4e9b\u4f18\u52bf\u8ba9\u9762\u8bd5\u8001\u5e08\u6ce8\u610f\u5230\u6211 \u60f3\u597d\u81ea\u5df1\u88ab\u95ee\u5230\u52a3\u52bf\u600e\u4e48\u56de\u7b54\uff0c\u4e0d\u77e5\u9053\u5c31\u8868\u8fbe\u81ea\u5df1\u5f88\u60f3\u5b66\u7684\u60f3\u6cd5 \u653e\u4e00\u4e2a\u6a21\u677f\uff1a\u6211\u5728\u4e0d\u65ad\u5730\u5b66\u4e60\u4e2d\u4e5f\u53d1\u73b0\u4e86\u81ea\u5df1\u5728\u8ba1\u7b97\u673a\u8bed\u8a00\u7b97\u6cd5\u95ee\u9898\u4e0a\u7684\u4e0d\u8db3\uff0c\u548c\u7ade\u8d5b\u9009\u624b\u4eec\u7684\u5dee\u8ddd\u4e5f\u5728\u6fc0\u52b1\u7740\u6211\u4e0d\u65ad\u5730\u5b66\u4e60\u548c\u8bf7\u6559\uff0c\u6211\u540c\u65f6\u4e5f\u76f8\u4fe1\u53ea\u8981\u4fdd\u6301\u7740\u6211\u7684\u70ed\u7231\u548c\u52aa\u529b\uff0c\u4ee5\u53ca\u5229\u7528\u597d\u6d59\u5927\u7ed9\u6211\u7684\u8d44\u6e90\uff0c\u4f1a\u5728\u6162\u6162\u7684\u81ea\u6211\u78e8\u70bc\u4e2d\u8fbe\u5230\u81ea\u6211\u7684\u8d85\u8d8a\u5e76\u5411\u76ee\u6807\u4e00\u6b65\u4e00\u6b65\u7684\u8fc8\u8fdb\u3002 \u5173\u4e8e\u672a\u6765\u89c4\u5212\uff0c\u53ef\u4ee5 ~\u7f16 \u4e00\u4e2a\u81ea\u5df1\u60f3\u63a2\u7d22\u7684 \u9886\u57df \uff0c\u4f8b\u5982 \u8ba1\u7b97\u673a\u89c6\u89c9 \u3001 \u4eba\u5de5\u667a\u80fd ~\u7b49\u7b49\uff0c\u5728\u81ea\u6211\u4ecb\u7ecd\u548c\u4e2a\u4eba\u9648\u8ff0\u4e2d\u5f15\u5bfc\u8001\u5e08\u5411\u8fd9\u65b9\u9762\u9760\u62e2\uff0c\u638c\u63e1\u8001\u5e08\u4f1a\u95ee\u4f60\u7684\u95ee\u9898\u3002 \u5982\u4e0a\u4e00\u6761\uff0c\u5728\u81ea\u6211\u4ecb\u7ecd\u4e2d\u7559\u7a7a\u5b50 \u591a\u770b\u4ee5\u524d\u7684\u9762\u8bd5\u9898 Markdown\u4e2a\u4eba\u9648\u8ff0\uff1f \u786c\u77e5\u8bc6\u50a8\u5907 \u00b6 \u5173\u4e8e\u7b80\u5386\u548c\u81ea\u6211\u4ecb\u7ecd\u4e2d\u53ef\u4ee5\u8bf4\u7684 \u52e4\u521b \u7684\u524d\u7aef\u77e5\u8bc6\uff0c\u5927\u5bb6\u4e0d\u7528\u62c5\u5fc3\u8001\u5e08\u4f1a\u95ee\u5230 \u7b97\u6cd5\u9898\u4e00\u822c\u4e0d\u4f1a\u95ee\u592a\u96be\uff0c\u6491\u6b7b\u95ee\u5230\u6392\u5e8f\uff0c \u540c\u7ec4\u6709\u4fe1\u7ade\u751f\u9664\u5916 \uff0c\u6709\u65f6\u95f4\u7684\u8bdd\u53ef\u4ee5\u770b\u770b\u300a\u554a\u54c8\u7b97\u6cd5\u300b \u8ba1\u79d1--\u4eba\u5de5\u667a\u80fd\uff0c\u5927\u6570\u636e \u8f6f\u5de5--\u8f6f\u4ef6\u5de5\u7a0b\u5bfc\u8bba \u4fe1\u5b89--\u5bc6\u7801\u5b66 \u5927\u8ba1\u57fa \u901f\u6210 \u5982\u679c\u8fd8\u662f\u5c0f\u767d\u7684\u8bdd\uff0c\u767e\u5ea6\u767e\u79d1\u7528\u8d77\u6765 \u7ec6\u8bfb \u57f9\u517b\u65b9\u6848 \uff01\uff01\uff01 \u8981\u4e86\u89e3\u7684\u786c\u77e5\u8bc6\u4e3e\u6817 \u00b6 \u6570\u636e\u7c7b\u578b \u4e8c\u8fdb\u5236\u79d1\u5b66\u8ba1\u6570\u6cd5 \u53cd\u7801\u8865\u7801 \u5c0f\u6570\u5b58\u50a8 \u6570\u636e\u7ed3\u6784\u57fa\u672c\u77e5\u8bc6\uff08\u554a\u54c8\u7b97\u6cd5\u770b\u8fc7\u7684\u5c31\u79d2\u6740 \u51af\u8bfa\u4f9d\u66fc C\u8bed\u8a00\u57fa\u7840 hb and Tai_zong's time \u00b6 Q&A \u00b6","title":"\u4e13\u4e1a\u5206\u6d41\u5185\u8bad"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#welcome-to-qc-family","text":"professional introduction for tech team from:lhmd Let's start!","title":"Welcome to QC family"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u4e13\u4e1a\u9009\u62e9","text":"\u4eca\u5e74\u8ba1\u79d1120\u4e2a\u540d\u989d\uff0c\u5de5\u8bbe\u8981\u54ed\u4e86 \u4fe1\u5b89\u4e5f\u6269\u62db\u4e86\uff0c\u4eba\u9ebb\u4e86 \u8ba1\u79d1\u548c\u8f6f\u5de580%\u8bfe\u7a0b\u4e00\u6837\uff0c\u8f6f\u5de5\u6709\u4e00\u4e9bsb\u8bfe\u4e0d\u4fbf\u63cf\u8ff0\uff0c\u8ba1\u79d1have\u786c\u4ef6\u8bfe \u4fe1\u5b89\u57f9\u517b\u65b9\u6848\u5e74\u5e74\u5927\u6539\uff0c\u603b\u4f53\u6765\u8bf4\u5f88\u786c\u6838 \u80fd\u53bb\u8ba1\u79d1\u5c31\u4e0d\u8981\u6765\u8f6f\u5de5 \u8ba1\u79d1\u4e5f\u5728\u8bfe\u6539\uff0c\u4f46\u662f\u662f\u5411\u597d\u7684\u65b9\u5411\uff0c\u8f6f\u5de5\u5728\u6539\u4f46\u6539\u7684\u4e0d\u591a","title":"\u4e13\u4e1a\u9009\u62e9"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u4e2a\u4eba\u7b80\u5386","text":"\u7b80\u7ea6 \u57fa\u672c\u4fe1\u606f \u9ad8\u8003\u6210\u7ee9 \u6559\u80b2\u80cc\u666f \u5956\u9879\u8bc1\u4e66 \u81ea\u6211\u8bc4\u4ef7 \u6821\u56ed\u7ecf\u5386 \u4e0d\u8981\u5199\u81ea\u5df1\u7684 \u7f3a\u70b9","title":"\u4e2a\u4eba\u7b80\u5386"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u8f85\u52a9\u6750\u6599","text":"\u8001\u5e08\u4f1a\u770b\u7684 \u6709\u4ec0\u4e48\u5199\u4ec0\u4e48 \u80fd\u5199\u591a\u5c11\u662f\u591a\u5c11 \u548c\u7ade\u8d5b\u672c\u8eab\u6ca1\u4ec0\u4e48\u5173\u7cfb\uff0c\u53ea\u662f\u52a0\u5206\u624b\u6bb5 ~\u9664\u975e\u4f60\u548c\u592a\u5b97\u4e00\u6837\u5f3a ~","title":"\u8f85\u52a9\u6750\u6599"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u81ea\u6211\u4ecb\u7ecd","text":"\u534a\u5206\u949f\u5230\u4e00\u5206\u534a\uff0c\u6709\u4e09\u4e2a\u6863\u4f4d \u8981\u6709\u81ea\u5df1\u6765\u8fd9\u4e2a\u4e13\u4e1a\u7684\u539f\u56e0 \u6709\u8fc7\u76f8\u5173\u7ecf\u5386\u4e00\u5b9a\u8981\u8bf4 \u7f16\u4e00\u4e2a \u60c5\u611f\u65b9\u9762\u7684\u7406\u7531 () \u81ea\u6211\u4ecb\u7ecd\u4e2d\u63d0\u5230\u7684\u6bcf\u4e00\u4e2a\u8bcd\u4f60\u90fd\u5fc5\u987b\u5f88\u6e05\u695a\u4ed6\u5982\u679c\u7ee7\u7eed\u95ee\u4f60\u4f60\u80fd\u7b54\u4e0a\u6765 \u4e0d\u8981\u592a\u88c5\u5b66\u4e60 \u4e00\u5206\u949f\u5185\u4f20\u8fbe\u66f4\u591a\u8981\u70b9 \u81ea\u6211\u4ecb\u7ecd\u65f6\u6700\u597d\u6bcf\u4e2a\u6559\u6388\u90fd\u770b\u8fc7\u53bb \u7f16\u7a0b\u80fd\u529b\u4e0d\u9519\uff0c\u6570\u5b66\u82f1\u8bed\u597d\uff0c\u672a\u6765\u8003\u8651 \u57fa\u672c\u4e0d\u4f1a\u6709\u82f1\u6587\u81ea\u6211\u4ecb\u7ecd\uff0c\u9047\u5230\u7b97\u4f60\u5012\u9709","title":"\u81ea\u6211\u4ecb\u7ecd"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#example","text":"\u5c0a\u656c\u7684\u8001\u5e08\uff1a \u6211\u662f\u5de5\u4fe12119\u73ed\u7684\u738b\u4f1f\u6770\uff0c\u6765\u81ea\u9655\u897f\u897f\u5b89\u3002 \u6211\u5c0f\u5b66\u65f6\u5019\u5b66\u4e60\u8fc7scratch\uff0c\u7b2c\u4e00\u6b21\u5bf9\u8f6f\u4ef6\u611f\u5174\u8da3\u662f\u5728\u521d\u4e2d\u770b\u4e09\u4f53\u65f6\u88ab\u51af\u8bfa\u4f9d\u66fc\u7528\u4eba\u5217\u8ba1\u7b97\u673a\u5236\u4f5c\u7684\u8f6f\u4ef6\u6765\u63a8\u7b97\u4e09\u4f53\u7684\u8fd0\u52a8\u89c4\u5f8b\u6240\u6253\u52a8\uff0c\u89c9\u5f97\u8ba1\u7b97\u673a\u771f\u7684\u5f88\u795e\u5947\uff0c\u4ece\u6b64\u5bf9\u8f6f\u4ef6\u7684\u5174\u8da3\u4fbf\u4e00\u53d1\u4e0d\u53ef\u6536\u62fe\uff0c\u539f\u6765\u751f\u6d3b\u4e2d\u4e30\u5bcc\u591a\u5f69\u7684\u8f6f\u4ef6\u7528\u8fd9\u4e9b\u5c0f\u5c0f\u7684\u4ee3\u7801\u5c31\u80fd\u6253\u51fa\u6765\uff0c\u5bf9\u8f6f\u4ef6\u65b9\u9762\u77e5\u8bc6\u7684\u70ed\u60c5\u4e00\u76f4\u5230\u9ad8\u4e2d\u6bd5\u4e1a\u4e5f\u6ca1\u6709\u8870\u51cf\u534a\u5206\u3002\u6240\u4ee5\u6211\u6bc5\u7136\u9009\u62e9\u4e86\u6d59\u6c5f\u5927\u5b66\uff0c\u6000\u7740\u6700\u521d\u7684\u68a6\u60f3\u6765\u5230\u4e86\u8fd9\u91cc\u3002 \u6211\u5728\u9ad8\u4e2d\u7684\u65f6\u5019\u66fe\u83b7\u5f97\u6570\u5b66\u3001\u82f1\u8bed\u7ade\u8d5b\u4e8c\u7b49\u5956\uff0c\u8fd8\u88ab\u63a8\u4e3e\u4e3a\u9655\u897f\u7701\u4e09\u597d\u5b66\u751f\uff0c\u6709\u826f\u597d\u7684\u6570\u7406\u57fa\u7840\uff0c\u5728\u81ea\u5b66C\u8bed\u8a00\u548c\u5927\u8ba1\u57fa\u7684\u8fc7\u7a0b\u4e2d\u4e5f\u8ba9\u6211\u575a\u5b9a\u4e86\u6765\u5230\u8f6f\u4ef6\u5de5\u7a0b\u4e13\u4e1a\u7684\u4fe1\u5fc3\u3002\u6765\u5230\u5927\u5b66\u540e\uff0c\u6211\u52a0\u5165\u4e86\u8ba1\u7b97\u673a\u5b66\u9662\u5b66\u751f\u4f1a\u548c\u52e4\u521b\u7684\u89c6\u89c9\u4e0e\u6280\u672f\u63a8\u5e7f\u90e8\u7684\u6280\u672f\u7ec4\uff0c\u5728\u4e0e\u540c\u5b66\u548c\u5b66\u957f\u4eec\u7684\u4ea4\u6d41\u4e2d\u953b\u70bc\u4e86\u81ea\u5df1\u7684\u6c9f\u901a\u6280\u5de7\u548c\u903b\u8f91\u601d\u8003\u80fd\u529b\u3002 \u5728\u4ed4\u7ec6\u9605\u8bfb\u8f6f\u4ef6\u5de5\u7a0b\u7684\u57f9\u517b\u65b9\u6848\u548c\u81ea\u5b66\u300a\u8f6f\u4ef6\u5de5\u7a0b\u5bfc\u8bba\u300b\u540e\uff0c\u6211\u53d1\u73b0\u8f6f\u4ef6\u5de5\u7a0b\u786e\u5b9e\u662f\u4e00\u95e8\u9002\u5408\u6211\u5e76\u4e14\u53ef\u4ee5\u8ba9\u6211\u70ed\u7231\u5e76\u4e3a\u4e4b\u594b\u6597\u3001\u94bb\u7814\u7684\u4e13\u4e1a\uff0c\u56e0\u6b64\uff0c\u6211\u5e0c\u671b\u5728\u5927\u5b66\u7684\u56db\u5e74\u4e2d\u53ef\u4ee5\u5728\u8f6f\u4ef6\u5de5\u7a0b\u8fd9\u4e2a\u9886\u57df\u4e2d\u4e0d\u65ad\u94bb\u7814\u4e8e\u63d0\u5347\u81ea\u6211\uff0c\u5728\u672a\u6765\u7684\u67d0\u4e00\u5929\u5b9e\u73b0\u81ea\u5df1\u7684\u7406\u60f3\u3002 \u5927\u5b66\u89c4\u5212\uff1a\u5728\u5927\u5b66\u6253\u597d\u57fa\u7840\uff0c\u4e3b\u52a8\u5b66\u4e60\uff0c\u62d3\u5bbd\u89c6\u91ce\uff0c\u5e76\u53c2\u52a0\u4e00\u4e9b\u8ba1\u7b97\u673a\u6bd4\u8d5b\uff0c\u5b9e\u4e60\u79ef\u7d2f\u7ecf\u9a8c\uff0c\u5e76\u4e89\u53d6\u51fa\u56fd\u4ea4\u6d41\u7684\u673a\u4f1a\u3002\u6bd5\u4e1a\u540e\u4fdd\u7814\u672c\u6821\u6216\u8003\u7814\u3002 \u751f\u6daf\u89c4\u5212\uff1a\u6211\u76ee\u6807\u5728\u79fb\u52a8\u5f00\u53d1\u548c\u524d\u7aef\u9886\u57df\u5de5\u4f5c\uff0c\u5e76\u81f4\u529b\u4e8e\u4e2a\u6027\u5316\u7684SaaS\u9886\u57df\uff0c\u540c\u65f6\u4e3a\u56fd\u5bb6\u201c\u5927\u6570\u636e\u80cc\u666f\u4e0b\u667a\u6167\u653f\u52a1\u7684\u5efa\u8bbe\u201d\u65b9\u5411\u5949\u732e\u81ea\u5df1\u7684\u4e00\u4efd\u529b\u3002","title":"example"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u4e2a\u4eba\u9648\u8ff0","text":"\u5199\u51fa\u6765\u7684\u4e1c\u897f\u5c3d\u91cf\u6311\u5173\u952e\u8bcd \u6807\u91cd\u70b9 \u4e2a\u4eba\u4f18\u52bf\uff0c\u9009\u62e9\u539f\u56e0\uff0c\u4e2a\u4eba\u5174\u8da3\uff0c\u672a\u6765\u89c4\u5212\uff08\u5177\u4f53\uff09 \u5fd7\u613f\u8bf4\u660e\uff1a\u6ca1\u6709\u5fc5\u8981\u5168\u8ba1\u9662","title":"\u4e2a\u4eba\u9648\u8ff0"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u4e00\u4e9btips","text":"\u63d0\u524d\u60f3\u597d \u8bdd\u672f \uff0c\u4f8b\u5982\u6211\u5728\u56de\u7b54\u975e\u4e13\u4e1a\u6027\u95ee\u9898\u65f6\u8981\u91cd\u70b9\u7a81\u51fa\u6211\u7684\u54ea\u4e9b\u4f18\u52bf\u8ba9\u9762\u8bd5\u8001\u5e08\u6ce8\u610f\u5230\u6211 \u60f3\u597d\u81ea\u5df1\u88ab\u95ee\u5230\u52a3\u52bf\u600e\u4e48\u56de\u7b54\uff0c\u4e0d\u77e5\u9053\u5c31\u8868\u8fbe\u81ea\u5df1\u5f88\u60f3\u5b66\u7684\u60f3\u6cd5 \u653e\u4e00\u4e2a\u6a21\u677f\uff1a\u6211\u5728\u4e0d\u65ad\u5730\u5b66\u4e60\u4e2d\u4e5f\u53d1\u73b0\u4e86\u81ea\u5df1\u5728\u8ba1\u7b97\u673a\u8bed\u8a00\u7b97\u6cd5\u95ee\u9898\u4e0a\u7684\u4e0d\u8db3\uff0c\u548c\u7ade\u8d5b\u9009\u624b\u4eec\u7684\u5dee\u8ddd\u4e5f\u5728\u6fc0\u52b1\u7740\u6211\u4e0d\u65ad\u5730\u5b66\u4e60\u548c\u8bf7\u6559\uff0c\u6211\u540c\u65f6\u4e5f\u76f8\u4fe1\u53ea\u8981\u4fdd\u6301\u7740\u6211\u7684\u70ed\u7231\u548c\u52aa\u529b\uff0c\u4ee5\u53ca\u5229\u7528\u597d\u6d59\u5927\u7ed9\u6211\u7684\u8d44\u6e90\uff0c\u4f1a\u5728\u6162\u6162\u7684\u81ea\u6211\u78e8\u70bc\u4e2d\u8fbe\u5230\u81ea\u6211\u7684\u8d85\u8d8a\u5e76\u5411\u76ee\u6807\u4e00\u6b65\u4e00\u6b65\u7684\u8fc8\u8fdb\u3002 \u5173\u4e8e\u672a\u6765\u89c4\u5212\uff0c\u53ef\u4ee5 ~\u7f16 \u4e00\u4e2a\u81ea\u5df1\u60f3\u63a2\u7d22\u7684 \u9886\u57df \uff0c\u4f8b\u5982 \u8ba1\u7b97\u673a\u89c6\u89c9 \u3001 \u4eba\u5de5\u667a\u80fd ~\u7b49\u7b49\uff0c\u5728\u81ea\u6211\u4ecb\u7ecd\u548c\u4e2a\u4eba\u9648\u8ff0\u4e2d\u5f15\u5bfc\u8001\u5e08\u5411\u8fd9\u65b9\u9762\u9760\u62e2\uff0c\u638c\u63e1\u8001\u5e08\u4f1a\u95ee\u4f60\u7684\u95ee\u9898\u3002 \u5982\u4e0a\u4e00\u6761\uff0c\u5728\u81ea\u6211\u4ecb\u7ecd\u4e2d\u7559\u7a7a\u5b50 \u591a\u770b\u4ee5\u524d\u7684\u9762\u8bd5\u9898 Markdown\u4e2a\u4eba\u9648\u8ff0\uff1f","title":"\u4e00\u4e9btips"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u786c\u77e5\u8bc6\u50a8\u5907","text":"\u5173\u4e8e\u7b80\u5386\u548c\u81ea\u6211\u4ecb\u7ecd\u4e2d\u53ef\u4ee5\u8bf4\u7684 \u52e4\u521b \u7684\u524d\u7aef\u77e5\u8bc6\uff0c\u5927\u5bb6\u4e0d\u7528\u62c5\u5fc3\u8001\u5e08\u4f1a\u95ee\u5230 \u7b97\u6cd5\u9898\u4e00\u822c\u4e0d\u4f1a\u95ee\u592a\u96be\uff0c\u6491\u6b7b\u95ee\u5230\u6392\u5e8f\uff0c \u540c\u7ec4\u6709\u4fe1\u7ade\u751f\u9664\u5916 \uff0c\u6709\u65f6\u95f4\u7684\u8bdd\u53ef\u4ee5\u770b\u770b\u300a\u554a\u54c8\u7b97\u6cd5\u300b \u8ba1\u79d1--\u4eba\u5de5\u667a\u80fd\uff0c\u5927\u6570\u636e \u8f6f\u5de5--\u8f6f\u4ef6\u5de5\u7a0b\u5bfc\u8bba \u4fe1\u5b89--\u5bc6\u7801\u5b66 \u5927\u8ba1\u57fa \u901f\u6210 \u5982\u679c\u8fd8\u662f\u5c0f\u767d\u7684\u8bdd\uff0c\u767e\u5ea6\u767e\u79d1\u7528\u8d77\u6765 \u7ec6\u8bfb \u57f9\u517b\u65b9\u6848 \uff01\uff01\uff01","title":"\u786c\u77e5\u8bc6\u50a8\u5907"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#\u8981\u4e86\u89e3\u7684\u786c\u77e5\u8bc6\u4e3e\u6817","text":"\u6570\u636e\u7c7b\u578b \u4e8c\u8fdb\u5236\u79d1\u5b66\u8ba1\u6570\u6cd5 \u53cd\u7801\u8865\u7801 \u5c0f\u6570\u5b58\u50a8 \u6570\u636e\u7ed3\u6784\u57fa\u672c\u77e5\u8bc6\uff08\u554a\u54c8\u7b97\u6cd5\u770b\u8fc7\u7684\u5c31\u79d2\u6740 \u51af\u8bfa\u4f9d\u66fc C\u8bed\u8a00\u57fa\u7840","title":"\u8981\u4e86\u89e3\u7684\u786c\u77e5\u8bc6\u4e3e\u6817"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#hb-and-tai_zongs-time","text":"","title":"hb and Tai_zong's time"},{"location":"%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/#qa","text":"","title":"Q&amp;A"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/","text":"\u7b2c\u4e00\u6b21\u9605\u8bfb\u8ba1\u7b97\u673a\u89c6\u89c9\u76f8\u5173\u9886\u57df\u8bba\u6587\u3002 \u539f\u6587\u94fe\u63a5\uff1a NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis NeRF\u6846\u67b6\u603b\u4f53\u4ecb\u7ecd\u3001\u539f\u7406\u8be6\u89e3\u53ca\u76f8\u5173\u6280\u672f(\u6709\u4e00\u4e9b\u524d\u7f6e\u77e5\u8bc6\u4ecb\u7ecd)\uff1a \u5176\u4ed6\u76f8\u5173\u4ecb\u7ecd\u89c6\u9891\uff08\u672c\u4eba\u5e76\u672a\u89c2\u770b\uff09: NeRF\u6e90\u7801\u89e3\u6790 NeRF\u7cfb\u5217\u516c\u5f00\u8bfe \u4e0b\u9762\u5f00\u59cb\u6b63\u5f0f\u8bba\u6587\u9605\u8bfb\u8bb0\u5f55\uff1a 0 Abstract \u00b6 \u8fd9\u4e2a\u7b97\u6cd5\u7528\u5168\u8fde\u63a5\u6df1\u5ea6\u7f51\u7edc\u6765\u8868\u793a\u573a\u666f\u3002 \u8f93\u5165\uff1a5D\u5750\u6807\uff08\u7a7a\u95f4\u4f4d\u7f6e \\(x,y,z\\) \u548c\u89c2\u5bdf\u65b9\u5411 \\(\u03b8\uff0c\u03c6\\) \uff09 \u8f93\u51fa\uff1a\u6bcf\u4e2a\u7a7a\u95f4\u4f4d\u7f6e\u7684\u4f53\u79ef\u5bc6\u5ea6(volume density)\u548c\u89c6\u666f\u53d1\u5c04\u8f90\u5c04\u5ea6(view-dependent emitted radiance) 1 Introduction \u00b6 \u5c06\u9759\u6001\u573a\u666f\u8868\u793a\u4e3a\u4e00\u4e2a\u8fde\u7eed\u76845D\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u8f93\u51fa\u7a7a\u95f4\u4e2d\u6bcf\u4e2a\u70b9\u7684\u989c\u8272(radiance)\u548c\u5bc6\u5ea6(\u53ef\u7406\u89e3\u4e3a\u4e0d\u900f\u660e\u5ea6)\u3002 \u4ee5\u4e0a\u56fe\u4e3a\u4f8b\uff0c\u5373\u5148\u5c06\u8f93\u5165\u7684100\u5f20\u56fe\u7247\u53d8\u6210\u7b2c\u4e8c\u5f20\u56fe\u7684\u6837\u5b50\uff0c\u627e\u5230\u6bcf\u4e2a\u76f8\u673a\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u7528\u4f53\u6e32\u67d3\u6280\u672f\u6cbf\u5149\u7ebf\u7d2f\u79ef\u8fd9\u4e2a\u573a\u666f\u8868\u793a\u7684\u91c7\u6837\u70b9\u4fe1\u606f\uff0c\u6700\u540e\u4ece\u65b0\u7684\u89c6\u89d2\u6e32\u67d3\u56fe\u50cf\u3002 \u8fd9\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u6d41\u7a0b\u662f\uff1a \u6cbf\u76f8\u673a\u5149\u7ebf\u67e5\u8be25D\u5750\u6807 \u5229\u7528\u795e\u7ecf\u7f51\u7edc\u5408\u6210\u89c6\u56fe \u7528\u4f53\u6e32\u67d3\u6280\u672f\u8f93\u51fa\u989c\u8272\u548c\u5bc6\u5ea6\uff0c\u6295\u5f71\u5230\u56fe\u50cf\u4e2d \u6b64\u7b97\u6cd5\u8fd8\u4f18\u5316\u4e86\u795e\u7ecf\u8f90\u5c04\u573a\uff1a \u200b \u5bf9\u4e8e\u590d\u6742\u573a\u666f\uff0c\u4f18\u5316\u795e\u7ecf\u8f90\u5c04\u573a\u7684\u8868\u793a\u5e76\u6ca1\u6709\u6536\u655b\u5230\u8db3\u591f\u9ad8\u7684\u6e05\u6670\u5ea6\uff0c\u5e76\u4e14\u5728\u6bcf\u4e2a\u6444\u50cf\u673a\u5149\u7ebf\u6240\u9700\u8981\u7684\u91c7\u6837\u6570\u65b9\u9762\u6548\u7387\u4f4e\u4e0b\u3002\u6240\u4ee5\u4f5c\u8005\u8fd8\u4f7f\u7528\u4e86 \u4f4d\u7f6e\u7f16\u7801 \u8f93\u5165\u7684\u5750\u6807\u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002 \u200b \u4f4d\u7f6e\u7f16\u7801\u80fd\u4f7fMLP\u8868\u793a\u9891\u7387\u66f4\u9ad8\u7684\u51fd\u6570\u3002\u4f5c\u8005\u8fd8\u63d0\u51fa\u4e86 \u5206\u5c42\u91c7\u6837\u8fc7\u7a0b \uff0c\u7528\u6765\u51cf\u5c11\u9700\u8981\u7684\u8f93\u5165\u89c6\u56fe\u7684\u4e2a\u6570\u3002 \u603b\u800c\u8a00\u4e4b\uff0c\u8fd9\u4e2a\u7b97\u6cd5\u7684\u6280\u672f\u8d21\u732e\u6709\uff1a \u5c06\u5177\u6709\u590d\u6742\u51e0\u4f55\u548c\u6750\u8d28\u7684\u8fde\u7eed\u573a\u666f\u8868\u73b0\u4e3a5D\u795e\u7ecf\u8f90\u5c04\u573a\uff0c\u53c2\u6570\u5316\u4e3a\u57fa\u672cMLP\u7f51\u7edc\u3002 \u57fa\u4e8e\u7ecf\u5178\u4f53\u6e32\u67d3\u6280\u672f\u7684\u53ef\u5fae\u5206\u6e32\u67d3\u8fc7\u7a0b\uff0c\u5305\u62ec\u5206\u5c42\u91c7\u6837\u7b56\u7565\uff0c\u7528\u4e8e\u5c06MLP\u7684\u5bb9\u91cf\u5206\u914d\u7ed9\u573a\u666f\u4e2d\u7684\u53ef\u89c1\u5185\u5bb9\u3002 \u5c06\u6bcf\u4e2a5D\u7a7a\u95f4\u5750\u6807\u6620\u5c04\u5230\u66f4\u9ad8\u7ef4\u5ea6\u7a7a\u95f4\u7684\u4f4d\u7f6e\u7f16\u7801\uff0c\u6210\u529f\u4f18\u5316\u795e\u7ecf\u8f90\u5c04\u573a\u4ece\u800c\u8868\u793a\u9ad8\u9891\u5185\u5bb9\u3002 \u200b \u6cbf\u7740\u76f8\u673a\u7684\u5149\u7ebf\u91c7\u68375D\u5750\u6807(\u56fea)\uff0c\u5c06\u8fd9\u4e9b\u4fe1\u606f\u8f93\u5165 \\(F_\u03b8\\) \u751f\u6210\u989c\u8272\u548c\u5bc6\u5ea6(\u56feb)\uff0c\u7528\u4f53\u6e32\u67d3\u6280\u672f\u5408\u62102D\u56fe\u50cf(\u56fec)\u3002\u8be5\u6e32\u67d3\u51fd\u6570\u662f\u53ef\u5fae\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6700\u5c0f\u5316\u5408\u6210\u56fe\u50cf\u548cGT\u89c2\u6d4b\u56fe\u50cf\u4e4b\u95f4\u7684error\u6765\u4f18\u5316\u573a\u666f\u8868\u793a(\u56fed)\u3002 2 Related Work \u00b6 \u200b \u56de\u987e\u4e86\u4e00\u4e9b\u8fd9\u9879\u5de5\u4f5c\u6240\u7528\u5230\u7684\u6280\u672f\u548c\u524d\u4eba\u6240\u505a\u7684\u52aa\u529b\u3002 2.1 Neural 3D shape representations \u00b6 \u200b \u901a\u8fc7\u4f18\u5316\u5c06 \\(xyz\\) \u5750\u6807\u6620\u5c04\u5230\u6709\u7b26\u53f7\u8ddd\u79bb\u51fd\u6570\u7684\u6df1\u5c42\u7f51\u7edc\u3002\u4f46\u662f\u8be5\u51fd\u6570\u4ec5\u5141\u8bb8\u4f7f\u75282D\u56fe\u50cf\u4f18\u5316\u795e\u7ecf\u9690\u5f0f\u5f62\u72b6\u8868\u793a\uff0c\u53ea\u80fd\u8868\u793a\u51e0\u4f55\u590d\u6742\u5ea6\u8f83\u4f4e\u7684\u7b80\u5355\u5f62\u72b6\u3002 2.2 View synthesis and image-based rendering \u00b6 mesh\u65b9\u6cd5\uff1a\u57fa\u4e8e\u56fe\u50cf\u91cd\u6295\u5f71\u7684\u57fa\u4e8e\u68af\u5ea6\u7684mesh\u4f18\u5316\u901a\u5e38\u975e\u5e38\u56f0\u96be\uff0c\u5728\u4f18\u5316\u524d\u9700\u8981\u63d0\u4f9b\u5177\u6709\u56fa\u5b9a\u62d3\u6251\u7684\u672b\u73ed\u7f51\u7edc\u4f5c\u4e3a\u521d\u59cb\u5316\u3002\u8fd9\u4e0d\u9002\u7528\u4e8e\u65e0\u7ea6\u675f\u7684\u73b0\u5b9e\u4e16\u754c\u573a\u666f\u3002 \u4f53\u79ef\u65b9\u6cd5\uff1a\u80fd\u8868\u793a\u66f4\u590d\u6742\u7684\u6750\u6599\u548c\u5f62\u72b6\u5e76\u4e14\u9002\u5408\u57fa\u4e8e\u68af\u5ea6\u7684\u4f18\u5316\uff0c\u89c6\u89c9\u5e72\u6270\u4e5f\u66f4\u5c11\uff0c\u73b0\u6709\u7684\u65b9\u6cd5\u65f6\u95f4\u7a7a\u95f4\u590d\u6742\u5ea6\u66f4\u9ad8\u3002\u672c\u6587\u63d0\u51fa\u5728MLP\u7684\u53c2\u6570\u4e2d\u7f16\u7801\u8fde\u7eedvolume\u6765\u89c4\u907f\u8fd9\u4e2a\u95ee\u9898\uff0c\u6e32\u67d3\u8d28\u91cf\u66f4\u9ad8\uff0c\u5b58\u50a8\u6210\u672c\u66f4\u5c0f\u3002 3 Neural Radiance Field Scene Representation \u00b6 \u200b \u672c\u6587\u5c06\u8fde\u7eed\u573a\u666f\u8868\u73b0\u4e3a5D\u5411\u91cf\u503c\u51fd\u6570\u3002\u8f93\u5165\u4e3a5D\u5750\u6807\uff0c\u8f93\u51fa\u4e3a\u6bcf\u4e2a\u70b9\u7684\u989c\u8272 \\(c=(r,g,b)\\) \u548c\u7a7a\u95f4\u5bc6\u5ea6 \\(\u03c3\\) \u3002 \u200b \u5728\u5b9e\u9645\u8868\u73b0\u4e2d\uff0c\u6211\u4eec\u5c06\u89c6\u89d2\u65b9\u5411\u8868\u793a\u4e3a3D\u5411\u91cf \\(d\\) \uff0c\u7528MLP\u7f51\u7edc\u8fd1\u4f3c\u8fd9\u79cd\u8fde\u7eed\u76845D\u573a\u666f\u8868\u793a\u3002 \u200b \u6211\u4eec\u901a\u8fc7\u8ba9\u7f51\u7edc\u628a\u4f53\u79ef\u5bc6\u5ea6\u9884\u6d4b\u4e3a\u4ec5\u4e0e\u4f4d\u7f6e \\(x\\) \u6709\u5173\uff0c\u6765\u4fdd\u8bc1\u8fd9\u79cd\u65b9\u6cd5\u5728\u4e0d\u540c\u89c6\u56fe\u4e0b\u662f\u4e00\u81f4\u7684\u3002 \u200b \u540c\u65f6RGB\u989c\u8272 \\(c\\) \u9884\u6d4b\u4e3a\u4f4d\u7f6e\u548c\u89c2\u5bdf\u65b9\u5411\u7684\u51fd\u6570\uff1a MLP\u9996\u5148\u628a3D\u5750\u6807 \\(x\\) \u901a\u8fc78\u5c42\u5168\u8fde\u63a5\u5c42(\u6fc0\u6d3b\u51fd\u6570\u4e3aReLU\uff0c\u6bcf\u5c42256\u901a\u9053)\uff0c\u8f93\u51fa\u4f53\u79ef\u5bc6\u5ea6 \\(\u03c3\\) \u548c\u4e00\u4e2a256\u7ef4\u7684\u7279\u5f81\u5411\u91cf\u3002 \u5c06\u7279\u5f81\u5411\u91cf\u4e0e\u76f8\u673a\u5149\u7ebf\u7684\u89c2\u5bdf\u65b9\u5411\u8fde\u63a5\u8d77\u6765\uff0c\u4f20\u9012\u5230\u989d\u5916\u7684\u4e00\u4e2a\u5168\u8fde\u63a5\u5c42(\u6fc0\u6d3b\u51fd\u6570\u4e3aReLU\uff0c\u6bcf\u5c42128\u901a\u9053)\uff0c\u8be5\u5c42\u8f93\u51fa\u4e0e\u89c6\u56fe\u76f8\u5173\u7684RGB\u989c\u8272\u3002 \u200b \u663e\u793a\u6765\u81ea\u4e24\u4e2a\u76f8\u673a\u4f4d\u7f6e\u7684\u4e24\u4e2a\u56fa\u5b9a3D\u70b9\u7684\u5916\u89c2\uff0c\u9884\u6d4b\u8fd9\u4e24\u4e2a3D\u70b9\u955c\u9762\u53cd\u5c04\u5916\u89c2\u7684\u53d8\u5316\u5e76\u6301\u7eed\u63a8\u5e7f\u3002 \u200b \u6ca1\u6709\u89c6\u56fe\u4f9d\u8d56\u6027(\u53ea\u6709x\u8f93\u5165)\u8bad\u7ec3\u7684\u6a21\u578b\u96be\u4ee5\u8868\u793a\u955c\u9762\u53cd\u5c04\uff0c\u4f1a\u5bfc\u81f4\u8fc7\u5ea6\u5e73\u6ed1\u7684\u5916\u89c2\u3002 4 Volume Rendering with Radiance Fields \u00b6 \u4f53\u6e32\u67d3\uff1a \u4f53\u6e32\u67d3(Volume Rendering)\u4e0e\u5149\u7ebf\u6295\u5c04(Ray Casting)\u7b97\u6cd5\u8be6\u89e3 alpha\u5408\u6210\uff1a\u56fe\u50cf\u4e0e\u80cc\u666f\u7ed3\u5408\uff0c\u53ef\u4ee5\u4ea7\u751f\u90e8\u5206\u900f\u660e\u6216\u5168\u900f\u660e\u7684\u89c6\u89c9\u6548\u679c\uff0c\u900f\u660e\u5ea6\u7528(0,1)\u8868\u793a alpha\u6df7\u5408\uff1a\u534a\u900f\u660e\u7684\u524d\u666f\u8272\u548c\u80cc\u666f\u7ed3\u5408\u7684\u8fc7\u7a0b\uff0c\u52a0\u6743\u8ba1\u7b97\u3002 $ \\left{ \\begin{array}{**l} out_A & = & src_A + dst_A(1-src_A) \\ out_{RGB} & = & \\frac {(src_{RGB}src_A+dst_{RGB}dst_A(1-src_A))}{out_A} \\ out_A=0 & => & out_{RGB}=0 \\end{array} \\right. $ \u4f53\u5bc6\u5ea6\u5373\u4e3a\u5149\u7ebf\u5728x\u5904\u7ec8\u6b62\u7684\u6982\u7387\uff0c\u76f8\u673a\u5149\u7ebf \\(r_{(t)}=o+td\\) \u7684\u9884\u671f\u989c\u8272\u4e3a\uff1a \\(C_{(r)}\\int_{t_n}^{t_f} T_{(t)}\u03c3(r_{(t)}c(r_{(t)})\uff0cd) dt, where: T_{(t)}=exp(-\\int_{t_n}^{t} \u03c3(r_{(s)}) ds)\\) \\(T_{(t)}\\) \u8868\u793a\u6cbf\u5149\u7ebf\u4ece \\(t_n\\) \u5230 \\(t\\) \u4f20\u64ad\u800c\u4e0d\u649e\u51fb\u4efb\u4f55\u5176\u4ed6\u7c92\u5b50\u7684\u6982\u7387\uff0c\u8fd9\u4e2a \\(T\\) \u53ef\u4ee5\u907f\u514d\u6e32\u67d3\u65f6\u8fc7\u5ea6\u5f15\u5165\u5bf9\u8c61\u80cc\u9762\u7684\u4fe1\u606f\u3002 \u6211\u4eec\u4f7f\u7528\u6570\u503c\u4f30\u8ba1\u8fd9\u4e2a\u8fde\u7eed\u79ef\u5206\u3002\u6211\u4eec\u5c06 \\([t_n,t_f]\\) \u5212\u5206\u4e3a \\(N\\) \u4e2a\u5747\u5300\u95f4\u9694\u7684\u533a\u57df\uff0c\u7136\u540e\u4ece\u6bcf\u4e2a\u533a\u57df\u5185\u5747\u5300\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u91c7\u6837\u70b9\u3002 5 Optimizing a Neural Radiance Field \u00b6 \u200b \u4e0a\u4e00\u8282\u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86\u5c06\u573a\u666f\u5efa\u6a21\u4e3a\u795e\u7ecf\u8f90\u5c04\u573a\u548c\u4ece\u8be5\u8868\u793a\u4e2d\u6e32\u67d3\u65b0\u89c6\u56fe\u6240\u9700\u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u4f46\u662f\u4ecd\u7136\u4e0d\u80fd\u8fbe\u5230\u6700\u9ad8\u7684\u8d28\u91cf\u3002\u56e0\u6b64\uff0c\u9700\u8981\u5f15\u5165\u4e24\u9879\u6539\u8fdb\uff1a \u8f93\u5165\u5750\u6807\u7684\u4f4d\u7f6e\u7f16\u7801\uff0c\u6709\u52a9\u4e8eMLP\u8868\u793a\u9ad8\u9891\u51fd\u6570 \u5206\u5c42\u91c7\u6837\u8fc7\u7a0b\uff0c\u6709\u6548\u5730\u5bf9\u9ad8\u9891\u8fdb\u884c\u91c7\u6837 5.1 \u4f4d\u7f6e\u7f16\u7801(Positional encoding) \u00b6 \u200b \u5c06F \u03b8 \u91cd\u65b0\u8868\u793a\u4e3a\u4e24\u4e2a\u51fd\u6570\u7684\u7ec4\u5408 \\(F_\u03b8=F_{\u03b8}^{'}\u25cb\u03b3\\) \uff0c\u03b3\u662f\u4ece \\(R\\) \u7a7a\u95f4\u5230 \\(R^{2L}\\) \u7a7a\u95f4\u7684\u51fd\u6570\uff0c\u5b9e\u9645\u4e0a \\(F_{\u03b8}^{'}\\) \u8fd8\u662f\u4e00\u4e2aMLP\u3002 \u200b \u5728\u6d41\u884c\u7684Transformer\u67b6\u6784\u4e2d\u4e5f\u4f7f\u7528\u4e86\u7c7b\u4f3c\u7684\u6620\u5c04\uff0c\u5728\u8fd9\u91cc\u5b83\u88ab\u79f0\u4e3a\u4f4d\u7f6e\u7f16\u7801\u3002\u7136\u800c\uff0cTransformers\u5c06\u5176\u7528\u4e8e\u4e00\u4e2a\u4e0d\u540c\u7684\u76ee\u6807\uff0c\u5373\u63d0\u4f9b\u5e8f\u5217\u4e2dtoken\u7684\u79bb\u6563\u4f4d\u7f6e\uff0c\u4f5c\u4e3a\u4e0d\u5305\u542b\u4efb\u4f55\u987a\u5e8f\u6982\u5ff5\u7684\u67b6\u6784\u7684\u8f93\u5165\u3002\u76f8\u53cd\uff0c\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u51fd\u6570\u5c06\u8fde\u7eed\u8f93\u5165\u5750\u6807\u6620\u5c04\u5230\u66f4\u9ad8\u7ef4\u7a7a\u95f4\uff0c\u4ee5\u4f7f\u6211\u4eec\u7684MLP\u66f4\u5bb9\u6613\u903c\u8fd1\u66f4\u9ad8\u9891\u7684\u51fd\u6570\u3002 5.2 \u5206\u5c42\u4f53\u79ef\u91c7\u6837(Hierarchical volume sampling) \u00b6 \u200b \u6e32\u67d3\u7b56\u7565\u662f\u5728\u6bcf\u4e2a\u76f8\u673a\u5149\u7ebf\u7684N\u4e2a\u67e5\u8be2\u70b9\u5904\u5bc6\u96c6\u8bc4\u4f30\u795e\u5c06\u8f90\u5c04\u573a\u7f51\u7edc\uff0c\u8fd9\u79cd\u7b56\u7565\u6548\u7387\u4f4e\u4e0b\uff0c\u6240\u4ee5\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2d\u5206\u5c42\u8868\u793a\u6cd5\uff0c\u901a\u8fc7\u6309\u6700\u7ec8\u6e32\u67d3\u7684\u9884\u671f\u6548\u679c\u6309\u6bd4\u4f8b\u5206\u914d\u91c7\u6837\u70b9\u63d0\u9ad8\u6e32\u67d3\u6548\u7387\u3002 \u200b \u4e0d\u4f7f\u7528\u5355\u4e2a\u795e\u7ecf\u7f51\u7edc\u6765\u8868\u793a\u573a\u666f\uff0c\u800c\u540c\u65f6\u4f18\u5316\u4e24\u4e2a\u795e\u7ecf\u7f51\u7edc\uff1a\"course\"\u548c\"fine\" \u9996\u5148\uff0c\u4f7f\u7528\u57fa\u672c\u7684\u5206\u5c42\u91c7\u6837\u5bf9\u4e00\u7ec4N c \u4e2a\u4f4d\u7f6e\u8fdb\u884c\u91c7\u6837\uff0c\u8bc4\u4f30\u8fd9\u4e9b\u4f4d\u7f6e\u5bf9\u5e94\u7684course\u7f51\u7edc\u3002 \u7136\u540e\u6cbf\u7740\u6bcf\u4e00\u6761\u5149\u7ebf\u751f\u6210\u4e00\u4e2a\u66f4\u5408\u7406\u7684\u70b9\u91c7\u6837\uff0c\u5176\u4e2d\u91c7\u6837\u70b9\u504f\u5411\u4e8e\u4f53\u79ef\u5b58\u5728\u7684\u76f8\u5173\u90e8\u5206\u3002 \u4e3a\u6b64\uff0c\u6211\u4eec\u9996\u5148\u4ececourse\u7f51\u7edc\u751f\u6210\u5408\u6210\u989c\u8272\uff0c\u7136\u540e\u5728\u5149\u7ebf\u4e0a\u91c7\u6837\u4f53\u5bc6\u5ea6\u5927\u7684\u70b9\uff0c\u91c7\u6837N f \u4e2a\u4f5c\u4e3a\u7b2c\u4e8c\u7ec4\u91c7\u6837\u70b9\uff0c\u5728\u7b2c\u4e00\u7ec4\u548c\u7b2c\u4e8c\u7ec4\u91c7\u6837\u7684\u5e76\u96c6\u4e0a\u8ba1\u7b97\"fine\"\u7f51\u7edc\uff0c\u5e76\u8ba1\u7b97\u6700\u7ec8\u7684\u6e32\u67d3\u989c\u8272\u3002 5.3 \u5b9e\u73b0\u7ec6\u8282 \u00b6 \u200b \u6211\u4eec\u4e3a\u6bcf\u4e2a\u573a\u666f\u4f18\u5316\u4e00\u4e2a\u5355\u72ec\u7684\u795e\u7ecf\u8fde\u7eed\u4f53\u79ef\u8868\u793a\u7f51\u7edc\u3002\u9700\u8981\u7684\u53c2\u6570\u6709\uff1aRGB\u56fe\u50cf\u6570\u636e\u96c6\u3001\u76f8\u5e94\u7684\u76f8\u673a\u5916\u53c2\u548c\u5185\u53c2\u4ee5\u53ca\u573a\u666f\u8fb9\u754c\u3002\u5728\u6bcf\u6b21\u4f18\u5316\u8fed\u4ee3\u4e2d\uff0c\u6211\u4eec\u4ece\u6570\u636e\u96c6\u4e2d\u7684\u6240\u6709\u50cf\u7d20\u96c6\u5408\u4e2d\u968f\u673a\u91c7\u6837\u4e00\u6279\u76f8\u673a\u5149\u7ebf\uff0c\u7136\u540e\u6309\u7167 \\(5.2\\) \u4e2d\u7684\u5206\u5c42\u91c7\u6837\u3002\u6700\u540e\u7684\u635f\u5931\u53ea\u662fcourse\u548cfine\u7684\u6e32\u67d3\u50cf\u7d20\u548c\u771f\u5b9e\u50cf\u7d20\u989c\u8272\u4e4b\u95f4\u7684\u5e73\u65b9\u8bef\u5dee\u3002 \u200b \u5176\u4e2d\uff0c \\(R\\) \u4e3abatch\u4e2d\u7684\u5149\u7ebf\u96c6\uff0c \\(C(r),C_{c}(r),C_{f}(r)\\) \u4e3aGT\uff0ccourse\u7f51\u7edc\u9884\u6d4b\uff0cfine\u7f51\u7edc\u9884\u6d4b\u7684RGB\u989c\u8272\u3002 6 Results \u00b6 \u4e24\u79cd\u6570\u636e\u96c6\uff1a Synthetic renderings of objects Real images of complex scenes nerf-pytorch\u4ee3\u7801\u9605\u8bfb\u7b14\u8bb0\uff1a nerf-notes \u4e0a\u624bpytorch\uff1a 60\u5206\u949f\u6559\u4f60\u4e0a\u624bPyTorch + \u8fc1\u79fb\u5b66\u4e60","title":"NeRF"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#0-abstract","text":"\u8fd9\u4e2a\u7b97\u6cd5\u7528\u5168\u8fde\u63a5\u6df1\u5ea6\u7f51\u7edc\u6765\u8868\u793a\u573a\u666f\u3002 \u8f93\u5165\uff1a5D\u5750\u6807\uff08\u7a7a\u95f4\u4f4d\u7f6e \\(x,y,z\\) \u548c\u89c2\u5bdf\u65b9\u5411 \\(\u03b8\uff0c\u03c6\\) \uff09 \u8f93\u51fa\uff1a\u6bcf\u4e2a\u7a7a\u95f4\u4f4d\u7f6e\u7684\u4f53\u79ef\u5bc6\u5ea6(volume density)\u548c\u89c6\u666f\u53d1\u5c04\u8f90\u5c04\u5ea6(view-dependent emitted radiance)","title":"0 Abstract"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#1-introduction","text":"\u5c06\u9759\u6001\u573a\u666f\u8868\u793a\u4e3a\u4e00\u4e2a\u8fde\u7eed\u76845D\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u8f93\u51fa\u7a7a\u95f4\u4e2d\u6bcf\u4e2a\u70b9\u7684\u989c\u8272(radiance)\u548c\u5bc6\u5ea6(\u53ef\u7406\u89e3\u4e3a\u4e0d\u900f\u660e\u5ea6)\u3002 \u4ee5\u4e0a\u56fe\u4e3a\u4f8b\uff0c\u5373\u5148\u5c06\u8f93\u5165\u7684100\u5f20\u56fe\u7247\u53d8\u6210\u7b2c\u4e8c\u5f20\u56fe\u7684\u6837\u5b50\uff0c\u627e\u5230\u6bcf\u4e2a\u76f8\u673a\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u7528\u4f53\u6e32\u67d3\u6280\u672f\u6cbf\u5149\u7ebf\u7d2f\u79ef\u8fd9\u4e2a\u573a\u666f\u8868\u793a\u7684\u91c7\u6837\u70b9\u4fe1\u606f\uff0c\u6700\u540e\u4ece\u65b0\u7684\u89c6\u89d2\u6e32\u67d3\u56fe\u50cf\u3002 \u8fd9\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u6d41\u7a0b\u662f\uff1a \u6cbf\u76f8\u673a\u5149\u7ebf\u67e5\u8be25D\u5750\u6807 \u5229\u7528\u795e\u7ecf\u7f51\u7edc\u5408\u6210\u89c6\u56fe \u7528\u4f53\u6e32\u67d3\u6280\u672f\u8f93\u51fa\u989c\u8272\u548c\u5bc6\u5ea6\uff0c\u6295\u5f71\u5230\u56fe\u50cf\u4e2d \u6b64\u7b97\u6cd5\u8fd8\u4f18\u5316\u4e86\u795e\u7ecf\u8f90\u5c04\u573a\uff1a \u200b \u5bf9\u4e8e\u590d\u6742\u573a\u666f\uff0c\u4f18\u5316\u795e\u7ecf\u8f90\u5c04\u573a\u7684\u8868\u793a\u5e76\u6ca1\u6709\u6536\u655b\u5230\u8db3\u591f\u9ad8\u7684\u6e05\u6670\u5ea6\uff0c\u5e76\u4e14\u5728\u6bcf\u4e2a\u6444\u50cf\u673a\u5149\u7ebf\u6240\u9700\u8981\u7684\u91c7\u6837\u6570\u65b9\u9762\u6548\u7387\u4f4e\u4e0b\u3002\u6240\u4ee5\u4f5c\u8005\u8fd8\u4f7f\u7528\u4e86 \u4f4d\u7f6e\u7f16\u7801 \u8f93\u5165\u7684\u5750\u6807\u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002 \u200b \u4f4d\u7f6e\u7f16\u7801\u80fd\u4f7fMLP\u8868\u793a\u9891\u7387\u66f4\u9ad8\u7684\u51fd\u6570\u3002\u4f5c\u8005\u8fd8\u63d0\u51fa\u4e86 \u5206\u5c42\u91c7\u6837\u8fc7\u7a0b \uff0c\u7528\u6765\u51cf\u5c11\u9700\u8981\u7684\u8f93\u5165\u89c6\u56fe\u7684\u4e2a\u6570\u3002 \u603b\u800c\u8a00\u4e4b\uff0c\u8fd9\u4e2a\u7b97\u6cd5\u7684\u6280\u672f\u8d21\u732e\u6709\uff1a \u5c06\u5177\u6709\u590d\u6742\u51e0\u4f55\u548c\u6750\u8d28\u7684\u8fde\u7eed\u573a\u666f\u8868\u73b0\u4e3a5D\u795e\u7ecf\u8f90\u5c04\u573a\uff0c\u53c2\u6570\u5316\u4e3a\u57fa\u672cMLP\u7f51\u7edc\u3002 \u57fa\u4e8e\u7ecf\u5178\u4f53\u6e32\u67d3\u6280\u672f\u7684\u53ef\u5fae\u5206\u6e32\u67d3\u8fc7\u7a0b\uff0c\u5305\u62ec\u5206\u5c42\u91c7\u6837\u7b56\u7565\uff0c\u7528\u4e8e\u5c06MLP\u7684\u5bb9\u91cf\u5206\u914d\u7ed9\u573a\u666f\u4e2d\u7684\u53ef\u89c1\u5185\u5bb9\u3002 \u5c06\u6bcf\u4e2a5D\u7a7a\u95f4\u5750\u6807\u6620\u5c04\u5230\u66f4\u9ad8\u7ef4\u5ea6\u7a7a\u95f4\u7684\u4f4d\u7f6e\u7f16\u7801\uff0c\u6210\u529f\u4f18\u5316\u795e\u7ecf\u8f90\u5c04\u573a\u4ece\u800c\u8868\u793a\u9ad8\u9891\u5185\u5bb9\u3002 \u200b \u6cbf\u7740\u76f8\u673a\u7684\u5149\u7ebf\u91c7\u68375D\u5750\u6807(\u56fea)\uff0c\u5c06\u8fd9\u4e9b\u4fe1\u606f\u8f93\u5165 \\(F_\u03b8\\) \u751f\u6210\u989c\u8272\u548c\u5bc6\u5ea6(\u56feb)\uff0c\u7528\u4f53\u6e32\u67d3\u6280\u672f\u5408\u62102D\u56fe\u50cf(\u56fec)\u3002\u8be5\u6e32\u67d3\u51fd\u6570\u662f\u53ef\u5fae\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6700\u5c0f\u5316\u5408\u6210\u56fe\u50cf\u548cGT\u89c2\u6d4b\u56fe\u50cf\u4e4b\u95f4\u7684error\u6765\u4f18\u5316\u573a\u666f\u8868\u793a(\u56fed)\u3002","title":"1 Introduction"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#2-related-work","text":"\u200b \u56de\u987e\u4e86\u4e00\u4e9b\u8fd9\u9879\u5de5\u4f5c\u6240\u7528\u5230\u7684\u6280\u672f\u548c\u524d\u4eba\u6240\u505a\u7684\u52aa\u529b\u3002","title":"2 Related Work"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#21-neural-3d-shape-representations","text":"\u200b \u901a\u8fc7\u4f18\u5316\u5c06 \\(xyz\\) \u5750\u6807\u6620\u5c04\u5230\u6709\u7b26\u53f7\u8ddd\u79bb\u51fd\u6570\u7684\u6df1\u5c42\u7f51\u7edc\u3002\u4f46\u662f\u8be5\u51fd\u6570\u4ec5\u5141\u8bb8\u4f7f\u75282D\u56fe\u50cf\u4f18\u5316\u795e\u7ecf\u9690\u5f0f\u5f62\u72b6\u8868\u793a\uff0c\u53ea\u80fd\u8868\u793a\u51e0\u4f55\u590d\u6742\u5ea6\u8f83\u4f4e\u7684\u7b80\u5355\u5f62\u72b6\u3002","title":"2.1 Neural 3D shape representations"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#22-view-synthesis-and-image-based-rendering","text":"mesh\u65b9\u6cd5\uff1a\u57fa\u4e8e\u56fe\u50cf\u91cd\u6295\u5f71\u7684\u57fa\u4e8e\u68af\u5ea6\u7684mesh\u4f18\u5316\u901a\u5e38\u975e\u5e38\u56f0\u96be\uff0c\u5728\u4f18\u5316\u524d\u9700\u8981\u63d0\u4f9b\u5177\u6709\u56fa\u5b9a\u62d3\u6251\u7684\u672b\u73ed\u7f51\u7edc\u4f5c\u4e3a\u521d\u59cb\u5316\u3002\u8fd9\u4e0d\u9002\u7528\u4e8e\u65e0\u7ea6\u675f\u7684\u73b0\u5b9e\u4e16\u754c\u573a\u666f\u3002 \u4f53\u79ef\u65b9\u6cd5\uff1a\u80fd\u8868\u793a\u66f4\u590d\u6742\u7684\u6750\u6599\u548c\u5f62\u72b6\u5e76\u4e14\u9002\u5408\u57fa\u4e8e\u68af\u5ea6\u7684\u4f18\u5316\uff0c\u89c6\u89c9\u5e72\u6270\u4e5f\u66f4\u5c11\uff0c\u73b0\u6709\u7684\u65b9\u6cd5\u65f6\u95f4\u7a7a\u95f4\u590d\u6742\u5ea6\u66f4\u9ad8\u3002\u672c\u6587\u63d0\u51fa\u5728MLP\u7684\u53c2\u6570\u4e2d\u7f16\u7801\u8fde\u7eedvolume\u6765\u89c4\u907f\u8fd9\u4e2a\u95ee\u9898\uff0c\u6e32\u67d3\u8d28\u91cf\u66f4\u9ad8\uff0c\u5b58\u50a8\u6210\u672c\u66f4\u5c0f\u3002","title":"2.2 View synthesis and image-based rendering"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#3-neural-radiance-field-scene-representation","text":"\u200b \u672c\u6587\u5c06\u8fde\u7eed\u573a\u666f\u8868\u73b0\u4e3a5D\u5411\u91cf\u503c\u51fd\u6570\u3002\u8f93\u5165\u4e3a5D\u5750\u6807\uff0c\u8f93\u51fa\u4e3a\u6bcf\u4e2a\u70b9\u7684\u989c\u8272 \\(c=(r,g,b)\\) \u548c\u7a7a\u95f4\u5bc6\u5ea6 \\(\u03c3\\) \u3002 \u200b \u5728\u5b9e\u9645\u8868\u73b0\u4e2d\uff0c\u6211\u4eec\u5c06\u89c6\u89d2\u65b9\u5411\u8868\u793a\u4e3a3D\u5411\u91cf \\(d\\) \uff0c\u7528MLP\u7f51\u7edc\u8fd1\u4f3c\u8fd9\u79cd\u8fde\u7eed\u76845D\u573a\u666f\u8868\u793a\u3002 \u200b \u6211\u4eec\u901a\u8fc7\u8ba9\u7f51\u7edc\u628a\u4f53\u79ef\u5bc6\u5ea6\u9884\u6d4b\u4e3a\u4ec5\u4e0e\u4f4d\u7f6e \\(x\\) \u6709\u5173\uff0c\u6765\u4fdd\u8bc1\u8fd9\u79cd\u65b9\u6cd5\u5728\u4e0d\u540c\u89c6\u56fe\u4e0b\u662f\u4e00\u81f4\u7684\u3002 \u200b \u540c\u65f6RGB\u989c\u8272 \\(c\\) \u9884\u6d4b\u4e3a\u4f4d\u7f6e\u548c\u89c2\u5bdf\u65b9\u5411\u7684\u51fd\u6570\uff1a MLP\u9996\u5148\u628a3D\u5750\u6807 \\(x\\) \u901a\u8fc78\u5c42\u5168\u8fde\u63a5\u5c42(\u6fc0\u6d3b\u51fd\u6570\u4e3aReLU\uff0c\u6bcf\u5c42256\u901a\u9053)\uff0c\u8f93\u51fa\u4f53\u79ef\u5bc6\u5ea6 \\(\u03c3\\) \u548c\u4e00\u4e2a256\u7ef4\u7684\u7279\u5f81\u5411\u91cf\u3002 \u5c06\u7279\u5f81\u5411\u91cf\u4e0e\u76f8\u673a\u5149\u7ebf\u7684\u89c2\u5bdf\u65b9\u5411\u8fde\u63a5\u8d77\u6765\uff0c\u4f20\u9012\u5230\u989d\u5916\u7684\u4e00\u4e2a\u5168\u8fde\u63a5\u5c42(\u6fc0\u6d3b\u51fd\u6570\u4e3aReLU\uff0c\u6bcf\u5c42128\u901a\u9053)\uff0c\u8be5\u5c42\u8f93\u51fa\u4e0e\u89c6\u56fe\u76f8\u5173\u7684RGB\u989c\u8272\u3002 \u200b \u663e\u793a\u6765\u81ea\u4e24\u4e2a\u76f8\u673a\u4f4d\u7f6e\u7684\u4e24\u4e2a\u56fa\u5b9a3D\u70b9\u7684\u5916\u89c2\uff0c\u9884\u6d4b\u8fd9\u4e24\u4e2a3D\u70b9\u955c\u9762\u53cd\u5c04\u5916\u89c2\u7684\u53d8\u5316\u5e76\u6301\u7eed\u63a8\u5e7f\u3002 \u200b \u6ca1\u6709\u89c6\u56fe\u4f9d\u8d56\u6027(\u53ea\u6709x\u8f93\u5165)\u8bad\u7ec3\u7684\u6a21\u578b\u96be\u4ee5\u8868\u793a\u955c\u9762\u53cd\u5c04\uff0c\u4f1a\u5bfc\u81f4\u8fc7\u5ea6\u5e73\u6ed1\u7684\u5916\u89c2\u3002","title":"3 Neural Radiance Field Scene Representation"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#4-volume-rendering-with-radiance-fields","text":"\u4f53\u6e32\u67d3\uff1a \u4f53\u6e32\u67d3(Volume Rendering)\u4e0e\u5149\u7ebf\u6295\u5c04(Ray Casting)\u7b97\u6cd5\u8be6\u89e3 alpha\u5408\u6210\uff1a\u56fe\u50cf\u4e0e\u80cc\u666f\u7ed3\u5408\uff0c\u53ef\u4ee5\u4ea7\u751f\u90e8\u5206\u900f\u660e\u6216\u5168\u900f\u660e\u7684\u89c6\u89c9\u6548\u679c\uff0c\u900f\u660e\u5ea6\u7528(0,1)\u8868\u793a alpha\u6df7\u5408\uff1a\u534a\u900f\u660e\u7684\u524d\u666f\u8272\u548c\u80cc\u666f\u7ed3\u5408\u7684\u8fc7\u7a0b\uff0c\u52a0\u6743\u8ba1\u7b97\u3002 $ \\left{ \\begin{array}{**l} out_A & = & src_A + dst_A(1-src_A) \\ out_{RGB} & = & \\frac {(src_{RGB}src_A+dst_{RGB}dst_A(1-src_A))}{out_A} \\ out_A=0 & => & out_{RGB}=0 \\end{array} \\right. $ \u4f53\u5bc6\u5ea6\u5373\u4e3a\u5149\u7ebf\u5728x\u5904\u7ec8\u6b62\u7684\u6982\u7387\uff0c\u76f8\u673a\u5149\u7ebf \\(r_{(t)}=o+td\\) \u7684\u9884\u671f\u989c\u8272\u4e3a\uff1a \\(C_{(r)}\\int_{t_n}^{t_f} T_{(t)}\u03c3(r_{(t)}c(r_{(t)})\uff0cd) dt, where: T_{(t)}=exp(-\\int_{t_n}^{t} \u03c3(r_{(s)}) ds)\\) \\(T_{(t)}\\) \u8868\u793a\u6cbf\u5149\u7ebf\u4ece \\(t_n\\) \u5230 \\(t\\) \u4f20\u64ad\u800c\u4e0d\u649e\u51fb\u4efb\u4f55\u5176\u4ed6\u7c92\u5b50\u7684\u6982\u7387\uff0c\u8fd9\u4e2a \\(T\\) \u53ef\u4ee5\u907f\u514d\u6e32\u67d3\u65f6\u8fc7\u5ea6\u5f15\u5165\u5bf9\u8c61\u80cc\u9762\u7684\u4fe1\u606f\u3002 \u6211\u4eec\u4f7f\u7528\u6570\u503c\u4f30\u8ba1\u8fd9\u4e2a\u8fde\u7eed\u79ef\u5206\u3002\u6211\u4eec\u5c06 \\([t_n,t_f]\\) \u5212\u5206\u4e3a \\(N\\) \u4e2a\u5747\u5300\u95f4\u9694\u7684\u533a\u57df\uff0c\u7136\u540e\u4ece\u6bcf\u4e2a\u533a\u57df\u5185\u5747\u5300\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u91c7\u6837\u70b9\u3002","title":"4 Volume Rendering with Radiance Fields"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#5-optimizing-a-neural-radiance-field","text":"\u200b \u4e0a\u4e00\u8282\u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86\u5c06\u573a\u666f\u5efa\u6a21\u4e3a\u795e\u7ecf\u8f90\u5c04\u573a\u548c\u4ece\u8be5\u8868\u793a\u4e2d\u6e32\u67d3\u65b0\u89c6\u56fe\u6240\u9700\u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u4f46\u662f\u4ecd\u7136\u4e0d\u80fd\u8fbe\u5230\u6700\u9ad8\u7684\u8d28\u91cf\u3002\u56e0\u6b64\uff0c\u9700\u8981\u5f15\u5165\u4e24\u9879\u6539\u8fdb\uff1a \u8f93\u5165\u5750\u6807\u7684\u4f4d\u7f6e\u7f16\u7801\uff0c\u6709\u52a9\u4e8eMLP\u8868\u793a\u9ad8\u9891\u51fd\u6570 \u5206\u5c42\u91c7\u6837\u8fc7\u7a0b\uff0c\u6709\u6548\u5730\u5bf9\u9ad8\u9891\u8fdb\u884c\u91c7\u6837","title":"5 Optimizing a Neural Radiance Field"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#51-\u4f4d\u7f6e\u7f16\u7801positional-encoding","text":"\u200b \u5c06F \u03b8 \u91cd\u65b0\u8868\u793a\u4e3a\u4e24\u4e2a\u51fd\u6570\u7684\u7ec4\u5408 \\(F_\u03b8=F_{\u03b8}^{'}\u25cb\u03b3\\) \uff0c\u03b3\u662f\u4ece \\(R\\) \u7a7a\u95f4\u5230 \\(R^{2L}\\) \u7a7a\u95f4\u7684\u51fd\u6570\uff0c\u5b9e\u9645\u4e0a \\(F_{\u03b8}^{'}\\) \u8fd8\u662f\u4e00\u4e2aMLP\u3002 \u200b \u5728\u6d41\u884c\u7684Transformer\u67b6\u6784\u4e2d\u4e5f\u4f7f\u7528\u4e86\u7c7b\u4f3c\u7684\u6620\u5c04\uff0c\u5728\u8fd9\u91cc\u5b83\u88ab\u79f0\u4e3a\u4f4d\u7f6e\u7f16\u7801\u3002\u7136\u800c\uff0cTransformers\u5c06\u5176\u7528\u4e8e\u4e00\u4e2a\u4e0d\u540c\u7684\u76ee\u6807\uff0c\u5373\u63d0\u4f9b\u5e8f\u5217\u4e2dtoken\u7684\u79bb\u6563\u4f4d\u7f6e\uff0c\u4f5c\u4e3a\u4e0d\u5305\u542b\u4efb\u4f55\u987a\u5e8f\u6982\u5ff5\u7684\u67b6\u6784\u7684\u8f93\u5165\u3002\u76f8\u53cd\uff0c\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u51fd\u6570\u5c06\u8fde\u7eed\u8f93\u5165\u5750\u6807\u6620\u5c04\u5230\u66f4\u9ad8\u7ef4\u7a7a\u95f4\uff0c\u4ee5\u4f7f\u6211\u4eec\u7684MLP\u66f4\u5bb9\u6613\u903c\u8fd1\u66f4\u9ad8\u9891\u7684\u51fd\u6570\u3002","title":"5.1 \u4f4d\u7f6e\u7f16\u7801(Positional encoding)"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#52-\u5206\u5c42\u4f53\u79ef\u91c7\u6837hierarchical-volume-sampling","text":"\u200b \u6e32\u67d3\u7b56\u7565\u662f\u5728\u6bcf\u4e2a\u76f8\u673a\u5149\u7ebf\u7684N\u4e2a\u67e5\u8be2\u70b9\u5904\u5bc6\u96c6\u8bc4\u4f30\u795e\u5c06\u8f90\u5c04\u573a\u7f51\u7edc\uff0c\u8fd9\u79cd\u7b56\u7565\u6548\u7387\u4f4e\u4e0b\uff0c\u6240\u4ee5\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2d\u5206\u5c42\u8868\u793a\u6cd5\uff0c\u901a\u8fc7\u6309\u6700\u7ec8\u6e32\u67d3\u7684\u9884\u671f\u6548\u679c\u6309\u6bd4\u4f8b\u5206\u914d\u91c7\u6837\u70b9\u63d0\u9ad8\u6e32\u67d3\u6548\u7387\u3002 \u200b \u4e0d\u4f7f\u7528\u5355\u4e2a\u795e\u7ecf\u7f51\u7edc\u6765\u8868\u793a\u573a\u666f\uff0c\u800c\u540c\u65f6\u4f18\u5316\u4e24\u4e2a\u795e\u7ecf\u7f51\u7edc\uff1a\"course\"\u548c\"fine\" \u9996\u5148\uff0c\u4f7f\u7528\u57fa\u672c\u7684\u5206\u5c42\u91c7\u6837\u5bf9\u4e00\u7ec4N c \u4e2a\u4f4d\u7f6e\u8fdb\u884c\u91c7\u6837\uff0c\u8bc4\u4f30\u8fd9\u4e9b\u4f4d\u7f6e\u5bf9\u5e94\u7684course\u7f51\u7edc\u3002 \u7136\u540e\u6cbf\u7740\u6bcf\u4e00\u6761\u5149\u7ebf\u751f\u6210\u4e00\u4e2a\u66f4\u5408\u7406\u7684\u70b9\u91c7\u6837\uff0c\u5176\u4e2d\u91c7\u6837\u70b9\u504f\u5411\u4e8e\u4f53\u79ef\u5b58\u5728\u7684\u76f8\u5173\u90e8\u5206\u3002 \u4e3a\u6b64\uff0c\u6211\u4eec\u9996\u5148\u4ececourse\u7f51\u7edc\u751f\u6210\u5408\u6210\u989c\u8272\uff0c\u7136\u540e\u5728\u5149\u7ebf\u4e0a\u91c7\u6837\u4f53\u5bc6\u5ea6\u5927\u7684\u70b9\uff0c\u91c7\u6837N f \u4e2a\u4f5c\u4e3a\u7b2c\u4e8c\u7ec4\u91c7\u6837\u70b9\uff0c\u5728\u7b2c\u4e00\u7ec4\u548c\u7b2c\u4e8c\u7ec4\u91c7\u6837\u7684\u5e76\u96c6\u4e0a\u8ba1\u7b97\"fine\"\u7f51\u7edc\uff0c\u5e76\u8ba1\u7b97\u6700\u7ec8\u7684\u6e32\u67d3\u989c\u8272\u3002","title":"5.2 \u5206\u5c42\u4f53\u79ef\u91c7\u6837(Hierarchical volume sampling)"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#53-\u5b9e\u73b0\u7ec6\u8282","text":"\u200b \u6211\u4eec\u4e3a\u6bcf\u4e2a\u573a\u666f\u4f18\u5316\u4e00\u4e2a\u5355\u72ec\u7684\u795e\u7ecf\u8fde\u7eed\u4f53\u79ef\u8868\u793a\u7f51\u7edc\u3002\u9700\u8981\u7684\u53c2\u6570\u6709\uff1aRGB\u56fe\u50cf\u6570\u636e\u96c6\u3001\u76f8\u5e94\u7684\u76f8\u673a\u5916\u53c2\u548c\u5185\u53c2\u4ee5\u53ca\u573a\u666f\u8fb9\u754c\u3002\u5728\u6bcf\u6b21\u4f18\u5316\u8fed\u4ee3\u4e2d\uff0c\u6211\u4eec\u4ece\u6570\u636e\u96c6\u4e2d\u7684\u6240\u6709\u50cf\u7d20\u96c6\u5408\u4e2d\u968f\u673a\u91c7\u6837\u4e00\u6279\u76f8\u673a\u5149\u7ebf\uff0c\u7136\u540e\u6309\u7167 \\(5.2\\) \u4e2d\u7684\u5206\u5c42\u91c7\u6837\u3002\u6700\u540e\u7684\u635f\u5931\u53ea\u662fcourse\u548cfine\u7684\u6e32\u67d3\u50cf\u7d20\u548c\u771f\u5b9e\u50cf\u7d20\u989c\u8272\u4e4b\u95f4\u7684\u5e73\u65b9\u8bef\u5dee\u3002 \u200b \u5176\u4e2d\uff0c \\(R\\) \u4e3abatch\u4e2d\u7684\u5149\u7ebf\u96c6\uff0c \\(C(r),C_{c}(r),C_{f}(r)\\) \u4e3aGT\uff0ccourse\u7f51\u7edc\u9884\u6d4b\uff0cfine\u7f51\u7edc\u9884\u6d4b\u7684RGB\u989c\u8272\u3002","title":"5.3 \u5b9e\u73b0\u7ec6\u8282"},{"location":"%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/NeRF/#6-results","text":"\u4e24\u79cd\u6570\u636e\u96c6\uff1a Synthetic renderings of objects Real images of complex scenes nerf-pytorch\u4ee3\u7801\u9605\u8bfb\u7b14\u8bb0\uff1a nerf-notes \u4e0a\u624bpytorch\uff1a 60\u5206\u949f\u6559\u4f60\u4e0a\u624bPyTorch + \u8fc1\u79fb\u5b66\u4e60","title":"6 Results"}]}